

9
=


Metaprogramming
===============


This chapter covers:



* What metaprogramming is and how to best use it
* Using generics to remove code duplication
* What the Abstract Syntax Tree is
* Executing code at compile-time
* Using templates and macros



This chapter describes one of the most advanced as well as most powerful features in the Nim programming language. This feature is called *metaprogramming* and it is composed of a number of components including *generics*, *templates*, and *macros*.


Metaprogramming is a feature of Nim that gives you the ability to treat your application’s source code as data. This means that you can write code which reads, generates, analyses and modifies other code. Being able to perform such activities brings many advantages, for example it allows you to minimize the number of lines of code needed to express a solution. In turn this means that metaprogramming reduces development time.


Generating code is usually easy enough in most languages, but reading, analysing and modifying it is not. Consider the following simple type definition:




```
type
  Person = object
    name: string
    age: int
```


Analysing this code to retrieve information about the `Person` type is not easy in a language without metaprogramming. You could attempt to treat the type definition as a string and parse it, but doing so would be very error prone. In Nim there are facilities in place to allow you to analyse type definitions. You may for example wish to iterate over each of the fields in a specified type:




```
import macros

type
  Person = object
    name: string
    age: int

static:
  for sym in getType(Person)[2]:
    echo(sym.symbol)
```


Compiling the above code will display the strings `name` and `age` among the compiler’s output.


That is just one example of what metaprogramming allows you to accomplish. You might use this to serialize any data type, without having to write code specific to each data type defined by you or anyone else. You will find that through this and many other features, metaprogramming opens up a vast number of possibilities.


Metaprogramming adds a lot of flexibility to the Nim programming language, and because the metaprogramming code is executed at compile-time it does so without causing any decrease in your program’s execution time.


In this chapter you will learn about the three metaprogramming constructs, starting with *generics*, going onto *templates* and finishing with *macros*. At the end you will see how to write a simple *Domain Specific Language* for configuration files. Domain Specific Languages are languages which are specialized to a particular application domain, see section 9.4 for more information.




9.1  Generics
=============



As you already know Nim is a statically typed programming language, this means that each piece of data in Nim has a type associated with it. In some cases these types are distinct but very similar, for example the `int` and `float` types both represent numbers, but the former cannot represent a fraction whereas the latter can.


*Generics* are a feature that allow you to write your applications in a style called generic programming. In *Generic Programming*, you write algorithms in terms of types that are not known until the algorithm is invoked. Generic programming is useful because it offers a reduction in code duplication.


Generics are related to the two other metaprogramming components in Nim, namely templates and macros, because they offer a way to generate repetitive code. This section will cover generics in procedures and types, showing you how to best utilize them in those contexts. It will also briefly show you how generics can be constrained to make the definitions of algorithms more accurate.


Some languages refer to generics as *parametric polymorphism* or as *templates*. Many prominent statically typed programming languages include support for generics including Java, C#, C++, Objective C and Swift. There are also a few which consciously omit the feature, the Go programming language is infamous for doing so.




9.1.1  Generic Procedures
-------------------------



To give you a better idea of how generics in Nim work, take a look at the following implementation of a generic `myMax` procedure:




```
proc myMax[T](a, b: T): T =
  if a < b:
    return b
  else:
    return a

doAssert myMax(5, 10) == 10
doAssert myMax(31.3, 1.23124) == 31.3
```


The key part of the example is the first line. There, a generic type `T` is defined in square brackets after the procedure name, and it is then used as the type of the parameters `a` and `b` as well as the procedure’s return type.


Occassionally the compiler may not be able to infer generic types, in that case you can specify them explicitly using square brackets as shown in the following code:




```
doAssert myMax[float](5, 10.5) == 10.5
```


The above code tells the compiler explicitly that the generic type `T` should be instantianted to `float` for this `myMax` procedure call.


Most of the time, the compiler does do a good job of inferring the type of `T`. For example, if you specify an int literal as the first argument and a float literal as the second. The compiler will implicitly convert the first argument to a float.




```
doAssert myMax(5, 10.5) == 10.5
```


The above code will compile successfully even though the two arguments passed to the `myMax` procedure do not have the same type.


You can define as many generic types in a procedure definition as you want. Currently the `myMax` procedure only accepts two arguments of the same type. This means that the following procedure call will fail with a `type mismatch` error.




```
doAssert myMax(5'i32, 10.5) == 10.5
```


The reason the above code fails to compile is because the type of argument `a` is `int32`, whereas the type of `b` is `float`. The `myMax` procedure defined above can only be called with arguments of the same type.





9.1.2  Generics in type definitions
-----------------------------------



When writing Nim code, you may run into cases when you would like to specify the type of one or more fields in an object during initialisation. That way you can have a single type definition, but be able to specialise it on a case-by-case basis.


This is useful for container types, such as lists and hash maps. A simple single item generic container can be defined like so:




```
type
  Container[T] = object
    empty: bool
    value: T
```


The above code defines a `Container` type which accepts a generic type `T`. The type of the `value` that the `Container` type stores is then determined by the generic type `T` specified when a `Container` variable is defined.


A constructor for the `Container` type can be defined like so:




```
proc initContainer[T](): Container[T] =
  result.empty = true
```


You can then call this constructor like so:




```
var myBox = initContainer[string]()
```


Specifying the generic type in between the square brackets is currently mandatory. This means that the following code will not work:




```
var myBox = initContainer()
```


Compiling this code will result in the `Error: cannot instantiate: 'T'` error message. As mentioned previously, the compiler can’t always infer the generic types, this is one case where it cannot.





9.1.3  Constraining generics
----------------------------



Occasionally you may wish to limit the types accepted by a generic procedure or type definition. This is useful for making the definition stronger and therefore more clear to yourself and other users of your code. Consider the `myMax` procedure defined previously, and what happens when it is called with two strings:




```
proc myMax[T](a, b: T): T =
  if a < b:
    return b
  else:
    return a

echo myMax("Hello", "World")
```


If you save this code, compile and run it then you will see the string `"World"` displayed.


Let’s assume that we don’t want our algorithm to be used with a pair of strings, but only with integers and floats. We can constrain the `myMax` procedure’s generic type like so:




```
proc myMax[T: int | float](a, b: T): T =
  if a < b:
    return b
  else:
    return a

echo myMax("Hello", "World")
```


Compiling this code will fail with the following error:




```
/tmp/file.nim(7, 11) Error: type mismatch: got (string, string)
but expected one of:
proc myMax[T: int | float](a, b: T): T
```


To make the constraint process more flexible, Nim offers a small number of *type classes*. A *type class* is a special pseudo-type that can be used to match against multiple types in a constraint context. You can define custom type classes like so:




```
type
  Number = int | float | uint

proc isPositive(x: Number): bool =
  return x > 0
```


Many are already defined for you in the `system` module. There is also a number of built-in type classes which match whole groups of types, you can find a list of them in the Nim Manual. [[26]](#ftn.d5e10335)





9.1.4  Concepts
---------------



*Concepts*, sometimes known as *user-defined type classes* in other programming languages, are a construct that can be used to specify arbitrary requirements that a matched type must satisfy. They are useful for defining a kind of interface for procedures, but they are still an experimental Nim feature. This section will give you a quick overview of concepts, without going into too much detail because their semantics may still change.


The `max` procedure defined earlier includes a constraint that limits it to accepting only `int` and `float` types as parameters. But for the purposes of the `max` procedure, it makes more sense to accept any type that has the `<` operator defined for it. A concept can be used to specify this requirement in the form of code.




```
type
  Comparable = concept a   ❶
    (a < a) is bool   ❷

proc max(a, b: Comparable): Comparable =
  if a < b:
    return b
  else:
    return a
```




|  |  |
| --- | --- |
| [❶](#CO1-1) | A concept definition is introduced with the `concept` keyword, what follows are the type identifiers. |
| [❷](#CO1-2) | This line specifies that for this concept to match the type, a `<` procedure that returns a `bool` value must be defined for the type. |




A concept is composed of one or more expressions. These expressions usually utilize the instances that are defined after the `concept` keyword. When a type is checked against a concept, the type is said to implement the concept as long as:



* All the expressions in the `concept` body compile, and
* All the expressions which evaluate to a boolean value are true.



The `is` operator determines whether the specified expression returns a value of type `bool`, by returning `true` if it does and `false` if it doesn’t.


We can check whether the `Comparable` concept works as expected by writing some quick tests, the following has been taken from a previous example.




```
doAssert max(5, 10) == 10
doAssert max(31.3, 1.23124) == 31.3
```


You would expect both lines to work and they do. The first line specifies two `int` arguments, a `proc `<`(a, b: int): bool` exists so `int` satisfies the `Comparable` concept. The second line specifies two `float` arguments, and similarly a `proc `<`(a, b: float): bool` also exists.


But attempting to pass two arrays into the `max` procedure by writing `echo max([5, 3], [1, 6])` fails with:




```
/tmp/file.nim(11, 9) Error: type mismatch: got (Array constructor[0..1, int], Array constructor[0..1, int])
but expected one of:
proc max[Comparable](a, b: Comparable): Comparable
proc max(x, y: int): int
proc max(x, y: int8): int8
...
```


Concepts are powerful, but they are also a very new Nim feature and as such are considered experimental. Due to their experimental nature, this chapter will not go into detail about them but you are more than welcome to learn about them in the Nim manual. [[27]](#ftn.d5e10391) Right now, let’s move on to templates.





  


[[26]](#d5e10335) Nim Manual: Typeclasses, <http://nim-lang.org/docs/manual.html#generics-type-classes>




[[27]](#d5e10391) Nim Manual: Concepts, <http://nim-lang.org/docs/manual.html#generics-concepts>







9.2  Templates
==============



A *template* in Nim is a procedure that generates code. Templates offer one of the easiest ways to generate code directly, the other being *macros* which you will learn about in the next section. Unlike generics, they offer a substitution mechanism that allows you to substitute arguments passed to them in the body of the template. Just like with all metaprogramming features, their code generation ability helps you deal with boilerplate code.


In general, templates offer a simple way to reduce code duplication. Some features, like the ability to inject variables into the calling scope are easiest to achieve in Nim by defining a template.


Templates are invoked in the same way as procedures. When the Nim compiler compiles your source code, any template invokations are substituted with the contents of the template. As an example, take a look at the following template from the standard library:




```
template `!=` (a, b: untyped) =   ❶
  not (a == b)
```




|  |  |
| --- | --- |
| [❶](#CO2-1) | Don’t worry about the `untyped` type right now, it will be explained later. |




It would be possible to define the `!=` operator as a procedure, but this would require a separate implementation for each type. To get around this, you could of course use generics but doing so would result in a lot more call overhead.


This definition of `!=` means that the following:




```
doAssert(5 != 4)
```


Is rewritten as:




```
doAssert(not (5 == 4))
```


This is done during the process of compilation, as shown in *Figure 9.1*.




Figure 9.1. Templates are expanded during the compilation of Nim source code


![ch09 template compilation](../Images/ch09_template_compilation.png)

The primary purpose of templates is to offer a simple substituting mechanism which reduces the need for code duplication. In addition to this there is one feature that templates offer which procedures don’t, a template can accept code statements.




9.2.1  Passing a code block to a template
-----------------------------------------



Code blocks are composed of one or more statements. In an ordinary procedure call, passing multiple statements into it can only be done using an anonymous procedure. With templates, you can pass a code block much more easily. Nim supports a special syntax for templates, which allows one or more code statements to be passed to them.


The following code listing shows a template definition which accepts a code block as one of its parameters.




```
import os        ❶
template repeat(statements: untyped) =   ❷
  while true:
    statements   ❸

repeat:          ❹
  echo("Hello Templates!")
  sleep(1000)
```




|  |  |
| --- | --- |
| [❶](#CO3-1) | Needed for the `sleep` procedure. |
| [❷](#CO3-2) | The template accepts a `statements` parameter, this corresponds to the code block. |
| [❸](#CO3-3) | The code block is substituted into here. |
| [❹](#CO3-4) | Templates which accept code blocks are used like this. |




 





> Tip Code blocks in macros |
| Macros, which you will learn about in the next section, also support code blocks as parameters. |



The `statements` identifier in the body of the template is replaced with whatever code block is passed into the template. After the compiler expands the template, the remaining code looks as follows:




```
import os

while true:
  echo("Hello Templates!")
  sleep(1000)
```


Figure 9.2 shows the code that is generated by the `repeat` template which accepts a code block as an argument.




Figure 9.2. A code block passed into the `repeat` template is substituted into its body


![ch09 template body](../Images/ch09_template_body.png)

This shows some of the amazing substitution capabilities of templates. Of course, template parameters don’t always have to accept a code block. The next section describes how template parameters are substituted in the body of a template and how the parameter’s type affects this.





> Tip Multiple code-blocks |
| There are also ways to pass multiple code blocks to a template or macro via the `do` notation. But this is beyond the scope of this chapter. See the Nim manual for more information. [[28]](#ftn.d5e10470) |



It’s important to know how code blocks and other parameters interact. The rule is that when a code block is passed into a template, the last parameter always contains it. For example:




```
import os
template repeat(count: int, statements: untyped) =   ❶
  for i in 0 .. <count:
    statements

repeat 5:
  echo("Hello Templates!")
  sleep(1000)
```




|  |  |
| --- | --- |
| [❶](#CO4-1) | The last parameter named `statements` contains the code block. |







9.2.2  Parameter substitution in templates
------------------------------------------



Templates can accept multiple parameters, these parameters are often simple identifiers such as variable or type names. In this section I will explain the different template-specific parameter types and how they modify the parameter substitution behaviour in templates.


Arguments can be passed into templates in the same manner as with procedures:




```
template declareVar(varName: untyped, value: typed) =   ❶
  var varName = value   ❷

declareVar(foo, 42)     ❸
echo(foo)
```




|  |  |
| --- | --- |
| [❶](#CO5-1) | The template’s return value is `untyped` because it is a statement that has no type. |
| [❷](#CO5-2) | Whatever arguments are passed into the template, they will replace the `varName` and `value` in this line. |
| [❸](#CO5-3) | Will be expanded to: `var foo = 42`. |




When the `declareVar` template is called, it expands into a simple variable declaration. The name and value of the variable is specified in the template using two arguments. The arguments differ in type, the first being `untyped` and the second `typed`. The difference between these two types is simple.


Figure 9.3 shows how the `declareVar` template produces code that defines a new variable.




Figure 9.3. Arguments are substituted as-is in templates, their type determines whether an undefined identifier is accepted


![ch09 template args](../Images/ch09_template_args.png)

An `untyped` template argument allows identifiers which have not been declared yet to be specified. The reason this type is named `untyped` is because undeclared identifiers have no type yet. The `foo` identifier in the example above isn’t declared anywhere and is thus `untyped`.


A `typed` template argument allows an identifier which has been declared, or a value that has a type to be specified. In the example above, the value `42` has a type `int`. The `typed` type allows any type to be specified, but templates also allow you to specify concrete types like `int`, `float`, and `string`.


To demonstrate the difference in more detail, take a look at the following `declareVar` calls:




```
var myInt = 42
declareVar(foo, myInt)   ❶

declareVar(foo, myUndeclaredVar)   ❷
```




|  |  |
| --- | --- |
| [❶](#CO6-1) | This will compile because `myInt` is declared above. |
| [❷](#CO6-2) | This will not compile because `myUndeclaredVar` is not declared anywhere. |




Remember that the second parameter is `typed` and so undeclared variables cannot be passed to it. Only if a variable by that name is defined can it be passed into it.


Compiling the above code will result in an "undeclared identifier" error.





9.2.3  Template hygiene
-----------------------



As shown with the `declareVar` template above, templates can define variables that are accessible after the template is invoked. This feature may not always be desirable, there are cases when you may wish to declare a variable inside a template without exposing it to the outside scope. The ability to do this is referred to as *template hygiene*.


Consider the previous template example again:




```
template declareVar(varName: untyped, value: typed) =
  var varName = value

declareVar(foo, 42)
echo(foo)
```


Calling the `declareVar` template declares a new variable. This is because the `varName` variable is *injected* into the calling scope. The injection occurs automatically because the name of the variable is taken from the template’s arguments. Normally variables are not injected in templates, unless they are marked explicitly with the `{.inject.}` pragma. The following code listing shows a comparison of the different cases where variables are injected and where they aren’t:




```
template hygiene(varName: untyped) =
  var varName = 42        ❶
  var notInjected = 128   ❷
  var injected {.inject.} = notInjected + 2   ❸

hygiene(injectedImplicitly)

doAssert(injectedImplicitly == 42)
doAssert(injected == 130)
```




|  |  |
| --- | --- |
| [❶](#CO7-1) | Injected implicitly because its name is taken from the `varName` argument. |
| [❷](#CO7-2) | Only accessible in this template. |
| [❸](#CO7-3) | Injected because of the `{.inject.}` pragma, note how the `notInjected` variable can still be used. |




Attempting to access the `notInjected` variable outside the template will result in a `Error: undeclared identifier: 'notInjected'` message. The other variables are accessible because they are injected by the template into the calling scope.


When writing templates make sure that you document precisely the variables that are injected by it, and be careful that only those variables are exposed. Keep in mind that in general injecting variables is considered bad style. The standard library only ever injects `it` within the likes of `mapIt`.


The hygiene rules demonstrated above are the same for the following definitions:



* `type`
* `var`
* `let`
* `const`



These definitions are all hygienic by default. The rules are opposite for the following definitions:



* `proc`
* `iterator`
* `converter`
* `template`
* `macro`



These definitions are not hygienic by default. The reasons for these rules is to capture the most common use cases without annotations.


The next section explains *macros*, a component of Nim related to templates that is a lot more flexible and many times more powerful than templates.




  


[[28]](#d5e10470) Do notation in the Nim manual, <http://nim-lang.org/docs/manual.html#procedures-do-notation>







9.3  Macros
===========



A macro in Nim is a special kind of procedure that is executed at compile-time and which returns a Nim expression or statement. Macros are the ultimate way to read, generate, analyse, and modify Nim code. In the world of computer science, they exist in many different forms. Templates are indeed a form of macro, albeit a very simple form that mostly consists of a simple substitution. Templates are said to be *declarative* because in their body they show what the code that should be produced looks like, instead of describing the steps needed to produce that code.


A Nim *macro* on the other hand is said to be *procedural* because it contains steps which describe the code that should be produced. In fact, when macros are invoked their body is executed at *compile-time*. Because of this, a related feature of the Nim programming language called *compile-time function execution* is also relevant to the study of macros. This feature allows procedures to be executed by the compiler during compilation, you will learn more about it in the next sub-section.


Macros operate on Nim code, but not in the same way that you operate on code. You, as a programmer, are used to dealing with the textual representation of code. You write, read and modify code as text. But macros don’t work that way, they operate on a different representation, and that representation is known as an *Abstract Syntax Tree*. The Abstract Syntax Tree is a special tree structure that represents code, you will learn more about it later in the Abstract Syntax Trees sub-section.


Figure 9.4 shows the primary difference between templates and macros.




Figure 9.4. Templates are declarative whereas macros are procedural.


![ch09 template macros](../Images/ch09_template_macros.png)

This section will take you through each of these concepts in order to teach you the ins and outs of macros. At the end you will also get to use your new macro skills to write a simple configuration library.




9.3.1  Compile-time Function Execution
--------------------------------------



*Compile-time function execution* (CTFE) is a feature of Nim that allows procedures to be executed at compile time. This is a powerful feature that is relatively uncommon among programming languages.


CTFE was introduced to you briefly in *Chapter 2* already, you were shown that the value of a constant in Nim must be computable at compile-time.




```
proc fillString(): string =
  result = ""
  echo("Generating string")
  for i in 0 .. 4:
    result.add($i)

const count = fillString()
```


When the above code listing is compiled the message "Generating string" will be shown among the compilation messages. This is because the `fillString` procedure is executed at compile-time.


Compile-time execution has some limits, these include:



* No access to the Foreign Function Interface (FFI), this means that some modules/procedures cannot be used. For example, you cannot generate random numbers at compile-time because of this, unless you do so indirectly using `staticExec`.
* Global variables which are not annotated with the `{.compileTime.}` pragma cannot be accessed at compile-time.



Despite these limits, Nim includes workarounds to allow common operations like reading files and executing external processes at compile time. These operations can be performed using the `staticRead` and `staticExec` procedures respectively.


Due to the fact that macros are used to generate, analyse and modify code they must also be executed at compile time. This means that the same limits apply to them as well.





9.3.2  Abstract Syntax Trees
----------------------------



An *Abstract Syntax Tree* (AST) is a data structure that represents source code. Many compilers use it internally after the source code is initially parsed, some like the Nim compiler expose it to the user.


The AST is a tree, with each node representing a single construct in the code. To get a better idea of what an AST is, let’s take a look at an example of one. Consider a simple arithmetic expression such as `5 * (5 + 10)`, the simplest AST for this might look something like the one shown in Figure 9.5.




Figure 9.5. A diagram representing the simple AST for `5 * (5 + 10)`


![ch09 ast simple](../Images/ch09_ast_simple.png)

From now on, I will refer to this AST as the *Simple AST* throughout the rest of this chapter. Let’s look at how the Simple AST can be represented as a Nim data type. *Listing 9.1* shows the definition for a `Node` type that is then used to model the Simple AST shown in Figure 9.5.




Listing 9.1. Modelling the Simple AST shown in Figure 9.5 using a custom data type.




```
type
  NodeKind = enum
    Literal, Operator     ❶

  Node = ref object
    case kind: NodeKind
    of Literal:
      value: int          ❷
    of Operator:
      left, right: Node   ❸
      operator: char      ❹

proc newLiteralNode(value: int): Node =   ❺
  result = Node(
    kind: Literal,
    value: value
  )

var root = Node(          ❻
  kind: Operator,
  operator: '*',
  left: newLiteralNode(5),
  right: Node(
    kind: Operator,
    operator: '+',
    left: newLiteralNode(5),
    right: newLiteralNode(10),
  )
)
```




|  |  |
| --- | --- |
| [❶](#CO8-1) | In the Simple AST there are only two node kinds: literals which include any number, and operators which specify the type of arithmetic operation to perform. |
| [❸](#CO8-3) | Each node may have up to two children nodes. This recursive definition allows a tree to be formed. |
| [❷](#CO8-2) | When the node is a literal then an `int` can be stored in its `value` field. |
| [❹](#CO8-4) | When the node is a literal then a `char` can be stored in its `operator` field. |
| [❺](#CO8-5) | A convenience proc to create a new literal node. |
| [❻](#CO8-6) | The `root` variable holds a reference to the *root* node in the AST. |





The `root` node now holds the full representation of `5 * (5 + 10)` in the form of an AST. *Figure 9.6* shows how the Simple AST diagram maps to the `Node` data structure defined in *Listing 9.1*.




Figure 9.6. An annotated *Figure 9.5* showing how it maps onto `root` in *Listing 9.1*


![ch09 ast simple annotated](../Images/ch09_ast_simple_annotated.png)

You could now write a procedure to convert any `Node` instance into its textual representation, or to display it as a tree using an indentation-based format like so:




Listing 9.2. A simplified AST for `5 * (5 + 10)` displayed using an indentation-based format




```
Operator '*'
  Literal 5
  Operator '+'
    Literal 5
    Literal 10
```



Nim’s AST is unfortunately not as simple as this, it models a language that is far more complex than simple arithmetic expressions. The arithmetic expression modelled by the Simple AST is also valid Nim code, this means that we can compare Nim’s AST to it. To do this we can use the `dumpTree` macro defined in the `macros` module, this macro takes a block of code as input and outputs the code block’s AST in the same indentation-based format as shown in *Listing 9.2*.


To display the AST of `5 * (5 + 10)` in Nim, compile the following code listing:




```
import macros

dumpTree:
  5 * (5 + 10)
```


Among the messages from the compiler you should see:




```
StmtList
  Infix
    Ident !"*"
    IntLit 5
    Par
      Infix
        Ident !"+"
        IntLit 5
        IntLit 10
```


You will note that the Nim AST differs in two important ways:



* It includes many more node kinds, for example `StmtList`, `Infix`, and `Ident`, and
* The AST is no longer a binary tree: some nodes contain more than 2 children.



But the structure is the same, the AST just contains more information about the expression. For example, it defines that infix notation was used to invoke the `*` and `+` operators, and that a part of the expression is enclosed in parenthesis.


The AST can represent any valid Nim code, because of this there is a large number of node kinds. To get a feel of the different node kinds, try displaying the AST of some common constructs such as procedures, for loops, procedure calls, variable declarations and anything else you can think of.


The Nim AST is described in the documentation for the `macros` module available at the following URL: <http://nim-lang.org/docs/macros.html> The documentation includes the definition of a `NimNode` type that is very similar to the `Node` type defined in *Listing 9.1*. The `macros` module also contains many procedures that can be used for building, modifying and reading the AST.


Before moving on, let’s look at some of these node kinds. *Table 9.1* describes each of the node kinds in the Nim AST that you have seen so far.




Table 9.1. Various Nim node kinds and what they mean









| Node Kind | Description | Children |
| `StmtList` | A list of statements. | Arbitrary number of other Nim nodes that represent a statement. |
| `Infix` | An infix expression, for example `5 * 5`. | Infix operator, the infix operator’s two arguments. |
| `Ident` | An identifier, such as the name of a procedure or variable. The node’s `ident` field contains the identifier. | *Cannot contain children*. |
| `Par` | Parenthesis | The code inside the parenthesis. |
| `IntLit` | An integer literal. The node’s `intVal` field contains the integer value. | *Cannot contain children*. |




Let’s try to build the Nim AST of `5 * (5 + 10)` using the procedures defined in the `macros` module, similar to the definition of `root` in *Listing 9.1*. *Listing 9.3* shows the code needed to create `5 * (5 + 10)`'s Nim AST.




Listing 9.3. Creating the Nim AST of `5 * (5 + 10)`




```
import macros   ❶
 
static:         ❷
  var root = newStmtList(
    infix(
      newIntLitNode(5),
      "*",
      newPar(
        infix(
          newIntLitNode(5),
          "+",
          newIntLitNode(10)
        )
      )
    )
  )
  echo(root.repr)   ❸
```




|  |  |
| --- | --- |
| [❶](#CO9-1) | The `macros` module defines all the necessary procedures for constructing the AST. |
| [❷](#CO9-2) | The `static` keyword runs its body at compile-time. Used because the AST procedures are only available at compile-time. |
| [❸](#CO9-3) | The `repr` call converts the `root` node to a textual representation of the Nim code. |





Compile *Listing 9.3* and note that the output is `5 * (5 + 10)`. You have successfully constructed your first Nim AST!





9.3.3  Macro definition
-----------------------



So far you have learned about what an AST is, how it can be constructed and different ways of displaying it during compilation. But you’re still missing a very important piece of knowledge: emitting a produced AST so the Nim code it represents is included in the final executable application.


A `macro` is used for precisely that purpose. In the previous section, you have constructed the AST of a simple arithmetic expression that produces a numeric value. Let’s write a macro that emits this AST so that the arithmetic expression can be calculated.




Listing 9.4. A macro that emits `5 * (5 + 10)`




```
import macros    ❶

macro calculate(): int =   ❷
  result = newStmtList(    ❸
    infix(       ❹
      newIntLitNode(5),    ❺
      "*",       ❻
      newPar(    ❼
        infix(   ❽
          newIntLitNode(5),
          "+",   ❻
          newIntLitNode(10)
        )
      )
    )
  )

echo(calculate())
```




|  |  |
| --- | --- |
| [❶](#CO10-1) | Import the `macros` module which is necessary for AST creation. |
| [❷](#CO10-2) | Define a new macro called `calculate`. |
| [❸](#CO10-3) | Create a new `StmtList` node with children. Resulting node produces `5 * (5 + 10)`. |
| [❹](#CO10-4) | Create a new `Infix` node as a child of the `StmtList` node. Resulting node produces `5 * (5 + 10)`. |
| [❺](#CO10-5) | Create a new `IntLit` node as a child of the `Infix` node. Resulting node produces `5`. |
| [❻](#CO10-6) | Specifies the infix operator to call. |
| [❼](#CO10-7) | Create a new `Par` node as a child of the `Infix` node. Resulting node produces `(5 + 10)`. |
| [❽](#CO10-8) | Create a new `Infix` node as a child of the `Par` node. Resulting node produces `5 + 10`. |





There are two important things to note about *Listing 9.4*. The first is that macros can be invoked in the same way as procedures and templates. The second is the AST tree structure constructed in the body of the macro.


The `calculate` macro currently generates only a single expression, so the `StmtList` node can be safely removed. The new definition of the `calculate` macro is shown in *Listing 9.5*.




Listing 9.5. Generating a single expression in a macro




```
import macros

macro calculate(): int =
  result = infix(       ❶
    newIntLitNode(5),   ❷
    "*",      ❸
    newPar(   ❹
      infix(
        newIntLitNode(5),
        "+",
        newIntLitNode(10)
      )
    )
  )

echo(calculate())
```




|  |  |
| --- | --- |
| [❶](#CO11-1) | Creates a new `Infix` node. The resulting node produces `5 * (5 + 10)`. |
| [❷](#CO11-2) | Creates a new `IntLit` node. The resulting node produces `5`. |
| [❸](#CO11-3) | Specifies the infix operator to call. |
| [❹](#CO11-4) | Creates a new `Par` node. The resulting node produces `(5 + 10)`. |





The macro generates functionally equivalent code, with no extraneous AST nodes.


That was a very simple example of a macro, designed to show you how macros use the AST to emit Nim code. The equivalent template is much simpler and achieves the same thing:




```
template calculate(): int = 5 * (5 + 10)

echo(calculate())
```


The `calculate` macro produces a static AST, but the true power of macros is the ability to produce ASTs dynamically. The next section will show you how to best make use of this power.





9.3.4  Arguments in macros
--------------------------



Just like procedures and templates, when macros are called you may pass one or more arguments to them. Doing so allows you to alter the behaviour of your macro, which as a result changes the code that it produces. You may for example wish to pass the name of a variable that the macro should use in the code that it generates.


You should think about arguments passed to macros a little bit differently though. For example, a macro argument’s type may be `int`, but in the body of the macro it is a `NimNode`. The following code listing demonstrates this:




```
import macros

macro arguments(number: int, unknown: untyped): untyped =   ❶
  result = newStmtList()    ❷
  echo number.treeRepr()    ❸
  echo unknown.treeRepr()   ❸

arguments(71, ["12", "89"])
```




|  |  |
| --- | --- |
| [❶](#CO12-1) | Every macro must have a return type. |
| [❷](#CO12-2) | Every macro must generate a valid AST, an empty `StmtList` node is created here to satisfy this rule. |
| [❸](#CO12-3) | The `treeRepr` procedure is similar to the `dumpTree` macro, it returns a tetual representation of a `NimNode`. |




Compiling this listing will result in the following output:




```
IntLit 71   ❶
Bracket     ❷
  StrLit 12
  StrLit 89
```




|  |  |
| --- | --- |
| [❶](#CO13-1) | The AST of the first argument passed to the macro: `71`. |
| [❷](#CO13-2) | The AST of the second argument passed to the macro: `["12", "89"]`. |




There are two things that you need to take away from this example:



* A macro must always have a return type and it must always return a valid AST, even if that AST is essentially empty.
* All macro arguments are Nim AST nodes.



The latter point makes perfect sense because macros already manipulate the AST. Representing each macro argument as an AST node allows for constructs which ordinarily would not be possible in Nim, one example of this is the following:




```
arguments(71, ["12", 876, 0.5, -0.9])
```


This example displays the following AST for the second argument:




```
Bracket
  StrLit 12
  IntLit 876
  Float64Lit 0.5
  Prefix
    Ident !"-"
    Float64Lit 0.9
```


Arrays in Nim are *homogeneous* and so each value that they contain must be of the same type. Attempting to declare an array with the values `"12"`, `876`, `0.5`, `-0.9` would not be possible, because the value’s types include a `string`, an `int` and a `float`. In this case, macros give greater flexibility, allowing the possibility to use a heterogeneous array constructor when calling macros.


That should give you a good idea of the basic macro concepts. In the next section I will show you how to build a configuration DSL.






9.4  Creating a configuration DSL
=================================



One of the most useful abilities that metaprogramming allows is the creation of Domain-Specific Languages. A Domain-Specific Language (DSL) is a language that is specialized to a particular application domain. Within the bounds of Nim’s syntax, you can define very flexible and intuitive languages that make writing software easier. For example, you may write a DSL for defining the structure of HTML. Instead of writing a long string literal that is error prone, you will write something like the following:




```
html:
  head: title("My page")
  body: h1("Hello!")
```


That’s just one example, in this section I will show you how to create a configuration DSL. This DSL will allow you to more easily define the structure of a configuration file, which can then be used to read and write configuration files easily. You will first see how a typical DSL is represented in Nim’s AST, then you will look at the AST representation of the desired generated code, finally looking at how to build that AST based on the information specified by the user when they make use of the DSL.


The DSL that you will create as part of this chapter will allow the following code to be written:




```
import configurator

config MyAppConfig:
  address: string
  port: int

var config = newMyAppConfig()
config.load("myapp.cfg")
echo("Configuration address: ", config.address)
echo("Configuration port: ", config.port)
```


This code defines a simple configuration file named `MyAppConfig` which stores two pieces of information, an address that is a string and a port that is an integer. The definition is initialised using a constructor and then loaded from a local `myapp.cfg` file. The address and port are then accessible as fields and their values displayed on the screen.


Specifying a configuration like this is useful because it streamlines the process of reading and writing configuration files. There is only a single place where the configuration file is defined, and that place is very easy to read and understand.


This DSL will be written as a library named `configurator`. Let’s get started!




9.4.1  Starting the configurator project
----------------------------------------



Begin by creating a new `configurator` directory somewhere on your file system. As with any project, set up a project directory structure containing a `src` directory and a Nimble file. Remember that you can use the `nimble init` command to help with this. Finally, create a `configurator.nim` file inside the `src` directory and open it in your favourite code editor.


Macros will be used for the implementation of the configurator DSL, so import the `macros` module at the top of your newly created `configurator.nim` file.


When working on a DSL, it is a good idea to start by writing down what you would like it to look like. Chances are that it may not be possible due to syntax restrictions, so it’s a good idea to test it first. The easiest way to do so is to use the `dumpTree` macro defined in the `macros` module. For example, to test whether the configuration DSL can be used you can compile the following:




```
import macros

dumpTree:
  config MyAppConfig:
    address: string
    port: int
```


If the compilation succeeds then your DSL is syntactically valid in Nim and therefore will work.


After testing the validity of your DSL, write a macro for that DSL and display the various arguments' ASTs as shown in *Listing 9.6* below.




Listing 9.6. A simple `config` macro




```
import macros

macro config(typeName: untyped, fields: untyped): untyped =   ❶
  result = newStmtList()    ❷
  echo treeRepr(typeName)   ❸
  echo treeRepr(fields)     ❸

config MyAppConfig:
  address: string
  port: int
```




|  |  |
| --- | --- |
| [❶](#CO14-1) | The `config` macro takes a type name and a list of fields. |
| [❷](#CO14-2) | Each macro must return a valid AST, so we create a basic one here. |
| [❸](#CO14-3) | For now, we display the AST of the `typeName` and `fields` arguments. |





Save this code into `configurator.nim`, then compile the file. You will see the following among the output:




```
Ident !"MyAppConfig"
StmtList
  Call
    Ident !"address"
    StmtList
      Ident !"string"
  Call
    Ident !"port"
    StmtList
      Ident !"int"
```


This gives you an idea of the AST structure that you will be working with. Next it’s time to decide what code needs to be emitted in order to implement the desired code logic. For the purposes of implementing the example shown at the start of this section, the macro will need to create three separate constructs:



* A `MyAppConfig` object type, to store the configuration data.
* A `newMyAppConfig` constructor procedure that initialises a new `MyAppConfig` type.
* A `load` procedure that parses the specified file, then populates the specified instance of the `MyAppConfig` object with the information stored in the parsed file.



The name of the generated type and constructor procedure depends on the one specified in the `config` construction. The macro will need to make use of this information to change the code that it produces. The fields included in the generated type will also depend on the ones specified in the `config` construction.


The next three sections will focus on implementing functionality in the macro to create the three constructs, which include an object type, a constructor procedure and a `load` procedure.





9.4.2  Generating the object type
---------------------------------



Before beginning to write AST generation code in the macro, you will first need to figure out what AST you want to generate. To do this you need to know the Nim code that you want the macro to emit. Let’s start by writing down the type definition that should be generated by the `config` construct, you saw this construct earlier:




```
config MyAppConfig:
  address: string
  port: int
```


The type definition that needs to be generated from this is very simple:




```
type
  MyAppConfig = ref object
    address: string
    port: int
```


Two pieces of information specified in the `config` construct have been used to create this type definition, the type name `MyAppConfig` and the two fields named `address` and `port`. Just like any code, this code can be represented as an AST. You need to find out what the AST for it looks like in order to be able to generate it. Let’s take a look at the information that `dumpTree` shows us about this type definition.




```
import macros

dumpTree:
  type
    MyAppConfig = ref object
      address: string
      port: int
```


Compiling this code should show the AST in *Listing 9.7*.




Listing 9.7. The AST of the `MyAppConfig` type definition




```
StmtList
  TypeSection
    TypeDef
      Ident !"MyAppConfig"
      Empty       ❶
      RefTy
        ObjectTy
          Empty   ❶
          Empty   ❶
          RecList
            IdentDefs
              Ident !"address"
              Ident !"string"
              Empty   ❶
            IdentDefs
              Ident !"port"
              Ident !"int"
              Empty   ❶
```




|  |  |
| --- | --- |
| [❶](#CO15-1) | Empty nodes are there to reserve space for extra features like generics in the AST. |





The AST in *Listing 9.8* contains a large amount of `Empty` nodes. These exist for optional constructs like generics, in order to ensure that the index position of each node remains the same. This is important because navigating an AST is done using the `[]` operator and an index, which you will see in action later on in this chapter.


Now that you know what the AST that needs to be generated looks like, you can begin to write code for generating it. In some cases, the `macros` module contains procedures which make the process of generating an AST for a specific construct easier. Unfortunately in this case you will need to generate the AST in *Listing 9.7* manually using certain primitive procedures because there currently is no type section constructor in the `macros` module. *Listing 9.8* shows a procedure which generates a large chunk of the AST shown in *Listing 9.7*.




Listing 9.8. Generating the AST for a type definition




```
proc createRefType(ident: NimIdent, identDefs: seq[NimNode]): NimNode =   ❶
  result = newTree(nnkTypeSection,   ❷
    newTree(nnkTypeDef,      ❸
      newIdentNode(ident),   ❹
      newEmptyNode(),        ❹
      newTree(nnkRefTy,
        newTree(nnkObjectTy,
          newEmptyNode(),    ❹
          newEmptyNode(),    ❹
          newTree(nnkRecList,
            identDefs
          )
        )
      )
    )
  )
```




|  |  |
| --- | --- |
| [❶](#CO16-1) | This procedure takes two arguments and returns a new `NimNode`. The first argument is an identifier that specifies the name of the type to define. The second argument includes a list of *identifier definitions*, which includes information about the type’s fields. |
| [❷](#CO16-2) | Each node is created using the `newTree` procedure which allows children to be easily added during its creation. |
| [❸](#CO16-3) | Each child node is given as an argument to the outer `newTree` call. |
| [❹](#CO16-4) | There are certain specialised procedures which make the process of creating nodes easier. |





The code shown in *Listing 9.8* creates each node, one-by-one, manually. For this purpose, the `newTree` procedure is used. It takes a node kind as an argument together with zero or more child nodes. These child nodes are added to the resulting new Nim AST node returned by `newTree` automatically.


Each node kind begins with the `nnk` prefix, for example in the procedure’s body the first line shows the creation of a `nnkTypeSection` node. This matches the output of `dumpTree` shown in *Listing 9.7*, except that the output does not contain the `nnk` prefixes.


Note the striking similarities between the `dumpTree` output shown in *Listing 9.7* and the code in *Listing 9.8*. The way in which the nodes are nested is even the same. The differences lie in the procedure calls, most of them involve `newTree` but there are also a couple of specialised procedures. These specialised procedures include the following.


The `newIdentNode` procedure is used to create an `nnkIdent` node. It takes either a `string` or a `NimIdent` argument and creates an appropriate `nnkIdent` node out of it. It can also be created via `newTree` but doing so would be more verbose as the ident would need to also be assigned. An ident node can refer to any identifier such as variable or procedure name, but much like in this case it may contain an identifier which has not been defined yet.


The `newEmptyNode` procedure creates a new `nnkEmpty` node. It is simply an alias for `newTree(nnkEmpty)`.


The `createRefType` procedure does not generate the full AST shown in *Listing 9.7*. It misses out on a key part, the `identDefs`. Instead it accepts them as an argument and assumes that they were generated somewhere else. A single `nnkIdentDefs` node represents a field definition, including the name and type of the field. In order to generate these, let’s define a new procedure. *Listing 9.9* shows the `toIdentDefs` procedure which converts a list of call statements to a list of `nnkIdentDefs` nodes.




Listing 9.9. Converting a list of call statements to a list of `IdentDefs` nodes




```
proc toIdentDefs(stmtList: NimNode): seq[NimNode] =
  expectKind(stmtList, nnkStmtList)   ❶
  result = @[]        ❷

  for child in stmtList:              ❸
    expectKind(child, nnkCall)        ❹
    result.add(       ❺
      newIdentDefs(   ❻
        child[0],     ❼
        child[1][0]   ❽
      )
    )
```




|  |  |
| --- | --- |
| [❶](#CO17-1) | Ensures that the `stmtList` node is of kind `nnkStmtList`. |
| [❷](#CO17-2) | Initialises the `result` variable with an empty sequence. |
| [❸](#CO17-3) | Iterates over all child nodes in `stmtList`. |
| [❹](#CO17-4) | Ensures that the `child` node is of kind `nnkCall`. |
| [❺](#CO17-5) | Adds a `nnkIdentDefs` node to the `result` sequence. |
| [❻](#CO17-6) | Creates a new `nnkIdentDefs` node. |
| [❼](#CO17-7) | The field name. The `child`'s first child, for example `Call` → `Ident !"address"`. |
| [❽](#CO17-8) | The field type. The `child`'s second child’s child, for example `Call` → `StmtList` → `Ident !"string"`. |





The `stmtList` argument that will be passed to the `toIdentDefs` procedure is the second argument in the `config` macro. More to the point, as you saw previously, the AST of `stmtList` will look like this:




```
StmtList
  Call
    Ident !"address"
    StmtList
      Ident !"string"
  Call
    Ident !"port"
    StmtList
      Ident !"int"
```


It is the job of the `toIdentDefs` procedure to take this AST and convert it to a list of `nnkIdentDefs` nodes which match the ones seen in *Listing 9.7*. The code is fairly short, it could be shortened further at the cost of some error checking.


The `expectKind` procedure is used to ensure that the input AST does not contain any unexpected node kinds. It is a good idea to use this when writing macros as sometimes your macro may get an unusual AST, adding such checks makes debugging easier and is akin to using the `doAssert` procedure.


The conversion process is fairly simple:



* The statement list node’s children are iterated over.
* Each child’s children and grandchildren are accessed using the `[]` operator to retrieve the two identifiers corresponding to the name and type of the fields.
* The `newIdentDefs` procedure is used to create a new `nnkIdentDefs` node.
* The new `nnkIdentDefs` node is added to the `result` sequence.



Obviously the conversion depends on the structure of this very AST, the indexing especially so. Thankfully the structure shouldn’t change, unless the user of the `configurator` library passes something unexpected in the `config` macro’s body. Later in this section you will see how this code reacts to different inputs and how to make the failures more informative.


Right now you have defined enough to generate the correct type definition in the `config` macro. All you need to do is add a call to `createRefType` and `toIdentDefs`.




```
let identDefs = toIdentDefs(fields)
result.add createRefType(typeName.ident, identDefs)
```


Add these two lines after the `result` variable is defined in your macro. Then at the end of the macro, add `echo treeRepr(result)` to display the produced AST. Compile the code and your AST should match the one shown in *Listing 9.7*.


Another way to confirm that the generated AST is correct is to convert it to code and display that. You can do so by writing `echo repr(result)` at the end of your file. After compiling you should see the following:




```
type
  MyAppConfig = ref object
    address: string
    port: int
```


That’s the first and most lengthy part of this macro finished! The two last remaining parts shouldn’t take as long.





9.4.3  Generating the constructor procedure
-------------------------------------------



The `config` macro can now generate a single type definition. But this type definition needs a constructor to be usable. This section will show you how to create this, very simple, constructor.


The constructor does not need to do much, it only needs to initialise the reference object. Because of this the code that will need to be generated is simple:




```
proc newMyAppConfig(): MyAppConfig =
  new result   ❶
```




|  |  |
| --- | --- |
| [❶](#CO18-1) | The `new` call is used to initialise the reference object in memory. |




This code could be generated in a similar manner as the type definition in the previous section, but thankfully there is an easier way. Instead of manually creating the AST for the procedure and its body, a template can be used. The following code listing shows the required template:




```
template constructor(ident: untyped): untyped =
  proc `new ident`(): `ident` =
    new result
```


Add this template just above your `config` macro in the `configurator.nim` file.


This template creates a new procedure, naming it `newIdent` where `Ident` is the `ident` argument passed to the template. The `ident` argument is also used for the return type of the created procedure. If you were to call this template via `constructor(MyAppConfig)`, you would essentially define the following procedure:




```
proc newMyAppConfig(): MyAppConfig =
  new result
```


But how can this template be utilised in the `config` macro? The answer lies in the `getAst` procedure defined in the `macros` module. This procedure converts the code returned by a template or a macro into one or more AST nodes.


Now thanks to `getAst` and the power of templates, you can add `result.add getAst(constructor(typeName.ident))` right after the `createRefType` call. Your `config` macro should now look like this:




```
macro config*(typeName: untyped, fields: untyped): untyped =
  result = newStmtList()

  let identDefs = toIdentDefs(fields)
  result.add createRefType(typeName.ident, identDefs)
  result.add getAst(constructor(typeName.ident))

  echo treeRepr(typeName)
  echo treeRepr(fields)

  echo treeRepr(result)
  echo repr(result)
```


You should now be able to compile the code again and see that the constructor procedure is now generated.





9.4.4  The `load` procedure
---------------------------



Last but not least is the `load` procedure. It will load the configuration file for us, parse it, and finally populate an instance of the configuration type with its contents.


Let’s look at what the implementation of this `load` procedure should look like. For the `config` definition shown in the previous sections, which contains an `address` string field and a `port` integer field, the `load` procedure should be defined as follows:




```
proc load*(cfg: MyAppConfig, filename: string) =
  var obj = parseFile(filename)         ❶
  cfg.address = obj["address"].getStr   ❷
  cfg.port = obj["port"].getNum.int     ❸
```




|  |  |
| --- | --- |
| [❶](#CO19-1) | Load the JSON file from `filename` and save it into the `obj` variable. |
| [❷](#CO19-2) | Get the `address` field from the parsed JSON object, retrieve its string value and assign it to the configuration instance’s `address` field. |
| [❸](#CO19-3) | Get the `port` field from the parsed JSON object, retrieve its integer value and assign it to the configuration instance’s `port` field. The type conversion is needed because the `getNum` procedure returns a `BiggestInt` type. |




For simplicity, the underlying configuration format used in this example is JSON. The `load` procedure starts by parsing the JSON file, it then accesses the `address` and `port` fields in the parsed JSON object and assigns them to the configuration instance.


Note the varying use of `getStr` and `getNum`. These procedures are used to retrieve the underlying `string` and `BiggestInt` values respectively from a JsonNode variant object.


The `address` field is a string, so the `load` procedure uses `getStr` to get a string for that field. Similar with the `port` field, although in this case the field is an integer so the `getNum` procedure is used. This will need to be determined by the macro when the procedure is generated.


In order to generate these statements you are going to need information about the config fields, including their name and type. Thankfully the code already deals with this information in the form of `IdentDefs`. We can reuse the `IdentDefs` that have been generated previously to generate the `load` procedure. Let’s take a look at what these `IdentDefs` look like again for the `MyAppConfig` definition:




```
IdentDefs
  Ident !"address"
  Ident !"string"
  Empty
IdentDefs
  Ident !"port"
  Ident !"int"
  Empty
```


The structure is pretty simple. There are two nodes and they each contain the field name and type. Let’s now use these to generate the `load` procedure, I will show you how to write it in steps.


First, define a new `createLoadProc` procedure:




```
proc createLoadProc(typeName: NimIdent, identDefs: seq[NimNode]): NimNode =
```


Add this definition just above the `config` macro in your `configurator.nim` file.


Just like the `createRefType` procedure defined previously, this one takes two parameters. A type name and a list of `IdentDefs` nodes. This procedure will use a semi-automatic approach to generating the necessary AST. The `load` procedure takes two parameters, a `cfg` and a `filename`, you need to create an `Ident` node for each of them. In addition to that, you should create an `Ident` node for the `obj` variable used in the procedure:




```
var cfgIdent = newIdentNode("cfg")   ❶
var filenameIdent = newIdentNode("filename")   ❷
var objIdent = newIdentNode("obj")   ❸
```




|  |  |
| --- | --- |
| [❶](#CO20-1) | The `cfg` parameter that will store an instance of the configuration object. |
| [❷](#CO20-2) | The `filename` parameter that will store the file name of the configuration file. |
| [❸](#CO20-3) | The `obj` variable that will store the parsed JSON object. |




Add this code to the body of the `createLoadProc` procedure.


The code is pretty straightforward, it creates three different identifier nodes that store the names of the two parameters and one of the variables. Let’s utilise these to generate the first line in the `load` procedure.




```
var body = newStmtList()   ❶
body.add quote do:         ❷
  var `objIdent` = parseFile(`filenameIdent`)   ❸
```




|  |  |
| --- | --- |
| [❶](#CO21-1) | Defines a variable that stores the body of the `load` procedure. |
| [❷](#CO21-2) | The `quote` procedure returns an expression’s AST, it allows for nodes to be quoted inside the expression. |
| [❸](#CO21-3) | The expression whose AST is generated is the first line of the `load` procedure, essentially `var obj = parseFile(filename)`. |




Append this code to the end of `createLoadProc`'s body.


This code starts off by creating a new `StmtList` node to hold the statements in the `load` procedure’s body. The first statement is then generated using the `quote` procedure defined in the `macros` module. The `quote` procedure returns a `NimNode` in a similar manner as the `getAst` procedure, but instead of needing to declare a separate template it allows you to pass statements to it. Code inside the body of `quote` can be substituted by quoting it using two backticks ```.


In the code above, the name that the `objIdent` node holds is substituted into the var definition. A similar substitution happens for the `filenameIdent` node. This results in `var obj = parseFile(filename)` being generated.


The next step is to iterate through the `IdentDefs` and generate the correct field assignments based on them.




```
for identDef in identDefs:                ❶
  let fieldNameIdent = identDef[0]        ❷
  let fieldName = $fieldNameIdent.ident   ❸
  case $identDef[1].ident                 ❹
  of "string":
    body.add quote do:
      `cfgIdent`.`fieldNameIdent` = `objIdent`[`fieldName`].getStr         ❺
  of "int":
    body.add quote do:
      `cfgIdent`.`fieldNameIdent` = `objIdent`[`fieldName`].getNum().int   ❻
  else:
    doAssert(false, "Not Implemented")
```




|  |  |
| --- | --- |
| [❶](#CO22-1) | Iterate through the `IdentDefs` nodes. |
| [❷](#CO22-2) | Retrieve the field name from the `IdentDefs` node. |
| [❸](#CO22-3) | Convert the `Ident` into a `string`. |
| [❹](#CO22-4) | Generate different code depending on the field’s type. |
| [❺](#CO22-5) | For a `string` field, generate the `getStr` call. |
| [❻](#CO22-6) | For an `int` field, generate the `getNum` call and a type conversion. |




Append this code to the end of `createLoadProc`'s body.


This is a rather large chunk of code. But it generates very simple statements which depend on the fields specified in the `config` body. For the `config` definition shown in the previous sections, it will generate the following two statements:



* `cfg.address = obj["address"].getStr`
* `cfg.port = obj["port"].getNum.int`



With that code, the procedure body is now fully generated. All that is left now is to create the AST for the procedure, this can be done easily using the `newProc` procedure defined in the `macros` module.




```
return newProc(newIdentNode("load"),   ❶
    [newEmptyNode(),   ❷
     newIdentDefs(cfgIdent, newIdentNode(typeName)),         ❸
     newIdentDefs(filenameIdent, newIdentNode("string"))],   ❹
    body)              ❺
```




|  |  |
| --- | --- |
| [❶](#CO23-1) | The name of the procedure. |
| [❷](#CO23-2) | The return type of the procedure, an empty node is used to signify a `void` return type. |
| [❸](#CO23-3) | The first procedure parameter, in this case `cfg`. |
| [❹](#CO23-4) | The second procedure parameter, in this case `filename`. |
| [❺](#CO23-5) | A `StmtList` node containing statements to be included in the body of the procedure. |




The `newProc` procedure generates the necessary AST nodes which model a procedure. You get to customise the procedure by specifying the name, the parameters, the return type and the procedure body.


All that’s left to do now is to add a call to generate the `load` proc in the `config` macro. Just add `result.add createLoadProc(typeName.ident, identDefs)` below the `getAst` call. That’s all there is to it! Let’s make sure that it all works now.





9.4.5  Testing the configurator
-------------------------------



Before testing the code, you should create a JSON file that can be read. Create a new file called `myappconfig.json` beside your `configurator.nim` file and add the following code to it:




```
{
  "address": "http://google.com",
  "port": 80
}
```


This will be read by the configurator in your test. *Listing 9.10* shows how to test it.




Listing 9.10. Testing the `config` macro




```
import json

config MyAppConfig:
  address: string
  port: int

var myConf = newMyAppConfig()
myConf.load("myappconfig.json")
echo("Address: ", myConf.address)
echo("Port: ", myConf.port)
```



Add the code in *Listing 9.10* to the bottom of the `configurator.nim` file. Then compile and run the file. You should see the following output:




```
Address: http://google.com
Port: 80
```


That’s all there is to it. The DSL is finished! Based on this example, you should now have a good idea of how DSLs can be written in Nim and how macros work. Feel free to play around with the resulting DSL, you might wish to add support for more field types or export the generated types and procedures to make them usable from other modules.






9.5  Summary
============




* Metaprogramming consists of three separate constructs: generics, templates and macros.
* Generic procedures reduce code duplication.
* Concepts are an experimental feature related to generics that allows you to specify requirements that a matched type must satisfy.
* You have learned how to define generic procedures to reduce code duplication.
* Templates are an advanced substitution mechanism that is expanded during compile-time.
* Templates support hygiene, which is a way to control access to variables defined in them.
* Templates and macros are the only constructs that can take a code block as an argument.
* Macros work by reading, generating and modifying code in the form of an *Abstract Syntax Tree*.
* You have learned how to get an AST representation of any piece of Nim code.
* You now know how to generate code by constructing an AST using macros.





