

8
=


Interfacing with other languages
================================


This chapter covers:



* Nim’s foreign function interface
* The difference between static and dynamic linking
* Creating a wrapper for an external C library
* Using the JavaScript backend
* Wrapping JavaScript APIs



For many years now, computer programmers have been writing software libraries in various programming languages. A lot of these libraries have been in development for a very long time, gaining many features and becoming stable over the years. Of course such libraries are not typically written in Nim, instead they have been written in older programming languages such as C and C++.


When writing software, you might have run into cases where an external C library was required to perform a task. A good example of this is the OpenSSL library which implements the SSL and TLS protocols. It is primarily used for transferring sensitive data over the internet securely, for example when navigating to a website using the HTTPS protocol.


Many of the HTTP client modules that are present in the standard libraries of various programming languages, including Nim’s, use this library to transfer encrypted data to and from HTTP servers securely. It’s easy to forget that this library is used, because it is usually invoked behind the scenes which reduces the amount of work the programmer needs to do.


The standard library takes care of a lot of things for you. That includes interfacing with other languages, as is the case with the OpenSSL library. Of course, there are times when you will need to interface with a library yourself.


This chapter will prepare you for those times. First of all, you will learn how to call procedures implemented in the C programming language. In addition to that you will be shown how to pass data to those procedures as well as how to receive data back from them. After that you will see how to wrap an external library called SDL and you will use your wrapper to create a simple SDL application that draws on the screen. Lastly, you will work with the JavaScript back end; wrapping the Canvas API and drawing shapes on the screen using it.


Nim makes the job of calling procedures implemented in the C programming language particularly easy. This is because Nim primarily compiles to C. Nim’s other compilation back ends including C++, Objective C and JavaScript makes using libraries written in those languages easy as well.




8.1  Nim’s Foreign Function Interface
=====================================



An FFI, or *Foreign Function Interface*, is the mechanism by which Nim can call procedures written in another programming language. Most languages offer it, but they don’t all use the same terminology. For example, Java refers to its FFI as the Java Native Interface, whereas Common Language Runtime languages such as C# refer to it as P/Invoke.


In many cases, the FFI is used to employ services defined and implemented in a lower level language. This lower level language is typically C or C++, because many important *operating system* services are defined using those languages. Nim’s standard library makes extensive use of the FFI to take advantage of OS services; this is done to perform tasks such as the reading of files or network communication.


In recent years, the web has become a platform of its own. Web browsers which retrieve and present web pages implement the JavaScript programming language, allowing complex and dynamic web applications to be run inside the browser easily. In order to run in a web browser and make use of the services provided by it, like the Document Object Model or WebGL, Nim source code can be compiled to JavaScript. Accessing those services and the plethora of JavaScript libraries is also done via the FFI. *Figure 8.1* shows an overview of Nim’s FFI.




Figure 8.1. Using the Nim Foreign Function Interface (FFI), you can take advantage of services in other languages. Nim offers two versions of the FFI: one for C, C++, and Objective C, and a second one for JavaScript. Both cannot be used in the same application.


![ch08 ffi](../Images/ch08_ffi.png)

It’s important to note that the FFI allows you to interface with C, C++ and Objective C libraries in the same application, but you cannot interface with both C and JavaScript libraries at the same time. This is because C++ and Objective C are both backward compatible with C, whereas JavaScript is a completely different language.




8.1.1  Static vs. Dynamic linking
---------------------------------



Before looking at the FFI in more detail let’s look at the two different ways that C, C++ and Objective C libraries can be linked to your Nim applications.


When using an external library, your application must have a way to locate it. The library can either be embedded in your application’s binary or it can reside somewhere on the user’s computer. The former refers to a *statically-linked library* whereas the latter refers to a *dynamically-linked library*.


Dynamic and static linking are both supported, but dynamic linking is favoured by Nim. Each approach has its advantages and disadvantages. Dynamic linking is favoured because:



* Libraries can be updated in order to fix bugs and security flaws without updating the applications that use the library.
* A development version of the linked library does not need to be installed in order to compile applications that use it.
* A single dynamic library can be shared between multiple applications.



The biggest advantage of static linking is the fact that it avoids dependency problems. The libraries are all contained in a single executable file which simplifies distribution and installation of the application. Of course this can also be seen as a disadvantage because the size of these executables can become very high.


Dynamically linked libraries are instead loaded when the application first starts. The application searches special paths for the required libraries, and if they cannot be found the application fails to start. *Figure 8.2* shows how libraries are loaded in a statically-linked and dynamically-linked application.




Figure 8.2. Static vs. dynamic linking


![ch08 dynamic vs static](../Images/ch08_dynamic_vs_static.png)

It’s important to know the distinction between a statically linked library and a dynamically linked one. It’s important to be aware of dynamically linked libraries that your application depends on, because without those libraries it will not run. With these differences in mind, let’s look at the process of creating wrappers in Nim.





8.1.2  Wrapping C procedures
----------------------------



This section shows you how to wrap a widely used and fairly simple C procedure: the `printf` procedure. In C, the `printf` procedure is declared as follows:




```
int printf(const char *format, ...);
```


What you see in the listing above is the procedure *prototype* of `printf`. A *prototype* specifies the procedure’s name and type signature, but omits its implementation. When wrapping procedures the implementation is not important, all that matters is the procedure prototype. If you are not familiar with this procedure, you will see what it does later in this section.


In order to wrap C procedures, you must have a good understanding of these procedure prototypes. Let’s look at what the procedure prototype shown in the previous code listing tells us about `printf`. Going from left to right, the first word specifies the procedure’s return type, in this case an `int`. The second specifies the procedure name which is `printf`. What follows is the list of parameters which the procedure takes, in this case a `format` parameter of type `const char *` and a variable amount of arguments signified by the ellipsis.


*Table 8.1* summarises the information defined by the `printf` prototype.




Table 8.1. Summary of the `printf` prototype











| Return type | Name | First parameter type | First parameter name | Second parameter |
| `int` | printf | `const char *` | format | *Variable number of arguments* |




This prototype has two special features:



* The `const char *` type, which represents a pointer to an immutable character.
* The variable number of arguments which this function takes.



In many cases, like this one, the `const char *` type represents a `string`. In C there is no `string` type, instead a pointer which points to the start of a list of characters is used.



* The `const char *` type, which represents a pointer to an immutable character.
* The variable number of arguments which this procedure takes.



In many cases, like this one, the `const char *` type represents a `string`. In C there is no `string` type, instead a pointer which points to the start of a list of characters is used.


When wrapping a procedure you need to look at each type and find a Nim equivalent. The `printf` prototype has two argument types: the `int` and `const char *`. Nim defines an equivalent type for both, the `cint` and `cstring` respectively. The `c` in those types does not represent the C programming language but instead stands for "compatible", the `cstring` type is therefore a "compatible string" type. This is because C is not the only language supported by Nim’s FFI, the `cstring` type is for example used as a native JavaScript string as well.


These types are defined in the implicitly imported `system` module, where you will find a lot of other similar types. For example:



* `cstring`
* `cint`, `cuint`
* `pointer`
* `clong`, `clonglong`, `culong`, `culonglong`
* `cchar`, `cschar`, `cuchar`
* `cshort`, `cushort`
* `cint`
* `csize`
* `cfloat`
* `cdouble`, `clongdouble`
* `cstringArray`



Let’s put all this together and create the wrapper procedure. *Figure 8.3* shows a wrapped `printf` procedure.




Figure 8.3. `printf` wrapped in Nim


![ch08 proc wrapper](../Images/ch08_proc_wrapper.png)

The following code listing shows how the procedure can be invoked:




```
proc printf(format: cstring): cint {.importc, varargs.}

discard printf("My name is %s and I am %d years old!\n", "Ben", 30)
```


Save the file as `ffi.nim`, then compile and run it with `nim c -r ffi.nim`. You should see the following output:




```
My name is Ben and I am 30 years old!
```


The `printf` procedure takes a string constant `format` which provides a description of the output. It specifies the relative location of the arguments to `printf` in the `format` string, as well as the type of output that this procedure should produce. The parameters that follow specify what each format specifier in the `format` string should be replaced with. The procedure then returns a count of the printed characters.


One thing you might immediately notice is the `discard` keyword. Nim requires return values which are not used to be explicitly discarded using the `discard` keyword. This is useful when working with procedures that return error codes or other important pieces of information, where ignoring their values may lead to issues. In the case of `printf`, the value can be safely discarded implicitly. The `{.discardable.}` pragma can be used for this purpose:




```
proc printf(format: cstring): cint {.importc, varargs, discardable.}

printf("My name is %s and I am %d years old!\n", "Ben", 30)
```


But what really makes this procedure work is the `importc` pragma. This pragma asks the Nim compiler to import the `printf` procedure from C. The name that is imported is taken from the procedure name, but it can be changed by specifying a different name in quotes like so:




```
proc displayFormatted(format: cstring): cint {.importc: "printf", varargs, discardable.}

displayFormatted("My name is %s and I am %d years old!\n", "Ben", 30)
```


That’s pretty much all there is to it. The `printf` procedure now wraps the `printf` procedure in the C standard library. You can even export it, and use it from other modules.





8.1.3  Type compatibility
-------------------------



You may wonder why the `cstring` and `cint` types need to be used at all. Why can’t you use `string` and `int`? Let’s try it and see what happens.


Modify your `ffi.nim` file so that the `printf` procedure returns an `int` type and takes a `string` type as the first argument. Then recompile and run the program.


The program will likely show no output. This underlines the unfortunate danger that comes with using the FFI. In this case, the procedure call does nothing, or at least it appears that way. In other cases your program may even crash. The compiler will believe whatever you tell it, because it has no way of knowing whether you are lying to it.


Because the `cstring` type was changed to the `string` type, your program now passes a Nim string object to the C `printf` procedure. C expects to receive a `const char*` type, and it always assumes that it receives it. This can lead to all sorts of issues, one of the major ones being memory corruption.


Nim’s string type isn’t as simple as C’s. But it is similar, a Nim string is an object that contains two fields: the length of the string and a pointer to an array of `char`'s. This is why a Nim string can be easily converted to a `const char*`. In fact, because this conversion is so easy it is done implicitly for you, which is why despite the fact that in the previous listing you are passing a `string` to `printf` which expects a `cstring`, the example compiles.





> Note Conversion from `cstring` to `string` |
| A conversion in the other way, from a `cstring` to a `string`, is not implicit because it has some overhead. This is why you must do it explicitly using a type conversion or the `$` operator. |



As for the `cint` type, it is actually very similar to the `int` type. You can check out the Nim documentation to see that it is actually just an alias for `int32`: <http://nim-lang.org/docs/system.html#cint>. The difference between the `int` and the `int32` type is that the former’s bitwidth depends on the current architecture, whereas the bitwidth of the latter type is always 32 bits.


The `system` module defines many more compatibility types, many of which are inspired by C. But there comes a time when you need to import types defined in C as well. The next section will show you how that can be done.





8.1.4  Wrapping C types
-----------------------



The vast majority of interfacing with C libraries involves the wrapping of procedures. Second to that is the wrapping of types, which this section is going to demonstrate.


In the previous section I showed you how to wrap the `printf` procedure. In this section you will see how to wrap the `time` and `localtime` procedures, which allow you to retrieve the current system time in seconds, and convert that time into calendar time respectively.


Let’s start by wrapping the `time` procedure. We can look up its prototype online, for example <http://en.cppreference.com/w/c/chrono/time> specifies that its prototype looks like this:




```
time_t time( time_t *arg );
```


Further research into the type of `time_t` indicates that it is a *signed integer*. [[25]](#ftn.d5e9529) That’s all we need to know to declare this procedure in Nim. *Listing 8.1* shows this declaration.




Listing 8.1. Wrapping `time`




```
type
  CTime = int64   ❶

proc time(arg: ptr CTime): CTime {.importc, header: "<time.h>".}   ❷
```




|  |  |
| --- | --- |
| [❶](#CO1-1) | The `CTime` type is the wrapped version of `time_t`, defined as a simple alias for a 64 bit signed integer. |
| [❷](#CO1-2) | The `time` C procedure is defined in the `<time.h>` header file, in order to import it the `header` pragma is necessary. |





In this case we wrap the `time_t` type ourselves. The procedure declaration has two interesting new characteristics. First of all, it uses the `ptr` keyword to emulate the `time_t *` type, that is a pointer to a `time_t` type. The declaration also uses a pragma which has not been shown yet: the `header` pragma. This pragma specifies the header file that contains the imported procedure.


The `time` procedure returns the number of seconds since the Unix epoch (Thursday, 1 January 1970).


To convert the result of `time` into the current hour and minute, we are going to need to wrap the `localtime` procedure and call it. Again, the specification of the prototype is available online, <http://en.cppreference.com/w/c/chrono/localtime> specifies that the prototype looks like this:




```
struct tm *localtime( const time_t *time );
```


The `localtime` procedure takes a pointer to a `time_t` value and returns a pointer to a `struct tm` value. A `struct` in Nim is equivalent to an `object`. Unfortunately there is no way to tell whether the `struct` that the `localtime` returns has been allocated on the stack or on the heap, by the return type alone.


Whenever a C procedure is returning a pointer to a data structure, it is important to investigate whether that pointer needs to be manually deallocated by your code. The documentation for this procedure states that the return value is a "pointer to a static internal tm object". This means that the object has a *static* storage duration and so does not need to be deallocated manually. Every good library will state the storage duration of an object in its documentation.


When wrapping code you will undoubtedly run into a procedure that returns an object with a *dynamic* storage duration. In that case, the procedure will allocate a new object every time it is called and it is your job to deallocate it whenever you no longer need it.


The `struct tm` type is much more complex than the `time_t` type. The documentation available at <http://en.cppreference.com/w/c/chrono/tm> shows that it contains 9 integer fields. The definition of this type in C would look something like this:




```
struct tm {
   int tm_sec;
   int tm_min;
   int tm_hour;
   int tm_mday;
   int tm_mon;
   int tm_year;
   int tm_wday;
   int tm_yday;
   int tm_isdst;
};
```


Wrapping this type is fairly simple, although a bit mundane. A good trick to know is that you don’t have to wrap the full type, unless you need to access all of the fields. For now let’s just wrap the `tm_min` and `tm_hour` fields. *Listing 8.2* shows how to wrap the `tm` type together with the two fields.




Listing 8.2. Wrapping `struct tm`




```
type
  TM {.importc: "struct tm", header: "<time.h>".} = object   ❶
    tm_min: cint    ❷
    tm_hour: cint   ❷
```




|  |  |
| --- | --- |
| [❶](#CO2-1) | Note that the `struct` keyword cannot be omitted in the argument to the pragma. |
| [❷](#CO2-2) | The two fields are defined as they would be for any Nim data type. Of significance is the use of `cint`. |





You can then wrap the `localtime` procedure and use it together with the `time` procedure as shown in *Listing 8.3*.




Listing 8.3. A complete `time` and `localtime` wrapper




```
type
  CTime = int64

proc time(arg: ptr CTime): CTime {.importc, header: "<time.h>".}

type
  TM {.importc: "struct tm", header: "<time.h>".} = object
    tm_min: cint
    tm_hour: cint

proc localtime(time: ptr CTime): ptr TM {.importc, header: "<time.h>".}   ❶

var seconds = time(nil)            ❷
let tm = localtime(addr seconds)   ❸
echo(tm.tm_hour, ":", tm.tm_min)   ❹
```




|  |  |
| --- | --- |
| [❶](#CO3-1) | The `localtime` procedure takes a `time_t *` and returns a `struct tm *`, which are both pointers. That is why the `ptr` keyword is used. |
| [❷](#CO3-2) | Assign the result of the `time` call to a new `seconds` variable. |
| [❸](#CO3-3) | Pass the address of the `seconds` variable to the `localtime` procedure. |
| [❹](#CO3-4) | Display the current time. |





Save this as `ffi2.nim`, then compile and run it. You should see the current time displayed on your screen after execution, for example `18:57`.


The main take away from the example in *Listing 8.3* is that wrapping a type involves essentially copying its structure into a Nim type definition. It is important to remember that the field names have to match that of the C type. You can specify the name of each field in a `importc` pragma if you wish to rename them. *Figure 8.4* demonstrates this.




Figure 8.4. The mapping between fields in a wrapped type and a C struct


![ch08 field mapping](../Images/ch08_field_mapping.png)

Another interesting aspect of this is the need to pass a pointer to the `localtime` procedure. We need to account for this in our wrapper. The `addr` keyword returns a pointer to the value specified, that value must be mutable which is why the return value of `time` is assigned to a new `seconds` variable in *Listing 8.3*. Writing `localtime(addr time(nil))` wouldn’t work because the return value isn’t stored anywhere permanent yet.


With all this in mind, you should now have a pretty good idea of how C types can be wrapped in Nim. It’s now time to wrap something a little more ambitious: an external library.





  


[[25]](#d5e9529) The `time_t` type, <http://stackoverflow.com/a/471287/492186>







8.2  Wrapping an external C library
===================================



So far I have shown you how to wrap some very simple procedures which are part of the C standard library. Most of these procedures have already been wrapped to some extent by the Nim standard library and are exposed via modules such as the `times` module.


Wrapping an external library is slightly different. This section will teach you these differences by showing you how to wrap a small bit of the SDL library.


Simple DirectMedia Layer, or SDL, is a cross-platform multimedia library. It is one of the widely used libraries for writing computer games and other multimedia applications. SDL manages video, audio, input devices, and much more. Some practical things that you can use it for is drawing 2D graphics on the screen or playing sound effects.


The former of which is exactly what I will show you how to do. By the end of this section you will produce an application which displays the window shown in *Figure 8.5*.





> Note SDL wrapper |
| The wrapper shown here will be very basic, for a full SDL wrapper that has already been created by the Nim community take a look here: <https://github.com/nim-lang/sdl2> |





Figure 8.5. The application you will produce in this section


![ch08 sdl screenshot 2](../Images/ch08_sdl_screenshot_2.png)



8.2.1  Downloading the library
------------------------------



Before you begin writing the wrapper for the SDL library you should download it. For the purposes of this wrapper you will only need SDL’s runtime binaries; these can be downloaded from: <http://www.libsdl.org/download-2.0.php#source>





8.2.2  Creating a wrapper
-------------------------



A *wrapper* consists of one or more modules which contain wrapped procedures and type definitions. Wrappers typically mirror the contents of C header files, which contain multiple declarations of procedure prototypes and types. But they may also for example mirror the contents of JavaScript API reference documentation.


For large libraries like SDL these header files are very large, containing thousands of procedure prototypes and hundreds of types. The good news is that in order to use the library you don’t need to wrap it all completely. A couple procedures and types will do. This means that you can wrap libraries on demand; instead of spending days wrapping the full library including procedures which you are never going to use, just wrap the procedures that you need to use.


Just like in the previous section, you can look up the definition of the procedure prototypes that you are wrapping online. Doing so has the disadvantage that it may yield unreliable or outdated information. But more often than not it is a lot more convenient than searching through dozens of header files for the correct procedure.


But before you do that you need to figure out what needs to be wrapped. The easiest way to figure that out is to look for examples in C, showing how the library in question can be used to develop a program which performs your desired actions. For this section, the objective is to create an application which shows a window of a specified color as shown in *Figure 8.5*.


The SDL library is certainly a lot more capable, but in the interest of showing you how to wrap it, it’s better to focus on the smallest example possible.


With that in mind let’s start. The wrapper itself will be a single module called `sdl`. Before moving onto the next section, create this module by creating a new file called `sdl.nim`.





8.2.3  Dynamic linking
----------------------



Earlier on in this chapter I have explained the differences between *static linking* and *dynamic linking*. The procedures you have wrapped in the previous section are part of the C standard library and as such the linking process used was automatically chosen for you. The process by which the C standard library is linked depends on your operating system and C compiler.


When it comes to linking with external C libraries, the recommended process is to use dynamic linking. This process involves some small initial setup which I will explain here.


Whenever you instruct the Nim compiler to dynamically link with a C library, you must supply it with the filename of that library. The filenames of each library depend entirely on the library and operating system that the library has been built for. *Table 8.2* shows the filenames of the SDL library for Windows, Linux and Mac OS X.




Table 8.2. The filenames of the SDL library









| Windows | Linux | Mac OS X |
| `SDL2.dll` | `libSDL2.so` | `libSDL2.dylib` |




These files are called *shared library* files because in many cases, especially on Unix-like operating systems, they are shared between multiple applications.


The SDL wrapper needs to know these filenames. Let’s define them in the `sdl` module you just created. *Listing 8.4* shows how to define these for each operating system.




Listing 8.4. Defining the shared library filename conditionally




```
when defined(Windows):
  const libName* = "SDL2.dll"
elif defined(Linux):
  const libName* = "libSDL2.so"
elif defined(MacOsX):
  const libName* = "libSDL2.dylib"
```



Add this code to your `sdl` module.


This code is fairly simple. Only one constant `libName` is defined on each operating system, its name remains the same but its value changes between each operating system. This will allow the wrapper to work on all 3 of the major operating systems.


That’s all the setup that is required. Strictly speaking it is not absolutely necessary, but it does mean that these filenames can be easily changed at a later time.


Now recall the previous section, where I showed you the `header` and `importc` pragmas. These were used to import C procedures from a specific header in the C standard library. In order to instruct the compiler to dynamically link a procedure, a new pragma called `dynlib` needs to be used. For example:




```
proc init*(flags: uint32): cint {.importc: "SDL_Init", dynlib: libName.}
```


The `dynlib` pragma takes one argument: the filename of the shared library where the imported procedure is defined. Every time your application starts, it will attempt to load all the shared libraries defined by these pragmas. If it cannot find the shared library or the wrapped procedure does not exist in the shared library then the application will display an error and terminate.


The `dynlib` pragma also supports a simple versioning scheme. For example, if you would like to load either `libSDL2-2.0.1.so` or `libSDL2.so` then you can specify `"libSDL2(|-2.0.1).so"` as the argument to `dynlib`. More information about the `dynlib` pragma is available in the Nim manual: <http://nim-lang.org/docs/manual.html#foreign-function-interface-dynlib-pragma-for-import>


Now you’re ready to start wrapping.





8.2.4  Wrapping the types
-------------------------



Before you can successfully wrap the required procedures, you are going to have to first define four types. Thankfully wrapping their internals is not necessary, they will simply act as stubs to identify some objects. *Listing 8.5* shows how to define these types.




Listing 8.5. Wrapping the 4 necessary types




```
type
  SdlWindow = object     ❶
  SdlWindowPtr* = ptr SdlWindow       ❷
  SdlRenderer = object   ❶
  SdlRendererPtr* = ptr SdlRenderer   ❷
```




|  |  |
| --- | --- |
| [❶](#CO4-1) | Define an object stub. This object surely contains fields, but we do not need to access them in our application and so can omit their definitions. |
| [❷](#CO4-2) | Many of the procedures in the SDL library work on pointers to objects, it’s convenient to simply give this type a name and export it instead of writing `ptr TheType` everywhere. |





The type definitions are fairly simple. The `SdlWindow` type will represent a single on screen SDL window and the `SdlRenderer` will represent an object used for rendering onto the SDL window.


The pointer types are defined for convenience, they are exported because the SDL procedures which you will wrap soon return them. Let’s look at these procedures now.





8.2.5  Wrapping the procedures
------------------------------



There is only a handful of procedures that need to be wrapped in order to show a colored window on the screen using SDL. *Listing 8.6* shows the C prototypes which define those procedures.




Listing 8.6. The SDL C prototypes that are going to be wrapped in this section




```
int SDL_Init(Uint32 flags)            ❶

int SDL_CreateWindowAndRenderer(int            width,
                                int            height,
                                Uint32         window_flags,
                                SDL_Window**   window,
                                SDL_Renderer** renderer)   ❷

int SDL_PollEvent(SDL_Event* event)   ❸

int SDL_SetRenderDrawColor(SDL_Renderer* renderer,
                           Uint8         r,
                           Uint8         g,
                           Uint8         b,
                           Uint8         a)      ❹

void SDL_RenderPresent(SDL_Renderer* renderer)   ❺

int SDL_RenderClear(SDL_Renderer* renderer)      ❻
```




|  |  |
| --- | --- |
| [❶](#CO5-1) | Initialises the SDL library. |
| [❷](#CO5-2) | Creates an SDL window and rendering context associated with that window. |
| [❸](#CO5-3) | Checks for input events. |
| [❹](#CO5-4) | Sets the current draw color on the specified renderer. |
| [❺](#CO5-5) | Updates the screen with any rendering that was performed. |
| [❻](#CO5-6) | Clear the specified renderer with the drawing color. |





You have already seen how to wrap the `SDL_Init` procedure:




```
proc init*(flags: uint32): cint {.importc: "SDL_Init", dynlib: libName.}
```


The wrapper for this procedure is fairly straight forward. The `Uint32` and `int` type in the prototype maps to a `uint32` and `cint` Nim type respectively. Notice how the procedure was renamed to `init`, this was done because the `SDL_` prefixes are redundant in Nim.


Now consider the rest of the procedures. Each wrapped procedure will need to specify the same `dynlib` pragma. You can remove this repetition with another pragma called the `push` pragma. The `push` pragma allows you to apply a specified pragma to the procedures or types defined below it, until a corresponding `pop` pragma is used. *Listing 8.7* shows how the rest of the procedures can be wrapped with the help of the `push` pragma.




Listing 8.7. Wrapping the procedures in the `sdl` module




```
{.push dynlib: libName.}   ❶
proc init*(flags: uint32): cint {.importc: "SDL_Init".}

proc createWindowAndRenderer*(width, height: cint, window_flags: cuint,
    window: var SdlWindowPtr, renderer: var SdlRendererPtr): cint        ❷
    {.importc: "SDL_CreateWindowAndRenderer".}

proc pollEvent*(event: pointer): cint {.importc: "SDL_PollEvent".}       ❸

proc setDrawColor*(renderer: SdlRendererPtr, r, g, b, a: uint8): cint
    {.importc: "SDL_SetRenderDrawColor", discardable.}                   ❹

proc present*(renderer: SdlRendererPtr) {.importc: "SDL_RenderPresent".}

proc clear*(renderer: SdlRendererPtr) {.importc: "SDL_RenderClear".}

proc drawLines*(renderer: SdlRendererPtr, points: ptr tuple[x, y: cint],
    count: cint): cint {.importc: "SDL_RenderDrawLines", discardable.}   ❺
{.pop.}   ❻
```




|  |  |
| --- | --- |
| [❶](#CO6-1) | This ensures that each proc gets the `dynlib` pragma. |
| [❷](#CO6-2) | Here the `var` keyword is used in place of a `ptr`. In Nim these end up generating equivalent C code. |
| [❸](#CO6-3) | The `pointer` type in Nim is equivalent to a `void *` which is a pointer of any type. |
| [❹](#CO6-4) | The `discardable` pragma is used here to implicitly discard the return value. |
| [❺](#CO6-5) | The `points` parameter is a pointer to the beginning of a list of tuples. |
| [❻](#CO6-6) | This stops the propagation of the `dynlib` pragma. |





Most of the code is fairly standard. The `createWindowAndRenderer` procedure’s arguments include a pointer to a pointer to a `SdlWindow` and `SdlRenderer`, written as `SdlWindow**` and `SdlRenderer**` respectively. A pointer to a `SdlWindow` and `SdlRenderer` was already defined in the previous sub-section under the names `SdlWindowPtr` and `SdlRendererPtr` respectively, so you can define the types of those arguments as `ptr SdlWindowPtr` and `ptr SdlRendererPtr`. This will work well, but in this case using `var` in place of `ptr` is also appropriate.


You may recall `var T` being used in Chapter 6, where it was used to store a result in a variable that was passed as a parameter to a procedure. The exact same thing is being done by the `createWindowAndRenderer` procedure. Nim implements these `var` parameters using pointers, so defining that argument’s type using `var` is perfectly valid. The advantages to doing so is that you no longer need to use `addr` and Nim also prevents you from passing `nil` for that argument.


For the `pollEvent` procedure the argument type was defined as `pointer`. This type is equivalent to a `void*` type in C, essentially a pointer to any type. This was done because it avoids the need to wrap the `SdlEvent` type. You may run into C libraries which declare procedures accepting a `void*` type, in that case you can use the `pointer` type. In practice however, it’s better to use a `ptr T` type for improved type safety. But the only way you can do so is if you know that the procedure which you are wrapping will only ever accept a specific pointer type.


Lastly, the `drawLines` procedure is the most complicated as it accepts a list of points to draw as lines. In C, a list of elements is represented by a pointer to the first element in the list and the number of variables in that list. In the case of the `drawLines` procedure, each element in the `points` list is an `SDL_Point` type and it is defined as a simple C struct containing two integers that represent the `x` and `y` coordinates of the point. In Nim, this simple struct can be represented using a tuple.


Now add the contents of *Listing 8.7* to your `sdl` module. It’s time to use it to write the application.





8.2.6  Using the SDL wrapper
----------------------------



Start by creating an `sdl_test.nim` file beside your wrapper. Then import the wrapper by writing `import sdl` at the top of the file.


Before the library can be used you are going to have to initialise it using the `init` procedure. The `init` procedure expects to receive a `flags` argument, this argument specifies which SDL subsystems should be initialised. For the purposes of this application you only need to initialise the "video subsystem". In order to do this you will need to define a constant for the `SDL_INIT_VIDEO` flag. The following code listing shows the code that can be used for this.




```
const INIT_VIDEO* = 0x00000020
```


The value of this constant needs to be defined in the Nim source file because it is not available in the shared library. C header files typically define these using a `#define` which is not compiled into any shared libraries.


Add this constant into your `sdl` module. After doing so you are finally ready to use the `sdl` wrapper to implement a simple application. *Listing 8.8* shows the code needed to do so.




Listing 8.8. An SDL application implemented using the `sdl` wrapper




```
import os
import sdl

if sdl.init(INIT_VIDEO) == -1:      ❶
  quit("Couldn't initialise SDL")   ❷

var window: SdlWindowPtr
var renderer: SdlRendererPtr
if createWindowAndRenderer(640, 480, 0, window, renderer) == -1:   ❸
  quit("Couldn't create a window or renderer")   ❹

discard pollEvent(nil)   ❺
renderer.setDrawColor 29, 64, 153, 255           ❻
renderer.clear           ❼

renderer.present         ❽
sleep(5000)              ❾
```




|  |  |
| --- | --- |
| [❶](#CO7-1) | Initialise the SDL video subsystem. |
| [❷](#CO7-2) | Quit with an error if the initialisation fails. |
| [❸](#CO7-3) | Create a window and renderer to draw things on. |
| [❶](#CO7-4) | Quit with an error if the creation of the window or renderer fails. |
| [❷](#CO7-5) | This is where you would handle any pending input events. For this application it is only called so that the window initialises properly. |
| [❸](#CO7-6) | Set the drawing color to the specified red, green, blue and alpha value. |
| [❼](#CO7-7) | Clear the screen with the specified drawing color. |
| [❽](#CO7-8) | Show the pixels drawn on the renderer. |
| [❾](#CO7-9) | Wait for 5 seconds before terminating the application. |





Compile and run the `sdl_test.nim` file. You should see a window with a blue background as shown in *Figure 8.6*.




Figure 8.6. What the result of running *Figure 8.6* should look like


![ch08 sdl screenshot](../Images/ch08_sdl_screenshot.png)

A blank SDL window is a great achievement, but it isn’t a very exciting one. Let’s use the `drawLines` procedure to draw the letter N in the middle of the screen. The following code shows how this can be done:




```
renderer.setDrawColor 255, 255, 255, 255              ❶
var points = [   ❷
  (260'i32, 320'i32),
  (260'i32, 110'i32),
  (360'i32, 320'i32),
  (360'i32, 110'i32)
]
renderer.drawLines(addr points[0], points.len.cint)   ❸
```




|  |  |
| --- | --- |
| [❶](#CO8-1) | Change the draw color to white. |
| [❷](#CO8-2) | Define an array of points that define the coordinates to draw an N. Each coordinate must be an `int32` as that is what a `cint` is. |
| [❸](#CO8-3) | Draw the lines defined by the `points` array. |




Add this code just below the `renderer.clear` statement in the `sdl_test.nim` file. Then compile and run the `sdl_test.nim` file. You should see a window with a blue background and the letter N as shown in *Figure 8.7*.




Figure 8.7. The final `sdl_test` application with the letter N drawn


![ch08 sdl screenshot 2](../Images/ch08_sdl_screenshot_2.png)

In the code above, the `drawLines` call is the important one. The address of the first element in the `points` array is passed to this procedure together with the length of the `points` array. The `drawLines` procedure then has all the information it needs to read all points in the array. It is important to note that this call is not memory safe, if the points count is too high then the `drawLines` procedure will attempt to read memory that is adjacent to the array. This is known as a *buffer over-read*, footnote:Buffer over-read, <https://en.wikipedia.org/wiki/Buffer_over-read>] and can result in serious issues because there is no way of knowing what the adjacent memory contains.


That’s how you wrap an external library using Nim! Of course there is plenty of room for improvement. Ideally a module which provides a higher-level API should always be written on top of a wrapper; that way a much more intuitive interface can be used for writing applications. Currently the biggest improvement that could be made to the `sdl` module is the addition of exceptions. Both the `init` and `createWindowAndRenderer` should raise an exception when an error occurs instead of requiring the user to check the return value manually.


The last two sections have given you an overview of the C FFI. Nim also supports interfacing with other C-like languages, including C++ and Objective C. Unfortunately those two backends are beyond the scope of this book, but the concepts you have learned so far should give you a good starting point. For further information about these take a look at the Nim manual: <http://nim-lang.org/docs/manual.html#implementation-specific-pragmas-importcpp-pragma>


The next section will show you how to write JavaScript wrappers.






8.3  The JavaScript backend
===========================



Today JavaScript is increasingly becoming known as the "assembly language of the web", because of the many new languages that target it due to its widespread use in web browsers. Languages that can be translated to JavaScript are very desirable for many reasons. One of the biggest advantages that a language which can be translated to JavaScript but also used for writing desktop applications is the ability to share the same code between a client script and a server application. The former of which will be running in the user’s web browser and the latter of which will be running on a server somewhere.


As an example, consider a chat application: the server manages connections and messages from multiple clients. A client script allows users to connect to the server and send messages to it from their web browser. These messages must be understood by all the clients and the server, as such it is beneficial for the code which parses those messages to be shared between both the server and the client. If both the client and the server are written in Nim then sharing this code is trivial. *Figure 8.8* shows how such a chat application could take advantage of Nim’s JavaScript backend.




Figure 8.8. How the same code is shared between two platforms


![ch08 javascript advantage](../Images/ch08_javascript_advantage.png)

Of course, when writing JavaScript applications there comes a time when you need to interface with the APIs exposed by the web browser as well as libraries which abstract those APIs. The process of wrapping JavaScript procedures and types is similar to what was described in the previous sections for the C backend, but there are some differences which are worth an explanation.


This section will show you how to wrap the JavaScript procedures needed in order to achieve the same effect as in the previous section with the SDL library: filling the drawable surface with a blue color and drawing a list of lines to form the letter N.




8.3.1  Wrapping the Canvas element
----------------------------------



The canvas element is part of HTML5 and allows rendering of 2D shapes and bitmap images on an HTML web page. All major web browsers support it and expose it via a JavaScript API.


To give an example of its usage, assuming that the HTML page contains a `<canvas>` element with an ID of `canvas` and its size is 600x600, the code in *Listing 8.9* will fill the canvas with the color blue.




Listing 8.9. Using the Canvas API in JavaScript




```
var canvas = document.getElementById("canvas");
canvas.width = 600;
canvas.height = 600;
var ctx = canvas.getContext("2d");

ctx.fillStyle = "#1d4099";
ctx.fillRect(0, 0, 600, 600);
ctx.strokeStyle = "#ffffff";
ctx.moveTo(250, 320);
ctx.lineTo(250, 110);
ctx.lineTo(350, 110);
ctx.lineTo(350, 320);
ctx.stroke();
```



The code is fairly self explanatory. The code starts by retrieving the canvas element from the *Document Object Model* by ID. The canvas size is set and a 2D drawing context is created. Lastly the screen is filled with a blue color, the letter N is traced using the `moveTo` and `lineTo` procedures and finally the letter is drawn using the `stroke` procedure. Wrapping the procedures that have been used in this example shouldn’t take too much effort so let’s begin!


Create a new file called `canvas.nim`. This file will contain the procedure wrappers needed to use the Canvas API. The `getElementById` procedure is already wrapped by Nim, it is a part of the Document Object Model and so it is available via the `dom` module.


Unlike C, in JavaScript there is no such thing as a header file. Again the easiest way to find out how a JavaScript procedure is defined is to look at the documentation. The following list contains the documentation for the types and procedures which will be wrapped in this section:



* `CanvasRenderingContext2D` type - <https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D>
* `canvas.getContext(contextType, contextAttributes);` procedure - <https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext>
* `void ctx.fillRect(x, y, width, height);` procedure - <https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillRect>
* `void ctx.moveTo(x, y);` procedure - <https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/moveTo>
* `void ctx.lineTo(x, y);` procedure - <https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineTo>
* `void ctx.stroke();` procedure - <https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/stroke>



Because JavaScript is a dynamically typed programming language, procedure definitions don’t contain information about each argument’s type. You must look at the documentation which more often than not tells you enough information to figure out the underlying type. *Listing 8.10* shows how the `CanvasRenderingContext2D` type and the five procedures should be wrapped.




Listing 8.10. Wrapping the Canvas API




```
import dom           ❶

type
  CanvasRenderingContext* = ref object   ❷
    fillStyle* {.importc.}: cstring      ❸
    strokeStyle* {.importc.}: cstring    ❸

{.push importcpp.}   ❹

proc getContext*(canvasElement: Element,
    contextType: cstring): CanvasRenderingContext   ❺

proc fillRect*(context: CanvasRenderingContext, x, y, width, height: int)

proc moveTo*(context: CanvasRenderingContext, x, y: int)

proc lineTo*(context: CanvasRenderingContext, x, y: int)

proc stroke*(context: CanvasRenderingContext)
```




|  |  |
| --- | --- |
| [❶](#CO9-1) | The `dom` module exports the `Element` type used in the `getContext` proc. |
| [❷](#CO9-2) | All JavaScript objects have `ref` semantics, hence the `ref object` definition. |
| [❸](#CO9-3) | Each field must be explicitly imported using `importc`. |
| [❹](#CO9-5) | Each procedure is given the `importcpp` pragma. |
| [❺](#CO9-6) | The `contextAttributes` argument is intentionally omitted here, it is an optional argument with a default value. |





This code is fairly short and to the point. You should be familiar with everything except the `importcpp` pragma. The name of this pragma is borrowed from the C++ backend. It instructs the compiler to generate JavaScript code which calls the specified procedure as if it was a member of the first argument’s object. *Figure 8.9* demonstrates the difference between `importc` and `importcpp` for the JavaScript backend.




Figure 8.9. The differences in JavaScript code produced with the `importc` and `importcpp` pragmas.


![ch08 importc importcpp](../Images/ch08_importc_importcpp.png)

There aren’t many other surprises. One interesting aspect to take note of is when wrapping data types in JavaScript, the wrapped type should be declared as a `ref object`. This is because JavaScript objects have reference semantics and so should be wrapped as such.


That’s all there is to it! Time to put this wrapper to use.





8.3.2  Using the Canvas wrapper
-------------------------------



Now that the wrapper is complete, you can write a little a script that will make use of it together with a small HTML page to execute it.


Save *Listing 8.11* as `index.html` beside your `canvas.nim` file.




Listing 8.11. The `index.html` file




```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Nim in Action - Chapter 8</title>
    <script type="text/javascript" src="test.js"></script>
    <style type="text/css">
      canvas { border: 1px solid black; }
    </style>
  </head>
  <body onload="onLoad();" style="margin: 0; overflow: hidden;">
    <canvas id="canvas"></canvas>
  </body>
</html>
```



The HTML is pretty bare bones, its got some small style adjustments to make the canvas fullscreen. It also defines an `onLoad` procedure to be called when the `<body>` tag’s `onLoad` event fires.


Save *Listing 8.12* as `canvas_test.nim` beside your `canvas.nim` file.




Listing 8.12. The `canvas_test.nim` file




```
import canvas, dom

proc onLoad() {.exportc.} =
  var canvas = document.getElementById("canvas").EmbedElement
  canvas.width = window.innerWidth
  canvas.height = window.innerHeight
  var ctx = canvas.getContext("2d")

  ctx.fillStyle = "#1d4099"
  ctx.fillRect(0, 0, window.innerWidth, window.innerHeight)
```



Note how similar the code is to JavaScript. The code listing defines a `onLoad` procedure which is then exported, this allows the browser to use it as an event callback. The `exportc` procedure is used to do this. It simply ensures that the generated JavaScript code contains an `onLoad` procedure. This pragma also works for the other backends.


You may wonder what the purpose of the `.EmbedElement` type conversion is. The `getElementById` procedure returns an object of type `Element`, unfortunately this object does not have the `width` or `height` properties and so it must be converted to a more concrete type. In this case the `EmbedElement` type which allows the two `width` and `height` assignments.


Now compile this `canvas_test` module by running `nim js -o:canvas_test canvas_test.nim`. You can then test it out by opening the `index.html` file in your favourite browser. You should see something resembling *Figure 8.10*.




Figure 8.10. The execution of the `canvas_test.nim` script in a web browser


![ch08 js result](../Images/ch08_js_result.png)

For now this is just a blue screen. Let’s extend it to draw the letter N. Add the following code at the bottom of the `onLoad` procedure.




```
ctx.strokeStyle = "#ffffff"      ❶
let letterWidth = 100            ❷
let letterLeftPos = (window.innerWidth div 2) - (letterWidth div 2)   ❸
ctx.moveTo(letterLeftPos, 320)   ❹
ctx.lineTo(letterLeftPos, 110)
ctx.lineTo(letterLeftPos + letterWidth, 320)
ctx.lineTo(letterLeftPos + letterWidth, 110)
ctx.stroke()   ❺
```




|  |  |
| --- | --- |
| [❶](#CO10-1) | Set the stroke color to white. |
| [❷](#CO10-2) | Create a local `letterWidth` variable to store the desired letter width. |
| [❸](#CO10-3) | Calculate the top-left position where the letter should be placed. |
| [❹](#CO10-4) | Begin tracing the lines of the letter. |
| [❺](#CO10-5) | Draw the letter. |




In this case the code calculates where to place the letter so that it is in the middle of the screen. This is because the canvas size depends on the size of the web browser window, in the SDL example this wasn’t necessary because the SDL window was always the same size.


Recompile the `canvas_test` file by running the same command again, then refresh your browser. You should see something resembling *Figure 8.11*.




Figure 8.11. The execution of the `canvas_test.nim` script in a web browser


![ch08 js result 2](../Images/ch08_js_result_2.png)

That’s all there is to it. You should now have a good basic understanding of how to wrap JavaScript and how to make use of Nim’s JavaScript backend.






8.4  Summary
============




* The Nim foreign procedure interface supports interfacing with C, C++, Objective C and JavaScript.
* C libraries can be either statically linked or dynamically linked with Nim applications.
* C header files declare procedure prototypes and types which provide all the information necessary to wrap them.
* The `importc` pragma is used to wrap a foreign procedure, including C and JavaScript procedures.
* The `discardable` pragma can be used to override the need to explicitly discard values.
* The `cstring` type should be used to wrap procedures which accept a string argument.
* Using an external C library is best done via dynamic linking.
* The `dynlib` pragma is used to import a procedure from a shared library.
* The `importcpp` pragma is used to wrap C++ procedures but also member procedures in JavaScript.





