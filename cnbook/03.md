第三章 编写聊天应用程序
===================

本章涵盖：

* 要求用户输入
* 创建命令行界面
* 解析和生成 JSON
* 通过网络传输数据
* 使用和创建模块

在上一章中，您学习了如何设置 Nim 编译器及其环境，从而允许您编译您的第一个 Nim 应用程序。您还学习了 Nim 编程语言的基础知识，包括语法、一些内置类型、有关如何定义变量和过程的信息、控制流语句、异常处理、如何定义自定义类型等。

在本章中，您将通过开发功能齐全的聊天应用程序来构建和巩固这些知识。您还将学习许多对某些应用程序的开发至关重要的新概念。特别是，您将：

* 构建命令行界面，该界面将充当请求用户输入的一种方式。
* 了解如何使用套接字通过互联网等网络传输数据。
* 使用 JSON 解析器构建简单的聊天协议。这将用于允许您的聊天应用程序以标准和一致的方式交换消息。
* 了解如何使用模块将代码分离为独立的单元，这将使代码更易于重用。

随着互联网的普及，计算机网络变得越来越重要。互联网最基本的功能是数据传输，这一功能在编程语言级别可能不是很容易。聊天应用程序是介绍在多台计算机之间传输数据的基础知识的好方法，这就是为什么我将在本章中将其用作示例的原因。

在本章结束时，您将成功编写一个由两个不同组件组成的应用程序：服务器和客户端。您将能够将客户端组件发送给您的朋友，然后使用它通过互联网实时聊天。

让我们开始吧。下一节将向您介绍应用程序如何工作的详细信息。

3.1 聊天应用程序的体系结构
----------------------

聊天应用程序的主要目的是允许多人使用他们的个人计算机进行通信。完成此任务的一种方法是使用这些计算机连接到的网络（如 Internet）并通过该网络发送数据。与主要用于一对一通信的Facebook Messenger或WhatsApp等应用程序不同，本章开发的聊天应用程序将主要支持类似于Internet Relay Chat或Slack的群组通信（多对多）。这意味着一条消息将发送给多个用户。

完成的应用程序会是什么样子？

假设我刚刚看了最新的《权力的游戏》剧集，现在很高兴能和我的朋友谈论它。我会称他们为约翰和格蕾丝，以防他们不喜欢我在本书中使用他们的真实姓名。谈话可能会是这样的（我保证没有权力的游戏剧透）：

清单 3.1.我、约翰和格蕾丝关于《权力的游戏》的对话
```
*Dominik said* What did you guys think about the latest Game of Thrones
episode?
*Grace said* I thought Tyrion was really great in it!
*John said* I agree with Grace. Tyrion deserves an Emmy for his performance.
```

在本章结束时，您将构建一个应用程序，该应用程序将允许进行此讨论。让我向您展示完成的应用程序在示例 3.1 中概述的对话上下文中的样子。

执行聊天应用程序的客户端组件并允许它连接到服务器后，我将能够开始发送消息。我先问约翰和格蕾丝，他们对最新的《权力的游戏》剧集有什么看法。我将通过在聊天应用程序中输入我的消息，然后按 Enter 键发送它来执行此操作。

图 3.1.发送消息后的屏幕

![ch03 Dominik 1](../Images/ch03_Dominik_1.png)

约翰和格蕾丝都会在他们的计算机上收到这条消息。客户端应用程序将以相同的方式向两者显示它。

图 3.2.约翰和格蕾丝的屏幕

![ch03 john grace](../Images/ch03_john_grace.png)

请注意，该消息以“多米尼克说”为前缀，让约翰和格蕾丝知道是谁发送了消息。然后，Grace 可以通过键入她的回复并按 Enter 键发送来回答我的问题。约翰和我都收到了她的回复。这样，我们可以相对轻松地在互联网上进行讨论。

这应该可以让您在本章结束时了解您的目标。当然，它可能不像包含图形用户界面的完整应用程序那样令人印象深刻，但这是一个开始。现在让我继续讨论此应用程序的一些基本方面，特别是其网络体系结构。

  **网络架构和模型**

此应用程序可以使用两种主要网络体系结构：对等网络和客户端-服务器模型。使用点对点网络时，没有服务器;相反，每个客户端都连接到多个其他客户端，然后在彼此之间交换信息。使用客户端-服务器模型，所有客户端都连接到单个服务器。消息全部发送到服务器，服务器将它们重新分发到正确的客户端。

图 3.3.客户端-服务器与点对点

![ch03 network models](../Images/ch03_network_models.png)

客户端-服务器模型是两者中较简单的一个。由于它也适用于您将要编写的应用程序类型，因此它将用作此聊天应用程序的基础。

要考虑的另一件事是传输协议，您将使用该协议在应用程序中传输消息。目前使用的两个主要协议是TCP和UDP。这两种协议都广泛用于许多不同类型的应用，但它们在两个重要方面有所不同。

TCP 协议最重要的功能是它确保消息传递到其目的地。这是通过随消息一起发送额外信息来实现的，以验证消息是否已正确传递。TCP 协议以牺牲某些性能为代价来执行此操作。

UDP 协议不这样做。使用UDP，数据被快速发送，协议不会检查数据是否到达目的地。这使得UDP的性能优于TCP，但具有使数据传输可靠性降低的效果。

聊天应用程序应该是高效的，但消息的可靠传递更为重要。仅基于这一方面：TCP获胜。

>注意 网络
关于网络主题的信息量要多得多，这超出了本书的范围。如果您感兴趣，我鼓励您进一步研究这个主题。

**客户端和服务器组件**

现在您对网络方面有所了解，让我们谈谈软件的实际工作方式。计划是创建两个单独的应用程序，第一个是服务器，第二个是客户端应用程序。在本章中，我将客户端称为客户端组件，将服务器称为服务器组件。

当服务器首次启动时，它将开始侦听来自特定端口上的客户端应用程序的连接。端口将被硬编码到服务器中，并提前选择，以免与任何其他应用程序冲突。我不希望它阻止你现在享受《使命召唤》的精彩游戏，对吧？一旦检测到该端口上的连接，服务器将接受该连接并等待来自该端口的消息。新收到的消息将发送到服务器以前接受的任何其他连接。

当客户端首次启动时，它将连接到用户在命令行上指定的服务器地址。成功连接后，客户端的用户将能够通过命令行输入消息来向服务器发送消息。客户端还将主动侦听来自服务器的消息，一旦收到消息，它就会显示给用户。

图 3.4.聊天应用程序的操作

![ch03 chat server](../Images/ch03_chat_server.png)

这些只是聊天应用程序如何运行的一些细节。图 3.8 显示了聊天应用程序在涉及 3 个客户端的简单用例中的操作。Dom、John 和 Grace 都是连接到服务器的正在运行的客户端。图 3.8 显示了 Dom 通过客户端向服务器发送“Hello”消息。服务器将接受此消息并将其传递给当前连接到它的其他客户端。

在本章结束时，我们的目标是完成一个应用程序，该应用程序将使我们能够实现图 3.8 中描述的场景。

您现在应该对聊天应用程序的工作方式有一个很好的了解，并且应该准备好开始实施它。下一节将向您展示如何操作！

3.2 启动项目
-----------

到现在为止，您应该对要构建的内容有所了解。上一节详细介绍了聊天应用程序的工作方式。本节将介绍开始项目所需的第一步。本章在很大程度上是一个练习，我鼓励你在阅读它时跟随发展。

你可能会感到惊讶，但在Nim启动一个项目是非常快速和容易的。只需打开您喜爱的文本编辑器，创建一个新文件并开始编码。但在此之前，您应该确定项目的目录布局。这是完全可选的，如果您将所有代码保存在“C:\code”中，编译器不会介意，但这样做是不好的做法。理想情况下，您应该仅为此项目创建一个新目录，例如`C:\code\ChatApp`（或`~/code/ChatApp`）。在该目录中创建一个“src”目录以存储所有源代码。将来，如果需要，您可以在项目中创建其他目录，如“tests”、“images”、“docs”等。大多数其他Nim项目也是这样布局的。这个项目很小，所以现在只使用“src”目录*下面的清单3.2*显示了典型的Nim项目目录布局。

清单 3.2.典型目录布局

MyAwesomeApp   ❶
├── bin        ❷
│   └── MyAwesomeApp
├── images     ❸
│   └── logo.png
├── src        ❹
│   └── MyAwesomeApp.nim
└── tests      ❺
    └── generictest.nim

>❶	`MyAwesomeApp`项目的根目录。
❷	此目录包含此项目的所有可执行文件。
❸	此目录包含此项目使用的所有图像。
❹	此目录包含与此项目相关的所有 Nim 源代码文件。
❺	此目录包含所有 Nim 源代码文件，其中包含对`src`中包含的文件的测试。
 

>注释 项目目录布局
良好的项目目录布局是非常有益的，特别是对于大型应用程序。最好尽早设置它。将应用程序源代码与测试分开意味着您可以轻松编写不冲突或不影响应用程序的测试代码。通常，分离也使代码导航更容易。

现在在`src`目录中创建一个文件`client.nim`。此文件将编译为可执行文件`client`，并充当聊天应用程序的客户端组件。

现在可以开始编写代码了。作为一个小测试，首先将以下内容写入新文件，然后保存`client.nim`。

```nim
echo("Chat application started")
```

为了编译您的新`client.nim`文件，请按照以下步骤操作。

1.打开新的终端窗口。
2.通过执行`cd ~/code/ChatApp`将`cd`插入项目目录，其中`~/codeChatApp`应替换为项目目录的路径。
3.通过执行`nim c src/client.nim`编译`client.nim`文件。

>提示 Aporia 
如果您使用的是Aporia，则只需按F4或在菜单栏中选择“工具>编译当前文件”即可编译当前选定的选项卡。也可以按 F5 进行编译和运行。

如果您正确完成了所有操作，您应该在终端窗口中看到以下内容。

图 3.5.成功编译`client.nim`.

![ch03 successful compilation](../Images/ch03_successful_compilation.png)

>提示输出目录
默认情况下，Nim编译器将在与编译文件相同的目录中生成可执行文件。您可以使用“-o”标志来更改此设置。例如，`nim c -o:chat src/client.nim` 将在当前目录中放置一个“chat”可执行文件

假设编译成功，编译器创建的可执行文件现在可以启动了。要开始执行，请使用以下命令`/src/client`。这将在屏幕上显示“聊天应用程序已启动”，然后退出。

您现在有了进一步发展的良好起点。我们起步很慢，到目前为止，您的应用程序并没有做太多事情。但它应该让您了解如何启动 Nim 中的所有应用程序，并确保 Nim 编译器在您的计算机上正常工作。

现在您已经开始了这个项目，让我们继续执行第一个任务：命令行界面。

3.3 检索客户端组件中的输入
----------------------

应用程序通常希望从用户那里获得某种指导，这可能是要导航到的网站的 URL 或要播放的视频的文件名。应用程序需要这种指导，因为它们（还）不能直接从我们的大脑中读取我们的意图，他们需要命令或鼠标点击形式的明确指令。指导软件的最简单方法是给它一个明确的命令。

在聊天应用程序的情况下，更具体地说是客户端组件。可以假设它所需的输入片段将包括要向其发送消息的服务器的地址以及要发送到该服务器的一条或多条消息。这些是聊天应用程序对用户的最低要求。

考虑到这些事情，需要有一种既可以要求用户输入特定输入的方法，又需要一种方法来实际获取用户使用键盘输入的数据。让我们关注用户所需的最低数据要求。我们要连接的服务器的地址有些关键。客户端在执行任何操作之前需要地址，因此我们应该在客户端启动后立即向用户询问该信息。在我们连接到服务器之前，用户将无法发送任何消息，因此要求用户发送消息之后。

**检索用户提供的命令行参数**

在命令行上，有两种方法可以从用户那里获取数据：

通过命令行参数，这些参数在应用程序启动时传递给应用程序。
通过标准输入流，可以随时读取。
通常，一条信息（如服务器地址）将通过命令行参数传递给应用程序，因为服务器地址需要在应用程序的最开始时知道。

在Nim中，可以通过`os`模块中定义的`paramStr`过程访问命令行参数。要使用`paramStr`过程，必须首先导入`os`模块。为此，在`client.nim`文件的顶部添加`import os`。然后，您可以扩展`client.nim`以读取第一个命令行参数，以便将代码更改为*清单3.3*中列出的代码。添加的代码以粗体显示。

清单 3.3.读取命令行参数

```nim
**import os**               ❶
echo("Chat application started")
**if paramCount() == 0:**   ❷
  **quit("Please specify the server address, e.g. ./client localhost")**   ❸

**let serverAddr = paramStr(1)**         ❹
**echo("Connecting to ", serverAddr)**   ❺
```

>❶	这是使用`os`模块中定义的`paramCount`过程所必需的。
❷	确保用户已在命令行上指定了参数。
❸	过早停止应用程序，因为如果没有该参数，它将无法继续。
❹	检索用户指定的第一个参数并将其分配给新`serverAddr`变量。
❺	向用户显示消息`"Connecting to <serverAddr>"`，其中 `<serverAddr>` 是用户指定的地址。

检查提供给可执行文件的参数数量总是很重要的。“paramCount”过程以整数形式返回参数数。上面的示例检查参数的数量是否为0，如果是，则调用“退出”过程，并显示应用程序退出的详细消息。“退出”过程退出应用程序，如果提供了一条消息，它将首先显示该消息并退出，退出代码告诉操作系统应用程序失败。

如果用户确实提供了命令行参数，则使用“paramStr”过程检索提供的第一个参数。使用索引1，因为可执行文件名存储在索引0处。然后将第一个命令行参数绑定到“serverAddr”变量。

>[警告]	可执行文件名称
不要通过 检索可执行文件名称，因为它可能会为您提供不可移植的特定于操作系统的数据。应改用模块中定义的过程。paramStr(0)getAppFilenameos	

>[注意]	始终使用paramCount
当通过不存在的过程访问参数时（例如当 ），将引发异常。您应该始终使用提前时间来检查已提供的参数数量。paramStrparamStr(56)paramCount() == 1IndexErrorparamCount

示例 3.3 中的最后一行使用该过程在屏幕上显示附加到变量内容的字符串。该过程接受可变数量的参数，并在同一行上显示每个参数。

```
echo"Connecting to "serverAddrecho
```

>提示 分析命令行参数| |应用程序通常为命令行参数实现特殊语法。此语法包括标志，例如 和 更多。Nim 标准库中包含的模块允许解析这些参数。Nim 社区还创建了其他更直观的软件包，用于检索和解析命令行参数，您将在本书的后面章节中了解它们。|--helpparseopt

使用上一节中的命令重新编译新模块，并像之前一样执行它。client.nim

图 3.6.在没有任何参数的情况下启动客户端

![ch03 exec1](../Images/ch03_exec1.png)

如图 3.10 所示，应用程序将立即退出，并显示消息“请指定服务器地址，例如 ./client localhost”。现在使用单个参数执行它，如示例中所示：。src/client localhost

图 3.7.使用 1 个参数启动客户端

![ch03 exec2](../Images/ch03_exec2.png)

您会注意到应用程序现在显示消息“连接到本地主机”，现在尝试指定不同的参数，看看你得到什么结果。

无论您键入多少个参数，只要至少有一个参数，消息将始终包含“连接到”，后跟您指定的第一个参数。

图 3.12 显示了命令行参数如何映射到不同的索引。paramStr

图 3.8.提供的命令行参数以及如何访问它们

![ch03 paramStr](../Images/ch03_paramStr.png)

现在客户端成功捕获了服务器地址，它将知道要连接到哪个服务器。现在，您需要考虑向用户请求他们想要发送的消息。

**从标准输入流读取数据**

与在应用程序启动之前传递给它的命令行参数不同，我们希望用户能够实时发送消息，以响应他们从其他用户接收到的消息。这意味着我们希望我们的应用程序理想地做的是始终准备好从用户读取数据。

当应用程序在终端或命令行内部运行时，可以在终端窗口中键入字符。应用程序可以通过标准输入流检索这些字符。与Python一样，可以通过“stdin”变量访问标准输入流。在Nim中，此变量在隐式导入的“system”模块中定义，其类型为“File”。这意味着可以像读取任何其他“文件”对象一样读取标准输入流。为从“File”对象读取数据定义了许多过程，通常最有用的是从指定的“File”读取单行数据的“readLine”过程。

将*清单3.4*中的以下代码添加到“client.nim”的底部，然后重新编译并运行它（可以使用以下命令“nim c-r src/client.nim localhost”快速完成）。

清单 3.4.从标准输入流读取
```nim
let message = stdin.readLine()      ❶
echo("Sending \"", message, "\"")   ❷
```

>❶	从标准输入流中读取一行文本并将其分配给变量。message
❷	显示消息“正在发送”“，其中是变量的内容，其中包含用户在其终端窗口中键入的文本行。<message>message
 

>注释字符转义序列
*清单3.4*中的最后一行使用字符转义序列来显示“”字符。这需要转义，否则编译器会认为字符串文本已经结束

您将看到应用程序不再立即退出，而是等待您在终端窗口中键入内容并按Enter键。完成此操作后，将显示一条消息，其中包含您在终端窗口中键入的文本。

从标准输入流读取将导致应用程序停止执行，应用程序将被*阻止*。一旦请求的数据被完全读取，将继续执行。在“stdin.readLine”的情况下，在用户向终端输入一些字符并按下Enter键之前，应用程序一直被阻止。当用户执行这些操作时，实际上是将一行文本存储到“stdin”缓冲区中。

阻塞是大多数输入/输出调用的一个不幸的副作用，不幸的是，这意味着您的应用程序在等待用户输入时将无法执行任何有用的工作。这实际上是一个问题，因为该应用程序需要主动保持与聊天服务器的连接，如果它等待用户在终端窗口中键入文本，则无法做到这一点*下图3.13*显示了这导致的问题。

图3.9.客户端被无限期阻止导致的问题

![ch03 client blocked](../Images/ch03_client_blocked.png)

在我们继续解决这个问题之前。清单 3.4 中缺少一些东西，代码只读取消息一次，但目的是允许用户发送多条消息。这样做相对简单，你只需要使用 while 语句引入一个无限循环。只需将示例 3.4 中的代码包装在 while 语句中，如下所示。
```nim
while true:   ❶
  let message = stdin.readLine()   ❷
  echo("Sending \"", message, "\"")
```
>❶	该语句将在其正文中重复这些语句，而其条件为 。在这种情况下，它将重复其下面的两个语句，直到用户手动关闭应用程序。whiletrue
❷	这两行将无限重复，因为它们在 while 语句下缩进。

现在再次编译并运行代码，亲自查看结果是什么。您应该能够在终端窗口中输入任意数量的文本行，直到您当然通过按无处不在的 Control 和 C 组合键（同时按 Ctrl + C）终止应用程序。

终止应用程序时，应会看到类似于以下内容的回溯。
```
Traceback (most recent call last)
client.nim(9)            client
sysio.nim(115)           readLine
sysio.nim(72)            raiseEIO
system.nim(2531)         sysFatal
SIGINT: Interrupted by Ctrl-C.
```

终止应用程序实际上是确定当前正在执行哪一行代码的好方法。上面你可以看到，当应用程序终止时，client.nim 中的第 9 行正在执行，这对应于等待用户输入的阻塞调用。
```nim
let message = stdin.readLine()readLine
```
图 3.10.当前执行client.nim

![ch03 input thread](../Images/ch03_input_thread.png)

图 3.14 显示了 中的当前执行流程。主线程在等待用户输入时被阻塞。因此，应用程序将处于空闲状态，直到用户通过在终端窗口中键入一些文本并按 Enter 将其唤醒。这是阻塞输入/输出操作的固有问题，如果客户端只需要对用户的输入做出反应，我们无需担心。遗憾的是，如上所述，客户端必须保持与服务器的持久连接才能从其他客户端接收消息。client.nim

**使用`spawn`生成避免阻塞输入/输出**

有多种方法可以确保您的应用程序在从标准输入流读取数据时不会阻塞。一种是异步输入/输出，即使结果不是立即可用，它也允许应用程序继续执行。不幸的是，标准输入流无法异步读取，因此这次不能使用异步 I/O，但稍后将通过网络传输数据时使用。届时将更详细地解释。另一种解决方案是创建另一个线程，该线程将读取标准输入流，保持主线程畅通无阻并自由执行其他任务。我现在将向您展示如何修改以实现此解决方案。client.nim

并行性的全部细节及其在 Nim 中的工作原理将在本章中不描述，但将在本书后面介绍。简而言之，每个进程至少包含一个线程，默认情况下，一个进程仅从一个称为主线程的线程开始。中指定的所有代码当前都在该主线程中执行。调用 时，此主线程将被阻塞。当用户在终端中输入一行时，线程将变得畅通无阻。可以创建一个单独的线程以使主线程保持活动状态，从而确保创建的线程是被阻塞的线程。client.nimreadLine

可以使用过程在新线程中执行过程。以下代码演示如何执行此操作。将其替换为之前创建的 while 语句，但暂时不要编译代码。spawn

```nim
while true:
  let message = spawn stdin.readLine()   ❶
  echo("Sending \"", ^message, "\"")     ❷
```

>❶	关键字现在用于调用该过程，这将生成一个新线程并在那里执行。spawnreadLinereadLine
❷	从线程返回的值不会立即可用，因此读取它必须由操作符`^`显式完成。

“readLine”过程返回字符串值。但是当这个过程在另一个线程中执行时，它的返回值不是立即可用的。为了解决这个问题，“派生”返回一个名为“FlowVar[T]”的特殊类型。此类型保存您派生的过程返回的值。

`^`运算符可用于检索`FlowVar[T]`类型保存的值。但`FlowVar[T]`对象可能不总是包含值，它将开始为空，一旦派生过程返回值，`FlowVar[T]`对象将包含该值。当`FlowVar[N]`对象为空时，`^`运算符将阻止当前线程，直到`FlowVar[T]`不再为空。如果一开始不为空，则`^`运算符将立即返回值。

这就是为什么上面的代码实际上会以与前面代码类似的方式运行。幸运的是，您还可以使用`isReady`过程检查`FlowVar[T]`类型是否包含值。使用该过程将允许应用程序避免阻塞行为。

**泛 型**

泛型是Nim的一个特性，您将在*第9章*中详细介绍。目前，您只需要知道`FlowVar[T]`是一种泛型类型。这允许它存储任何类型的值，存储的值的类型在方括号中指定。

例如，`spawn stdin.readLine()` 表达式返回`FlowVar[string]`类型，因为`readLine`的返回类型是`string`，并且因为`FlowVar`包装派生过程的返回值。

将`spawn`派生调用应用于任何返回字符串`string`的过程将产生`FlowVar[string]`值：

```nim
import threadpool
proc foo: string = "Dog"
var x: FlowVar[string] = spawn foo()
assert(^x == "Dog")
```

请参阅图 3.15 以了解两个不同的线程如何相互交互。将其与图 3.14 进行比较，看看在引入 .clientspawn

图 3.11.当前执行client.nim

![ch03 input thread 2](../Images/ch03_input_thread_2.png)

现在有一个辅助线程，但结果是相同的，主线程和线程都被阻塞，产生相同的结果。readLinereadLine

现在让我向您展示如何修改以便使用 .清单 3.5 显示了完整的代码，更改后的行以粗体显示。需要注意的关键点是该过程是在模块中定义的，因此您必须记住通过 导入它。client.nimspawnspawnthreadpoolimport threadpool

清单 3.5.到目前为止的代码client.nim

```nim
import os, **threadpool**

echo("Chat application started")
if paramCount() == 0:
  quit("Please specify the server address, e.g. ./client localhost")
let serverAddr = paramStr(1)
echo("Connecting to ", serverAddr)
while true:
  let message = **spawn** stdin.readLine()
  echo("Sending \"", **^message**, "\"")
```

编译现在需要该标志。要编译和运行该文件，您现在应该执行 .需要该标志才能打开 Nim 的线程支持，否则它将无法运行。--threads:onclient.nimnim c -r --threads:on src/client.nim localhost--threads:onspawn

提示 Nim 配置文件| |诸如旗帜之类的标志可以快速积累。Nim 编译器支持配置文件，使您不必在命令行上重新键入所有这些标志。只需创建一个文件（在文件旁边）并在那里添加。每个标志都需要在自己的行上，因此您可以通过用换行符分隔它们来添加额外的标志。|--threads:onclient.nim.cfgclient.nim--threads:on

应用程序的行为方式仍与以前相同。但是，对标准输入流读取代码所做的更改将在本章后面有用。在下一节中，我将向您展示如何添加异步网络代码，允许客户端应用程序连接到服务器。服务器本身也将使用相同的异步 I/O 方法，以便一次与多个客户端通信。client

本部分介绍如何在应用程序运行时以两种不同的方式从用户读取输入：作为命令行参数和从标准输入流读取。我还讨论了标准阻塞 I/O 的问题，并向您展示了一种解决方法。现在让我们继续为您的聊天应用程序编写协议。

3.4 实现协议
-----------

通过网络与另一个应用程序通信的每个应用程序都需要定义用于该通信的协议。协议可确保两个应用程序可以相互理解。它类似于我们人类使用的自然语言，也是一种基本一致的标准，并且可以被通信双方理解。想象一下，试图与一个只会说中文的人用英语交流。你不会理解他们，他们也不会理解你。同样，应用程序中的不同组件必须使用相同的语言进行通信才能相互理解。

![ch03 human protocol](../Images/ch03_human_protocol.png)

重要的是要记住，即使协议定义良好，仍然有很大的错误空间。消息可能只是未正确传输。这就是为什么解析给定消息的代码可以处理格式不正确的消息或不包含所需数据的消息至关重要的原因。我将在本节中向您展示的代码不会竭尽全力验证它收到的消息的有效性。但我鼓励您稍后花时间添加异常处理代码，以验证消息的有效性，并为代码用户提供更好的异常消息。

解析和生成消息的代码易于测试。因此，我还将在本节中向您展示一些测试代码的基本方法。

聊天应用程序的协议将是一个简单的协议。它将在客户端之间传输的信息仅包含用户决定发送给其他客户端的消息和用户名。

有很多方法可以对这些信息进行编码，但最简单的方法之一是将其编码为 JSON 对象，这就是我将向您展示如何操作的内容。

3.4.1 模块
--------

您已经看到许多模块示例。您编写的文件本身就是一个模块，并且您还使用关键字将 Nim 标准库中的模块导入到您的代码中。client.nimimport

到目前为止，我还没有确切地解释模块是什么。如今，许多编程语言都使用模块系统。Nim的模块系统相当简单：每个Nim文件，即以“nim”扩展名结尾的文件，也是一个模块。只要编译器可以找到该文件，就可以成功导入该文件。

我在本书的这一点上向你解释模块系统的原因是因为，理想情况下，即将推出的消息解析器应该写在一个单独的模块中，我认为最好用一个实际的例子来解释它。模块系统允许您将应用程序的功能分离到独立的模块中。在我们的例子中，这样做的一个优点是模块是可互换的。只要模块的接口保持不变，就可以更改它实现的底层协议。因此，稍后您可以轻松地使用 JSON 以外的其他内容对消息进行编码。

现在创建一个模块来容纳您的新消息解析器，只需在文件旁边的目录中创建一个名为的新文件。这样做之后，您的源目录将同时包含 和 模块。protocol.nimsrcclient.nimclientprotocol

默认情况下，您在模块中定义的所有内容只能在该模块内部访问，不能在模块外部访问，因为它是私有的。这允许您隐藏模块的某些实现细节，并精确地决定哪些应该向导入它的模块公开。在某些语言中，和关键字用于指定定义的可见性，[12]在 Nim 中，默认情况下每个定义都是私有的，因此只需要将其公开，这可以使用运算符来完成。publicprivate*

可以放在过程名称、变量名称、方法名称和字段名称的末尾。*

清单 3.6.消息类型定义和进程存根
```
type
  Message* = object     ❶
    username*: string   ❷
    message*: string

proc parseMessage*(data: string): Message =   ❸
  discard   ❹
```

>❶	此行定义一个新类型。导出标记放置在类型名称之后。Message*
❷	两个字段定义遵循类型定义，并以类似的方式导出。
❸	此行定义一个新过程。导出标记也用于名称后以导出它。parseMessage
❹	这是必需的，因为过程的主体不能为空。discard

示例 3.6 显示了存储来自服务器的消息包含的两条信息的类型定义，即客户端的用户名和实际的消息。这些定义中的每一个都使用标记导出。最后定义过程。它接受字符串类型，这是客户端从服务器接收的原始字符串，或由客户端发送的原始字符串，具体取决于您如何看待它。然后，该过程返回一个类型的值，该值是分析的消息。此过程也会导出，它与类型一起形成模块的公共接口。Message*parseMessagedataparseMessageMessageprotocolMessage

现在，您应该将清单 3.6 中的代码添加到您之前创建的模块中。然后确保它使用 .protocolnim c src/protocol

模块系统的基础知识应该很容易掌握，因为它们很简单。还有一些额外的事情需要注意，但这应该足以让你开始编写简单的模块。现在让我们继续实现该过程。parseMessage

3.4.2 解析 JSON
--------------

JSON 是一种非常简单的数据格式。它被广泛使用，Nim在其标准库中支持解析和生成JSON。这使得 JSON 成为存储两个消息字段的完美候选者。

一个典型的JSON片段由一个包含多个字段的对象组成，字段名称是简单带引号的字符串，值可以是整数，浮点数，字符串，数组或其他对象中的任何一个。

让我们回顾一下我在本章开头定义的关于《权力的游戏》的对话。我将发送的第一条消息将是“你们对最新的《权力的游戏》剧集有什么看法？这可以像这样使用 JSON 表示。

清单 3.7.JSON 中消息的表示形式
```nim
{   ❶
  "username": "Dominik",   ❷
  "message": "What did you guys think about the latest Game of Thrones episode?"   ❸
}
```

>❶	大括号定义对象。
❷	具有相应值的`username`字段。
❸	具有相应值的`message`字段。

在 Nim 中解析 JSON 非常容易。首先，通过添加到文件顶部来导入模块。然后将 proc 中的语句替换为 。清单 3.8 以粗体显示了添加的代码。jsonimport jsondiscardparseMessagelet dataJson = parseJson(data)

清单 3.8.解析 JSON protocol.nim
```nim
**import json**
type
  Message* = object
    username*: string
    message*: string

proc parseMessage*(data: string): Message =
  **let dataJson = parseJson(data)**
```

模块中定义的过程接受字符串并返回该类型的值。parseJsonjsonJsonNode

类型是变体类型。这意味着可以访问的字段由始终在该类型中定义的一个或多个其他字段的值确定。在这种情况下，它是确定被解析的 JSON 节点类型的字段。JsonNodeJsonNodekind

**有关变体类型的一些信息**

变体类型是其字段根据一个或多个字段的值而变化的对象类型。让我直接举一个例子，因为这样解释它们要容易得多。

清单 3.9.使用变型类型对盒子进行建模
```nim
type
  Box = object           ❶
    case empty: bool     ❷
    of false:            ❸
      contents: string   ❹
    else:
      discard            ❺

var obj = Box(empty: false, contents: "Hello")   ❻
assert obj.contents == "Hello"                   ❼

var obj2 = Box(empty: true)
echo(obj2.contents)      ❽
```

>❶	变量类型的定义方式与普通对象类型类似。
❷	区别在于对象定义下的 case 语句。这实际上定义了此类型的字段。empty
❸	如果字段是，则可访问此分支下定义的字段。emptyfalse
❹	在以下情况下，该字段将可访问。contentsempty == false
❺	如果出现以下情况，则未定义其他字段。empty == true
❻	当字段在构造函数中设置为 时，还可以指定该字段。emptyfalsecontents
❼	因为是可以访问的字段。obj.emptyfalsecontents
❽	这将导致错误，因为无法访问该字段。无法访问它，因为 是 。contentsemptytrue

3.9 例显示了如何对一个可能为空的普通盒子进行建模。在示例 3.9 的末尾，我展示了一个错误的情况，其中访问了一个空框的内容。编译和运行上述代码会导致错误也就不足为奇了。
```
Traceback (most recent call last)
variant.nim(13)          variant
system.nim(2533)         sysFatal
Error: unhandled exception: contents is not accessible [FieldError]
```
这只是一个非常简单的变体类型，只有两个状态。也可以在变量类型的case语句中使用枚举类型。这非常常见，用于`JsonNode`类型。

有7种不同的`JsonNodeKind`。`JsonNodeKind`类型是一个枚举，每种JSON值都有一个值*清单3.10*提供了所有7个以及它们映射到的`JsonNodeKind`的列表。

清单3.10.JSON值与`JsonNodeKind`类型之间的映射

```nim
assert parseJson("null").kind == JNull
assert parseJson("true").kind == JBool
assert parseJson("42").kind == JInt
assert parseJson("3.14").kind == JFloat
assert parseJson("\"Hi\"").kind == JString
assert parseJson("""{ "key": "value" }""").kind == JObject
assert parseJson("[1, 2, 3, 4]").kind == JArray
```
当解析任意JSON数据时，需要一个变量类型，因为编译器无法在编译时知道生成的JSON类型应该是什么。这只有在运行时才知道。这就是`parseJson`过程返回`JsonNode`类型的原因，该类型的内容因传递到`parseJson`过程的JSON值的类型而异。

*清单3.10*中显示的最后两个JSON值是集合。`JObject`类型表示`string`和`JsonNode`之间的映射。`JArray`类存储`JsonNode`的列表。

可以使用“`[]`”运算符访问`JObject`的字段。它类似于数组和序列`[]`运算符，但采用`string`作为其参数。该字符串确定要从`JObject`中检索值的字段。需要记住的一点是，`[]`运算符返回一个`JsonNode`值。

```nim
import json
let data = """
  {"username": "Dominik"}
"""

let obj = parseJson(data)    ❶
assert obj.kind == JObject   ❷
assert obj["username"].kind == JString    ❸
assert obj["username"].str == "Dominik"   ❹
```

>❶	只需解析字符串并返回一个类型，然后将其分配给变量。dataJsonNodeobj
❷	返回的 具有一种类型，因为这是包含在 中的 JSON 类型。JsonNodeJObjectdata
❸	使用运算符访问字段。它返回另一个，在这种情况下它是一个。[]JsonNodekindJString
❹	由于运算符返回 ，因此必须通过包含该值的字段显式访问它所包含的值。在 的情况下，这是 。一般来说，你最好使用 proc。[]JsonNodeJStringstrgetStr
 

>[注意] `kind`很重要
|在“JsonNode”的“kind”字段不是“JObject”的字符串上调用“[]”运算符将导致引发异常

那么，如何从解析的“`JsonNode`”中检索“`username`”字段？使用`dataJson["username"]`将返回另一个`JsonNode`。除非已解析的“`JObject`”中不存在“username”字段，否则将引发“`KeyError`”异常。在上面的列表中，`dataJson["username"]`将返回的`JsonNode`类型将是`JString`，因为该字段包含一个`string`值。您可以使用“`getStr`”过程检索“`string`”值。每个“`JsonNode`”类型都有一个“`get`”过程，如果要返回的值的类型与“`JsonNode`”类型不匹配，则每个“`get`”程序将返回一个默认值。

>提示 `get`默认值|
|可以重写`get`过程返回的默认值。要重写，请传递默认情况下要作为过程的第二个参数返回的值，例如`node.getStr("Bad kind")`.


现在，您只需要将此用户名分配给`Message`类型的新实例。请参见代码*清单3.11*，它显示了完整的`protocol`模块，添加的新分配以粗体显示。

清单3.11将解析的数据分配给结果变量

```nim
import json
type
  Message* = object
    username*: string
    message*: string

proc parseMessage*(data: string): Message =
  let dataJson = parseJson(data)
  **result.username = dataJson["username"].getStr()**   ❶
  **result.message = dataJson["message"].getStr()**     ❷
```

>❶	获取键下的值，并将其字符串值分配给结果 ."username"usernameMessage
❷	在此处执行相同的操作，但改为获取键下的值。"message"
只需简单地添加两行代码即可完成。

**神奇的变量`result`**

您可能想知道 3.11 中的变量来自哪里。答案是，Nim含蓄地为你定义了它。此变量在使用返回类型定义的所有过程中定义。resultresult
```nim
proc count10(): int =
  for i in 0 .. 10:
    result.inc
assert count10() == 10
```
这意味着您不需要重复定义“result”变量，也不需要返回它。“result”变量将自动为您返回。回顾第2章中的“过程定义”一节，了解更多信息。

您应该尽可能快速和频繁地测试代码。现在可以通过开始将新模块与客户端模块集成来实现这一点，但最好将代码作为单独的单元进行测试。协议模块是隔离测试的良好代码单元。测试模块时，最好测试每个导出的过程，以确保它们按预期工作。协议模块当前只导出一个过程，即“parseMessage”过程，因此您只需要为其编写测试。

在Nim中测试代码有多种方法，最简单的方法是使用“doAssert”过程。“doAssert”过程在“system”模块中定义。它类似于“assert”过程，它接受一个“boolean”类型的参数，如果该“boolean’的值为“false”，则引发“AssertionFailed”异常。它与“assert”有一个简单的区别，即在发布模式下编译应用程序时（通过“-d:release”标志），“assert”语句会被优化，而“doAssert”语句则不会。

>注意：发布模式
|默认情况下，Nim 编译器在调试模式下编译应用程序。在调试模式下，您的应用程序运行速度稍慢，但会执行某些检查，这些检查会为您提供有关可能意外引入程序的某些错误的更多信息。部署应用程序时，为了获得最佳性能，应使用将其置于发布模式的标志对其进行编译。|-d:release

让我们定义一个输入，然后用于测试 的输出。doAssertparseMessage

示例 3.12.测试新功能
```nim
when isMainModule:   ❶
  block:             ❷
    let data = """{"username": "John", "message": "Hi!"}"""   ❸
    let parsed = parseMessage(data)      ❹
    doAssert parsed.username == "John"   ❺
    doAssert parsed.message == "Hi!"     ❻
```

>❶	该语句是一个编译时，仅当其条件为 .常量是当前模块尚未导入的情况。这意味着如果导入此模块，测试代码将被隐藏。wheniftrueisMainModuletrue
❷	开始一个新的作用域，用于隔离测试。
❸	这里我使用三引号字符串文字语法来定义要解析的数据，三引号字符串文字意味着 JSON 中的单引号不需要转义。
❹	对上面定义的数据调用该过程。parseMessage
❺	检查解析的用户名是否正确。parseMessage
❻	检查解析的消息是否正确。parseMessage

将示例 3.12 中的代码添加到文件底部，然后编译并运行代码。程序应成功执行，没有输出。虽然这一切都很好，但至少收到某种消息让您知道测试成功会很好，因此只需添加到文件底部即可。只要所有测试都通过，您的程序现在应该输出该测试。echo("All tests passed!")

尝试更改其中一个断言以检查不同的输出并观察发生的情况。例如，从语句中删除感叹号将导致以下错误。doAssert parsed.message == "Hi!"
```nim
Traceback (most recent call last)
protocol.nim(17) protocol
system.nim(3335) raiseAssert
system.nim(2531) sysFatal
Error: unhandled exception: parsed.message == "Hi"  [AssertionError]
```

如果你修改协议模块并破坏你的测试，你可能会发现突然你会得到这样的错误。

您现在有一个正确输入的测试，不正确的输入呢？创建另一个测试以查看输入不正确时会发生什么情况。

```nim
block:
  let data = """foobar"""
  let parsed = parseMessage(data)
```
现在编译并运行，你应该得到以下输出。protocol.nim

```nim
Traceback (most recent call last)
protocol.nim(21) protocol_progress
protocol.nim(8)  parseMessage
json.nim(1086)   parseJson
json.nim(1082)   parseJson
json.nim(1072)   parseJson
json.nim(561)    raiseParseErr
Error: unhandled exception: input(1, 5) Error: { expected [JsonParsingError]
```

由于指定的数据不是有效的 JSON，因此引发了异常。但这是应该发生的事情，因此在测试中通过捕获异常并确保已引发异常来定义它。parseJson

```nim
block:
  let data = """foobar"""
  try:
    let parsed = parseMessage(data)
    doAssert false   ❶
  except JsonParsingError:   ❷
    doAssert true
  except:
    doAssert false
```

>❶	此行永远不应执行，因为会引发异常。parseMessage
❷	确保引发的异常是预期的异常。

proc 报告错误的理想方法是引发自定义异常。但这超出了本章的范围。我鼓励你在学会如何做到这一点后回来实施它。现在让我们继续生成 JSON。parseMessage

3.4.3 生成 JSON
-----------------

您已经成功解析了JSON，现在让我们继续生成JSON。协议模块需要能够解析和生成消息。值得庆幸的是，生成JSON甚至比解析它更简单。

在Nim中，JSON可以通过多种方式生成。一种方法是简单地创建一个字符串，其中包含与值连接的正确JSON，就像在第一次测试中所做的那样。这会起作用，但容易出错，因为很容易漏掉JSON的某些语法元素。另一种方法是构造新的“JsonNode”，并使用“$”运算符将其转换为字符串。让我们现在就这么做。首先定义新的“createMessage”过程，然后使用“%”运算符创建新的“JsonNode”对象*清单3.13*显示了如何定义“createMessage”过程。


清单 3.13.创建新消息
```nim
proc createMessage*(username, message: string): string =
  result = $(%{   ❶
    "username": %username,   ❷
    "message": %message
  }) & "\c\l"   ❸
```

>❶	将运算符返回的内容转换为字符串。$JsonNode%
❷	将字符串、整数、浮点数等转换为适当的 's。%JsonNode
❸	回车符和换行符将添加到消息末尾。它们充当消息的分隔符。
 

>注意 表构造函数语法
您在上面的代码清单中看到的`{:}`语法称为表构造函数。它只是数组构造函数的语法糖，即 `{"key1": "value1", "key2": "value2"}`与`[("key1", "value1"), ("key2, "value2")]`相同。

“%”运算符非常强大，因为它可以将各种不同类型的值转换为适当的“JsonNode”类型。这允许使用非常直观的语法创建JSON。

按照惯例，“$”是用于将任何类型转换为“string”值的运算符。在“JsonNode”的情况下，为其定义的“$”运算符将生成生成的“JsonNode”对象的有效JSON字符串文字表示。
当客户端和服务器组件需要接收消息时，添加回车符和换行符（某些操作系统使用换行符表示换行符）将很有用。他们需要一种方法来确定一条新消息何时停止，另一条消息何时开始，本质上这些字符将是消息分隔符。在实践中，可以使用任何分隔符，但“\c\l”序列已在许多其他协议中普遍使用，并且由Nim的网络模块支持。

与“parseMessage”过程一样，您也应该为“createMessage”过程添加测试。只需再次使用“doAssert”，以确保输出符合预期。记住在预期输出中包含“\c\l”。下面的代码列表显示了一个可以执行的测试，将其添加到“protocol.nim”的底部。

```nim
block:
  let expected = """{"username":"dom","message":"hello"}""" & "\c\l"   ❶
  doAssert createMessage("dom", "hello") == expected
```
>❶	这里要注意的一件有趣的事情是，三引号字符串文字根本不支持任何字符转义序列。作为一种解决方法，我只是将它们连接起来。

重新编译模块并运行它以确保测试通过。（可选）您可以通过检查不同的输入来进一步扩展测试，例如包含 JSON 中具有特殊含义的字符（如字符）的输入。"

假设所有测试都通过了，那么您已经成功完成了该模块，现在已准备好进入此应用程序开发的最后阶段！protocol

[12]特别是C++和Java使用and关键字来表示标识符的可见性。publicprivate

3.5 使用套接字传输数据
-------------------

此时，您正在完成此聊天应用程序。模块已完成，模块已基本完成。在完成模块之前，让我们看一下到目前为止完全被忽视的模块。protocolclientclientserver

该模块可以说是最重要的模块之一，它将单独编译以生成二进制文件。如前所述，它将充当所有客户端将连接到的中心枢纽。将需要执行两个主要任务：serverserverserverserver

倾听潜在客户的新联系;和
侦听来自已连接到服务器的每个客户端的新消息
接收的任何消息都需要发送给当前连接到它的所有其他消息。

serverclient

图 3.12.聊天应用程序的操作

![ch03 chat server](../Images/ch03_chat_server.png)

您在第一部分中看到的图 3.16 显示了服务器和客户端的操作。这是一个简化的图表，不包含任何协议细节。现在您已经熟悉了聊天应用程序将使用的协议，我可以向您展示将在图 3.16 中发送的确切消息。首先假设服务器已成功接受来自 Dom、John 和 Grace 的连接。以下事件按显示顺序发生。

示例 3.14.首先，客户端 Dom 向服务器发送消息
```json
{"username": "Dom", "message": "Hello"}   ❶
```
>❶	请记住，此消息后跟 .\c\l

示例 3.15.然后服务器将相同的消息发送给客户端 John 和 Grace
```json
{"username": "Dom", "message": "Hello"}   ❶
```
>❶	此消息后还跟着 .\c\l

您可以看到服务器只是将它收到的任何消息传递给其他客户端。为简单起见，服务器不检查任何客户端的身份，因此它们可以模拟其他用户。在本章结束时，将有足够的空间来改进此应用程序，并且安全性将是鼓励您加强的一个方面。

暂时不用担心安全性，让我们继续创建服务器模块。让我们从定义它将使用的类型开始。首先，在目录中创建一个新文件。然后创建清单 3.16 中所示的类型。server.nimsrc

清单 3.16.标准库导入和类型定义
```nim
import asyncdispatch, asyncnet   ❶

type   ❷
  Client = ref object      ❸
    socket: AsyncSocket    ❹
    netAddr: string        ❺
    id: int                ❻
    connected: bool        ❼

  Server = ref object      ❽
    socket: AsyncSocket    ❾
    clients: seq[Client]   ❿
```

>❶	导入包含使用异步套接字所需的过程和类型的 and 模块。asyncdispatchasyncnet
❷	开始一个新的类型部分。
❸	将类型定义为引用类型。Client
❹	属于客户端的套接字，类型为异步套接字。AsyncSocket
❺	存储此客户端连接的地址的字段。
❻	此客户端的标识号。
❼	确定此客户端是否仍处于连接状态的标志。
❽	将类型定义为引用类型。Server
❾	用于接受新客户端连接的服务器套接字。
❿	已连接对象的列表。Client

和类型都被定义为引用类型，你可能还记得第2章中的这些类型，它们是这样定义的，因为它允许将这些类型作为参数的过程来修改它们。这将是必不可少的，例如，当新客户端连接时，需要将新元素添加到字段中。ServerClientclients

该类型包含与服务器直接相关的信息，例如服务器套接字和已连接到它的客户端。同样，该类型表示连接到服务器的单个客户端，它包括提供有关每个客户端的有用信息的字段。例如，包含客户端 IP 地址的字段，以及将保存每个客户端生成的身份的字段，允许您区分它们。该标志很重要，因为它跟踪客户端是否仍处于连接状态。服务器需要知道这一点，因为它不应该尝试将消息发送到断开连接的客户端。ServerClientnetAddridconnected

现在剩下的就是为新定义的类型创建一个构造函数。Server

**Nim的构造函数**

Nim 中的构造函数只是具有特定命名约定的过程。Nim 不包含任何用于定义此类构造函数的特殊语法，但它确实包含一些用于构造自定义类型的简单语法，您可能还记得第 2 章。示例如下。

元组可以通过简单地将值放在括号中来构造：
```nim
type
  Point = tuple[x, y: int]

var point = (5, 10)
var point2 = (x: 5, y: 10)
```

对象（包括对象）可以通过调用类型（就像它是一个过程一样）来构造，然后指定每个字段名称和值，用冒号分隔：ref
```nim
type
  Human = object
    name: string
    age: int

var jeff = Human(name: "Jeff", age: 23)
var amy = Human(name: "Amy", age: 20)
```

无法重写这些，因此如果您需要更复杂的构造函数，则需要定义一个过程。Nim中有一个关于如何命名这些构造函数过程的约定，下表显示了这些约定以及它们如何应用于不同的类型定义。

|类型定义|名称| 
|---- | --|
| `MyType = object` | `initMyType` |
| `MyTypeRef = ref object` | `newMyTypeRef` |
| `MyTuple = tuple[x, y: int]` | `initMyTuple` |


对于 ref 类型（如类型），过程应命名为 ：ServernewServer

proc newServer(): Server = Server(socket: newAsyncSocket(), clients: @[])
这将创建该类型的新实例并初始化其套接字和序列。现在调用此过程并将其分配给新变量。Serverclientsserver
```nim
var server = newServer()
```

在清单 3.16 中创建的类型下面添加上面定义的两段代码。生成的代码为开始添加网络代码奠定了良好的基础。但在开始之前，让我解释一下网络如何，特别是异步网络在 Nim 中的工作原理。我将首先查看用于通过网络传输数据的基本工具，该工具称为套接字。

3.5.1 什么是套接字？
----------------

在几乎所有编程语言中，通过网络传输数据都是使用网络套接字完成的。Nim 中的网络套接字使用该类型表示。此类型在模块中定义，可以使用该过程创建它的新实例。SocketnetnewSocket

套接字与文件描述符有一些相似之处，因为它们支持 、 和 等操作。但实际上，套接字的差异足以公开不同的接口。下面的表 3.1 显示了为套接字定义的一些常见过程及其文件描述符等效项。writereadopenclose

表 3.1.常见套接字过程

| 过程|等效文件过程| 描述 |
|----|- | --|
| `recv` | `read` | Allows incoming data to be read from the remote side. For TCP sockets `recv` is used, and for UDP sockets `recvFrom` is used. |
| `send` | `write` | Sends data to a socket, allowing data to be sent to the remote side. For TCP sockets `send` is used, and for UDP sockets `sendTo` is used. |
| `connect` | `open` | Connects a socket to a remote server. This is typically only used for TCP sockets. |
| `bindAddr` | None | Binds a socket to the specified address and port. When called, the socket becomes a server socket and other sockets can connect to it. This is typically only used for TCP sockets. |


通过在构造函数中指定不同的选项，可以对套接字进行大量自定义。默认情况下，构造函数将创建一个 TCP 套接字。这很方便，因为碰巧TCP是聊天应用程序将使用的协议。newSocketnewSocket

TCP 协议是一种连接协议，它允许将套接字用作服务器或客户端。新创建的 TCP 套接字在调用 or 过程之前都不是。前者将其转换为服务器套接字，后者转换为客户端套接字。让我们先创建一个服务器套接字，因为这是此应用程序的组件所需要的。bindAddrconnectserver

服务器套接字的主要目的是侦听新连接，并以尽可能少的延迟接受它们。但在执行此操作之前，必须首先将套接字绑定到地址和端口。图 3.17 显示了成功创建和绑定服务器套接字需要调用的过程。

图 3.13.开始在服务器套接字上接受新连接所需的步骤

![ch03 server socket](../Images/ch03_server_socket.png)

首先，每个服务器套接字都需要显式绑定到特定的端口和地址。这可以使用将端口作为第一个参数和地址作为第二个参数的过程来完成。默认情况下，地址只是“本地主机”，但必须始终指定端口。您可以将端口指定为所需的任何端口，但请注意，其他应用程序经常使用标准端口。这方面的一个例子是 HTTP 服务器使用的端口 80。需要注意的另一点是，绑定到 1024 或更小的端口需要管理员权限。bindAddr

其次，在套接字开始接受连接之前，您必须在其上调用该过程。该过程告知套接字开始侦听传入连接。listenlisten

然后可以使用该过程接受新连接。此过程返回一个新的客户端套接字，该套接字对应于刚刚连接到调用 中指定的地址和端口的套接字。acceptbindAddr

提示 有关套接字|的详细信息 |不要担心记住本节中写的所有细节，将其用作参考，与下一节一起展示如何将这些知识付诸实践。|

与从标准输入读取数据类似，该过程会阻止应用程序，直到建立新连接。这是一个问题，但由于 Nim 对异步套接字的支持，这个问题很容易解决。异步套接字不会阻塞，可以代替同步阻塞套接字使用，而不会有太大麻烦。异步套接字在模块中定义，我将在下一节中解释它们的工作原理。acceptasyncnet

3.5.2 异步输入/输出
-----------------

Nim 支持许多抽象，这使得异步 I/O 工作变得简单，这部分是通过使异步 I/O 与同步 I/O 非常相似来实现的，因此您不需要使代码逻辑比需要的更复杂。

让我们首先更详细地看一下该过程。该过程采用一个参数：服务器套接字。此过程用于检索已连接到指定服务器套接字的新客户端。acceptaccept

该过程的同步版本和异步版本之间的最根本区别如下：accept

同步过程会阻止调用它的线程，直到新套接字连接到服务器套接字;而accept
异步过程在调用后立即返回。accept
但是异步版本返回什么？它当然不能立即返回接受的套接字，因为新客户端可能尚未连接，因此没有要接受的内容。

相反，异步返回一个对象。了解异步 I/O 的基础是了解未来是什么，因此让我们更详细地了解一下它。acceptFuture[AsyncSocket]

**未来型`Future`**

这是一种特殊的类型`Future`，它有很多名称，包括承诺、延迟和延迟在其他语言中。此类型充当最初未知的结果的代理，通常是因为其值的计算尚未完成。

您可以将未来视为一个容器，最初它是空的，当它保持为空时，您无法检索其值。在某个未知的时间点，容器中放置了一些东西，因此它不再是空的。这就是未来这个名字的由来。

Nim 中的每个异步操作都返回一个对象，其中 对应于承诺在未来某个时间点存储的值类型。Future[T]TFuture

类型在模块中定义，您可以轻松地对其进行试验，而无需处理任何异步 I/O 操作。下面的清单 3.17 显示了一个简单的对象的行为。Future[T]asyncdispatchFuture[int]

清单 3.17.简单示例Future[int]
```nim
import asyncdispatch   ❶

var answer = newFuture[int]()    ❷
doAssert(not answer.finished)    ❸

answer.callback =      ❹
  proc (future: Future[int]) =   ❺
    echo("Future is no longer empty, ", future.read)   ❻

answer.complete(42)    ❼
```

>❶	模块在定义类型时需要导入。asyncdispatchFuture[T]
❷	可以使用构造函数初始化新的未来。newFuture
❸	未来开始时为空，当未来不为空时，过程将返回 true。finished
❹	可以设置一个回调，当设置未来的值时将调用该回调。
❺	回调被赋予其值设置为参数的未来。
❻	该过程用于检索未来的值。read
❼	可以通过调用过程来设置未来的值。complete

期货还可以存储异常，以防价值计算失败。调用包含异常的 将导致错误。readFuture

为了演示此操作的效果，请将上面的清单 3.17 的最后一行修改为 。然后编译并运行它。answer.fail(newException(ValueError, "The future failed"))

应用程序应崩溃并显示以下输出：
```
Traceback (most recent call last)
system.nim(2510)         ch3_futures
asyncdispatch.nim(242)   fail
asyncdispatch.nim(267)   :anonymous
ch3_futures.nim(8)       :anonymous
asyncdispatch.nim(289)   read
Error: unhandled exception: The future failed
  unspecified's lead up to read of failed Future:   ❶
    Traceback (most recent call last)
    system.nim(2510)         ch3_futures
    asyncdispatch.nim(240)   fail [Exception]
```

>❶	unspecified是未来的名字，之所以叫它，是因为未来是没有名字的。可以通过在构造函数中指定字符串来命名 futures 以获得更好的调试信息。unspecifiednewFuture

如您所见，错误消息试图将尽可能多的信息打包到自身中。它确实造成了一些混乱，并且缺少一些重要信息。期货产生的错误消息仍在处理中，应该会随着时间的推移而改进。现在，最好了解它们当前的外观，因为在 Nim 中编写异步应用程序时，您无疑会看到它们。

上面的异常是由调用内部存储了异常的未来引起的。为了防止这种情况发生，您可以使用该过程检查将来是否完成并出现异常。此过程返回一个布尔值，该布尔值确定未来是否完成并出现异常。readfailed

使用期货时要记住的一件重要事情是，除非明确读取它们，否则它们存储的任何异常都可能在期货被解除分配时悄无声息地消失。因此，重要的是不要使用期货，而是使用该过程来确保在程序中重新引发任何异常。discardasyncCheck

**同步执行和异步执行的区别**

希望到现在为止，您已经了解了期货的工作原理，并准备回过头来学习更多关于过程上下文中的异步执行的知识。下面的图 3.18 显示了调用同步版本与调用异步版本之间的区别。acceptaccept

图 3.14.同步和异步的区别。accept

![ch03 server socket async](../Images/ch03_server_socket_async.png)

如前所述，异步会立即返回一个对象。而同步会阻止当前线程。当线程被阻塞时，它处于空闲状态，不执行任何有用的计算工作。另一方面，异步版本具有执行计算工作的能力，只要这项工作不需要客户端套接字。它可能涉及以前已连接的客户端套接字，或者可能只涉及计算π的第 1025 个十进制数字。在图 3.18 中，这项工作被掩盖在一个程序下面，该过程可以在后台执行上述任何任务。acceptFutureacceptdoWork

异步版本执行的调用比同步版本多得多。它还保留了对导致相同代码逻辑但性能特征非常不同的调用。doWorkdoWork(socket)

但需要注意的是，图 3.18 中描述的异步执行存在问题。它展示了所谓的忙碌等待，即反复检查未来是否为空。这种技术效率非常低，因为 CPU 时间浪费在无用的活动中。正如您在上一节中看到的，它支持可以用自定义过程覆盖的回调。然后，每当 用值完成时，都会调用回调，导致该值存储在将来，或者完成并出现异常。在该实例中使用回调将防止忙于等待。FutureFuture

**使用回调的异步 I/O 示例**

在你们中的一些人中，回调这个词可能会引发一种恐怖的感觉。但不用担心，您绝不会被迫在 Nim 中使用回调。虽然 公开的最基本的通知机制是回调，但 Nim 提供了所谓的异步等待，它向你隐藏了这些回调。稍后您将了解有关异步等待的更多信息。Future

虽然我确实说过你不会被迫在 Nim 中使用回调，但我将首先通过向您展示它如何与回调一起工作来解释异步 I/O。这样做的原因是我相信您熟悉回调的可能性比异步等待的可能性更高。我将首先在 Node.js 和 Nim 之间进行比较，这种比较不涉及套接字，而是更简单的东西：异步读取文件。

清单 3.18.在节点中异步读取文件
```nim
var fs = require('fs');
fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});
```

示例 3.18 中的代码直接取自 Node 的文档[13]，它只是异步读取文件的内容。执行此脚本时发生的情况是，该函数告诉 Node 运行时读取第一个参数中的路径指定的文件，并在完成后调用第二个参数中指定的函数。函数本身会立即返回，控制权隐式返回给 Node 运行时。现在将其与 Nim 版本进行比较。"/etc/passwd"readFilereadFile

示例 3.19.在 Nim 中异步读取文件

```nim
import asyncdispatch, asyncfile

var file = openAsync("/etc/passwd")   ❶
let dataFut = file.readAll() ❷
dataFut.callback =           ❸
  proc (future: Future[string]) =
    echo(future.read())      ❹

asyncdispatch.runForever()   ❺
```

>❶	异步打开文件并将其绑定到变量。"/etc/passwd"file
❷	请求读取 的所有内容，并将结果类型分配给变量。fileFuture[string]dataFut
❸	分配要在将来完成时调用的新回调。
❹	在回调中，读取现在应该存在的未来内容。
❺	显式运行模块中定义的事件循环。asyncdispatch

Nim 版本乍一看可能看起来更复杂，但这是因为 Nim 的标准库不像 Node 的标准库那样定义单个过程。相反，您必须首先使用获取对象的过程打开文件，然后可以从该对象读取数据。[注14]readFileopenAsyncAsyncFile

除了标准库 API 的差异之外，Nim 版本还有一个更重要的不同之处：该过程不接受回调，而是返回该类型的新实例。然后，回调将存储在 中，并在将来完成时调用。readAllFutureFuture

**事件循环**

在 Node 应用程序中，运行时是事件循环的一种形式，它使用本机操作系统 API 来检查各种事件。其中之一可能是成功读取的文件或从它连接到的服务器接收数据的套接字。运行时将这些事件调度到相应的回调。Nim 的事件循环是在模块中定义的，它在许多方面与 Node 的运行时相似，只是需要显式执行。执行此操作的一种方法是调用该过程。下面的图 3.19 显示了该过程的行为。asyncdispatchrunForeverrunForever

图 3.15.Nim的事件循环asyncdispatch

![ch03 event loop](../Images/ch03_event_loop.png)

Nim 事件循环让您掌控一切。该过程只是过程的包装器，该过程在无限循环中调用该过程。您可以自己调用该过程，这将使您能够更好地控制事件循环。该过程等待事件指定的毫秒数（默认为 500 毫秒），并不总是需要 500 毫秒才能完成，因为事件可能发生得比这早得多。创建事件后，过程将对其进行处理。然后，该过程检查每个当前挂起的对象，以查看 是否正在等待该事件。如果是，则调用 的回调，并填充存储在将来的任何适当值。runForeverpollrunForeverpollpollpollpollFutureFutureFuture

与可以无限时间阻塞的同步 I/O 相比，该过程也阻塞，但只能阻塞可以自由指定的有限时间。这允许您将一定的时间用于 I/O 处理，其余时间用于其他任务，例如绘制 GUI 或执行 CPU 密集型计算。稍后我将在模块中向您展示如何使用此过程，以便将异步套接字与在另一个线程中读取标准输入流的过程混合在一起。pollclientreadLine

**异步等待**

对异步 I/O 使用回调存在一个大问题。问题在于，对于复杂的应用程序逻辑，它们不灵活，导致 - 恰如其分地命名 - 回调地狱。让我用一个示例用例来说明这个问题。假设您要在读取第一个文件后读取另一个文件。为此，您被迫嵌套回调并最终得到变得丑陋且无法维护的代码。

Nim有一个解决这个问题的方法，它是关键词。关键字只能在标有杂注的过程内部使用。它完全消除了回调地狱，并使异步代码几乎与同步代码相同。下面的清单 3.20 显示了如何使用一个过程读取和写入文件。awaitawait{.async.}async

清单 3.20.使用 await 按顺序读取文件和写入文件
```nim
import asyncdispatch, asyncfile

proc readFiles() {.async.} =        ❶
  var file = openAsync("~/test.txt", fmReadWrite)   ❷
  let data = await file.readAll()   ❸
  echo(data)          ❹
  await file.write("Hello!\n")      ❺

waitFor readFiles()   ❻
```

>❶	杂注用于指定过程是异步的。{.async.}readFile
❷	以模式异步打开文件，以便可以读取和写入文件。"~/test.txt"fmReadWrite
❸	文件已完全读取，此处使用的关键字表示应暂停，直到文件完全读取。awaitreadFiles
❹	显示文件的内容。
❺	也向文件写入一些数据。该过程将暂停，直到数据成功写入文件。
❻	运行事件循环，直到完成。readFile

示例 3.20 执行的操作与示例 3.19 中的代码相同，并且更多。在使用关键字的每个点，过程的执行都会暂停，直到等待的完成。此时，过程恢复执行，并自动读取未来的值。当该过程暂停时，应用程序将继续运行，因此线程永远不会被阻塞。这一切都在单个线程中完成，在任何时候都可以暂停多个异步过程，等待事件恢复它们，并在后台回调用于恢复这些过程。awaitreadFilesFuture

用杂注标记的每个过程都必须返回一个对象。在示例 3.20 中，该过程可能看起来什么都不返回，但实际上它返回了一个 ，这是隐式完成的，以避免一直写入的痛苦。可以等待返回 的任何过程。{.async.}Future[T]Future[void]Future[void]Future[T]

下面的图 3.20 显示了清单 3.20 的执行过程。

图 3.16.示例 3.20 的执行

![ch03 async await execution](../Images/ch03_async_await_execution.png)

使用的过程代替运行事件循环，直到过程完成其执行。下面的表3.2显示了到目前为止您看到的所有不同异步关键字之间的比较。waitForrunForeverreadFiles

表 3.2.常见异步关键字之间的比较

|程序|直接|控制事件循环用例|描述 |
|---|---|--------------|------| 
|是的|通常用于需要无限期保持活动状态的服务器应用程序。|永久运行事件循环。| | |是的|通常用于在特定异步过程完成其执行后需要退出的应用程序|运行事件循环，直到指定的将来完成。| | |是的|适用于需要精确控制事件循环的应用。和过程调用此。|侦听指定时间量的事件。| | |没有|安全丢弃期货。通常执行异步进程而不关心其结果。|将指定将来的回调属性设置为将适当处理异常的过程。| | |没有|用于执行另一个异步进程，其结果在 .|暂停异步进程的执行，直到指定的将来完成。|runForeverwaitForpollrunForeverwaitForasyncCheckawaitawait


| Procedure | Controls event loop directly | Use case | Description |
|---|---|--------------|------| 
| `runForever` | Yes | Usually used for server applications that need to stay alive indefinitely. | Runs the event loop forever. |
| `waitFor` | Yes | Usually used for applications which need to quit after a specific asynchronous procedure finishes its execution | Runs the event loop until the specified future completes. |
| `poll` | Yes | For applications which need precise control of the event loop. The `runForever` and `waitFor` procedures call this. | Listens for events for the specified amount of time. |
| `asyncCheck` | No | Discarding Futures safely. Typically to execute an async proc without caring for its result. | Sets the specified future’s callback property to a procedure which will handle exceptions appropriately. |
| `await` | No | Used to execute another async proc whose result is needed in the line of code after the `await`. | Pauses the execution of an async proc, until the specified future completes. |


>[警告]	控制事件循环的过程
通常，不应在异步过程中使用 、 和，因为它们直接控制事件循环。runForeverwaitForpoll	
现在让我向您展示如何使用异步套接字来完成服务器的实现。await

3.5.3 异步传输数据
------------------

您已经初始化了异步套接字并将其存储在变量中。后续步骤如下：server

将套接字绑定到端口，例如 。[注15]7687
调用套接字以开始侦听新连接。listen
通过该过程开始接受连接。accept
您将需要使用，因此需要引入新的异步过程。下面的代码清单显示了执行这些步骤的过程。awaitloop
```nim
proc loop(server: Server, port = 7687) {.async.} =
  server.socket.bindAddr(port.Port)   ❶
  server.socket.listen()

  while true:
    let clientSocket = await server.socket.accept()   ❷
    echo("Accepted connection!")

waitFor loop(server)   ❸
```

>❶	通过将服务器套接字绑定到端口并调用 来设置服务器套接字。整数参数需要强制转换为过程期望的类型。listenportPortbindAddr
❷	调用服务器套接字以接受新客户端。关键字可确保在新客户端连接之前暂停该过程。acceptawait
❸	执行该过程，然后运行事件循环，直到过程返回。looploop

该过程将持续等待建立新的客户端连接。目前对这些连接没有做任何事情，但让我们测试一下这是否有效。将上面的代码添加到 的底部。然后通过运行 来编译并运行服务器。loopserver.nimnim c -r src/server

**在没有客户端的情况下测试服务器**

测试这一点有点棘手，因为您的客户端尚未完成。但是，使用调用的命令行应用程序连接到新服务器相当容易。telnet

在 Windows 上，您可能需要在 Windows 功能菜单中启用它，有关详细信息，请访问此链接：http://windows.microsoft.com/en-gb/windows/telnet-faq。安装后，您应该能够打开一个新的命令窗口，在提示符中键入，然后通过执行命令连接到服务器。然后，服务器应输出“接受连接！telnetopen localhost 7687

在类Unix操作系统（如Linux和Mac OS X）上，该应用程序默认情况下应该可用。您可以简单地打开一个新的终端窗口并执行，然后服务器应该输出“接受连接！telnettelnet localhost 7687

**创建新的客户端实例以保存有关客户端的数据**

现在，让我们扩展创建新实例并将其添加到字段的过程。将 while 循环替换为以下内容。loopClientclients
```nim
while true:
  let (netAddr, clientSocket) = await server.socket.acceptAddr()   ❶
  echo("Accepted connection from ", netAddr)   ❷
  let client = Client(   ❸
    socket: clientSocket,
    netAddr: netAddr,
    id: server.clients.len,
    connected: true
  )
  server.clients.add(client)   ❹
```

>❶	acceptAddr返回一个类型，元组解压缩为两个变量。tuple[string, AsyncSocket]
❷	将显示一条消息，指出客户端已连接及其网络地址。
❸	初始化对象的新实例并相应地设置其字段。Client
❹	最后，将客户端的新实例添加到序列中。clients

该过程的变体已更改为还返回已连接的客户端的 IP 地址的变体。该过程返回一个元组，其第一个值是客户端的 IP 地址，第二个值是客户端套接字。上面的列表使用元组解包，它允许将这两个值立即分配给两个不同的变量。acceptacceptAddr

当客户端成功连接时，下一行将向终端写入一条消息，其中包括刚刚连接的客户端的 IP 地址。执行此操作后，将创建对象的新实例，每个字段使用构造函数逐个分配一个新值。最后，新实例将添加到服务器的序列中。Clientclients

重新编译此代码并重复上述步骤应生成一个结果，显示“接受来自 127.0.0.1 的连接”。但是发送消息当然还行不通。

**处理客户端的消息**

使用 telnet 建立连接后，服务器将不会收到在提示中键入的任何消息。这是因为仍未从已连接的客户端读取消息。现在让我们在服务器中实现代码来执行此操作。

```nim
proc processMessages(server: Server, client: Client) {.async.} =
  while true:
    let line = await client.socket.recvLine()   ❶
    if line.len == 0:         ❷
      echo(client, " disconnected!")
      client.connected = false
      client.socket.close()   ❸
      return   ❹

    echo(client, " sent: ", line)
```

>❶	等待从客户端读取一行。
❷	大多数从套接字读取数据的过程可能会返回空字符串，这表示套接字已与服务器断开连接。
❸	关闭客户端的套接字，因为它已断开连接。
❹	停止对消息的任何进一步处理。

确保将过程放在程序之上。稍后，您将需要在过程中调用此过程，为了使此过程正常工作，此过程必须位于调用站点上方。processMessagelooploop

您可能会发现看到由过程正文顶部的语句表示的另一个无限循环很奇怪。当然，一旦调用此过程，其执行将永远不会停止。这是有道理的，但请注意，这是一个异步过程，因此可以暂停。此过程永远不会停止执行，但在调用时会暂停执行。while trueawait client.socket.recvLine()

这意味着在此过程等待 的结果时，将执行其他代码段。结果将包含客户端发送的单个消息。保证单个消息，因为在上一节中创建的消息协议使用换行符作为分隔符。client.socket.recvLine()

有一种情况会阻止接收完整的消息：客户端与服务器断开连接。在这种情况下，返回一个空字符串，这就是下一行检查结果字符串的长度的原因。如果字符串为空，则终端上会显示一条消息，指出客户端已断开连接。客户端的标志设置为 false，并在套接字上调用该过程以释放其资源。recvLineconnectedclose

最后，假设客户端没有断开连接，客户端发送的消息将显示在终端中。

尝试再次重新编译代码。你会发现它没有编译，错误将类似于以下内容。
```
server.nim(16, 54) template/generic instantiation from here
server.nim(20, 12) Error: type mismatch: got (Client)
but expected one of:
system.$(x: int)
system.$(x: seq[T])
system.$(x: cstring)
system.$(x: bool)
...
```

这是因为尝试在终端中显示类型的行。问题是该过程尝试使用运算符来显示其所有参数。如果未为传递给 的类型定义运算符，则会收到类似于上述错误消息。解决方法是简单地定义它。echo(client, " disconnected!")Clientecho$$echo

的完整代码清单现在应如下所示。server.nim
```nim
import asyncdispatch, asyncnet

type
  Client = ref object
    socket: AsyncSocket
    netAddr: string
    id: int
    connected: bool

  Server = ref object
    socket: AsyncSocket
    clients: seq[Client]

proc newServer(): Server = Server(socket: newAsyncSocket(), clients: @[])

**proc `$`(client: Client): string =**
  **$client.id & "(" & client.netAddr & ")"**

proc processMessages(server: Server, client: Client) {.async.} =
  while true:
    let line = await client.socket.recvLine()
    if line.len == 0:
      echo(client, " disconnected!")
      client.connected = false
      client.socket.close()
      return

    echo(client, " sent: ", line)

proc loop(server: Server, port = 7687) {.async.} =
  server.socket.bindAddr(port.Port)
  server.socket.listen()

  while true:
    let (netAddr, clientSocket) = await server.socket.acceptAddr()
    echo("Accepted connection from ", netAddr)
    let client = Client(
      socket: clientSocket,
      netAddr: netAddr,
      id: server.clients.len,
      connected: true
    )
    server.clients.add(client)
    **asyncCheck processMessages(server, client)**

var server = newServer()
waitFor loop(server)
```

代码现在包括 for 类型的定义，以及在后台运行过程的命令。这些都以粗体显示。该命令可用于运行异步过程，而无需等待其结果。此代码将为连接到服务器的每个客户端调用该过程，这正是需要完成的操作。需要持续读取每个客户端，以确保处理它发送的任何消息。由于异步过程的性质，所有这些都将在后台完成，执行继续，从而准备好接受更多连接。$ClientasyncCheckprocessMessagesasyncCheckprocessMessagesloop

再次重新编译服务器模块，然后运行它并再次使用 连接到它。现在在远程登录窗口中输入一些文本，然后按回车键;您应该会看到服务器输出的消息，其中显示了您输入的文本。telnet

**将消息发送到其他客户端**

最后，您需要将从客户端接收的消息发送到当前连接到服务器的所有其他客户端。将以下内容添加到过程的底部;请确保缩进此代码，使其位于 while 循环中。processMessages
```nim
for c in server.clients:   ❶
  if c.id != client.id and c.connected:   ❷
    await c.socket.send(line & "\c\l")    ❸
```

>❶	循环遍历序列中的每个客户端。clients
❷	检查客户端是否不是发送此消息的客户端，并且客户端仍处于连接状态。
❸	将消息发送到客户端，后跟消息分隔符。\c\l

为完整起见，下面的代码清单显示了您的过程现在应该是什么样子。添加项以粗体显示。processMessages
```nim
proc processMessages(server: Server, client: Client) {.async.} =
  while true:
    let line = await client.socket.recvLine()
    if line.len == 0:
      echo(client, " disconnected!")
      client.connected = false
      client.socket.close()
      return

    echo(client, " sent: ", line)
    **for c in server.clients:**
      **if c.id != client.id and c.connected:**
        **await c.socket.send(line & "\c\l")**
```

这就是服务器的全部内容！它现在可以接收消息并将其发送到其他客户端。现在的问题是客户端仍然没有代码连接到服务器或向其发送消息。让我们解决这个问题。

**向客户端添加网络功能**

应该在客户端中实现的第一件事是它能够连接到服务器。在实现执行此操作的过程之前，必须导入 和 模块。除此之外，您还需要导入之前创建的模块。然后，您可以创建一个新的异步过程，如下所示。asyncdispatchasyncnetprotocolconnect
```nim
proc connect(socket: AsyncSocket, serverAddr: string) {.async.} =
  echo("Connecting to ", serverAddr)
  await socket.connect(serverAddr, 7687.Port)         ❶
  echo("Connected!")

  while true:
    let line = await socket.recvLine()   ❷
    let parsed = parseMessage(line)      ❸
    echo(parsed.username, " said ", parsed.message)   ❹
```

>❶	连接到默认端口上提供的服务器地址。7687
❷	不断尝试从服务器读取邮件。
❸	使用模块中定义的过程来解析收到的消息。parseMessageprotocol
❹	将邮件与邮件发件人的用户名一起显示。

应将此过程放在文件顶部的导入语句的正下方。它相当简单，它连接到服务器并开始等待来自它的消息。该过程用于一次读取一行。然后将此行传递给过程，该过程对其进行分析并返回一个对象，该对象允许访问消息的特定部分。然后，该消息将与信使的用户名一起显示。recvLineparseMessage

在调用该过程之前，必须先定义一个新变量。此变量应使用过程进行初始化。在读取命令行参数后定义它，因此在行之后定义它。下面的代码应该可以解决问题。connectsocketnewAsyncSocketserverAddrlet serverAddr = paramStr(1)var socket = newAsyncSocket()

然后，可以将 替换为对 的调用，使用该过程在后台运行它：。echo("Connecting to ", serverAddr)connectasyncCheckasyncCheck connect(socket, serverAddr)

现在是时候完成以非阻塞方式进行标准输入读取所需的更改了。目前，读取标准输入的 while 循环仍然阻塞。但是为了使异步过程正常工作，需要执行异步事件循环。如果线程被阻塞，则不会发生这种情况。因此，需要修改 while 循环，以将标准输入读数与事件循环集成在一起。下面的代码清单显示了如何做到这一点，你应该用它替换 while 循环。client.nimconnectclient.nim
```nim
var messageFlowVar = spawn stdin.readLine()   ❶
while true:
  if messageFlowVar.isReady():        ❷
    let message = createMessage("Anonymous", ^messageFlowVar)   ❸
    asyncCheck socket.send(message)   ❹
    messageFlowVar = spawn stdin.readLine()   ❺

  asyncdispatch.poll()   ❻
```

>❶	初始调用已移出 while 循环。readLine
❷	该过程确定是否从 将 块中读取值。isReadymessageFlowVar
❸	使用模块中定义的过程创建新消息。获取用户名留给读者作为练习。createMessageprotocol
❹	将消息发送到服务器，在这种情况下，请为您添加分隔符。createMessage
❺	再次在另一个线程中生成，因为最后一个线程已返回数据。readLine
❻	使用该过程手动调用事件循环。poll

已修改生成调用，以防止该过程在数百个线程中多次执行。如果将生成调用放在 while 语句内，则会发生这种情况，因为将不再同步读取。而不是这样做，一次只有一个在单独的线程中运行。while 循环使用过程来检查过程是否从标准输入流返回了新读取的值。如果是这样，则消息将发送到服务器，并再次生成该过程。参见图 3.22，其中显示了主线程和线程的执行。将其与您之前看到的图 3.21 进行比较。readLinereadLinemessageFlowVarreadLineisReadyreadLinereadLinereadLine

图 3.17.在引入之前的执行client.nimisReady

![ch03 input thread 2](../Images/ch03_input_thread_2.png)

图 3.18.当前执行client.nim

![ch03 input thread 3](../Images/ch03_input_thread_3.png)

等待标准输入不再阻塞主线程，并允许事件循环时间通过调用过程来检查事件。poll

为完整起见，下面是 的完整代码清单。本节中所做的更改以粗体显示。client.nim
```nim
import os, threadpool, **asyncdispatch, asyncnet**
**import protocol**

**proc connect(socket: AsyncSocket, serverAddr: string) {.async.} =**
  **echo("Connecting to ", serverAddr)**
  **await socket.connect(serverAddr, 7687.Port)**
  **echo("Connected!")**

  **while true:**
    **let line = await socket.recvLine()**
    **let parsed = parseMessage(line)**
    **echo(parsed.username, " said ", parsed.message)**

echo("Chat application started")
if paramCount() == 0:
  quit("Please specify the server address, e.g. ./client localhost")
let serverAddr = paramStr(1)
**var socket = newAsyncSocket()**
**asyncCheck connect(socket, serverAddr)**
**var messageFlowVar = spawn stdin.readLine()**
**while true:**
  **if messageFlowVar.isReady():**
    **let message = createMessage("Anonymous", ^messageFlowVar)**
    **asyncCheck socket.send(message)**
    **messageFlowVar = spawn stdin.readLine()**

  **asyncdispatch.poll()**
```

**最终结果**

仅此而已！您现在可以编译服务器和客户端，然后运行服务器和多个客户端。从一个客户端发送消息应该在服务器窗口中显示它，但也在连接到服务器的其他客户端中显示！

让我们回顾一下我最初的用例，向约翰和格蕾丝询问《权力的游戏》。讨论看起来像这样。

清单 3.21.我、约翰和格蕾丝关于《权力的游戏》的对话
```
*Dominik said* What did you guys think about the latest Game of Thrones
episode?
*Grace said* I thought Tyrion was really great in it!
*John said* I agree with Grace. Tyrion deserves an Emmy for his performance.
```

进行此讨论后，每个人的屏幕将显示相同的消息。除了他们自己的消息不会以他们的名字在哪里为前缀。<name> said<name>

为了真正看到它的实际效果，您需要亲自尝试一下。

在此交换后，服务器应显示以下信息。

图 3.19.服务器的输出

![ch03 final 4](../Images/ch03_final_4.png)

这应该是最终结果。如果你在途中迷路了，或者由于某种原因无法编译代码，或者代码无法正常工作，那么你可以从 https://github.com/dom96/nim-in-action-code 下载本书的所有代码示例。

现在，您甚至可以将客户端二进制文件发送给您的一位朋友，并让他们与您聊天。不过，您可能需要通过LAN或路由器上的转发端口执行此操作才能正常工作。

还有很大的改进空间。我故意将每个客户端的用户名设置为“匿名”，希望鼓励您为每个客户端进行配置，类似于更改服务器地址的方式。此功能存在于本章中显示的屏幕截图中。其他改进涉及更多，例如通过发送特殊的“PING”消息或添加将用户从服务器踢出的功能来确保客户端仍然连接。我相信有些东西，你，有创造力的读者，也会想出。

[13] Node fs.readFile 文档，https://nodejs.org/api/fs.html#fs_fs_readfile_filename_options_callback

[14] 创建单个程序将是一项相当微不足道的工作，我把创建这样一个过程的挑战留给您。readFile

[15] 大多数易于记忆的端口被其他应用程序使用，https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers


3.6 小结
--------

* 聊天应用程序的体系结构，包括客户端-服务器和对等模型以及常见的Internet协议（如TCP和UDP）之间的比较。
* 设置您的第一个Nim项目并对其进行编译，包括用于自定义编译过程的其他标志和可用于存放这些标志的Nim配置文件。
* 使用“paramStr”过程检索命令行参数。
* 使用“readLine”从标准输入流中读取行。
* 通过使用“派生”从另一个线程中的标准输入流读取数据，解决同步I/O的阻塞问题。
* 使用“JSON”模块解析和生成JSON。
* 使用“doAssert”编写简单的单元测试。
* 使用`asyncnet`异步网络模块和套接字通过网络传输数据。
* Nim的模块系统。