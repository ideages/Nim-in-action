
6 并发性
===========

本章包括：
* 并发性的重要性
* 并发与并行
* Nim语言的Thread 线程
* 使用正则表达式和其他方法对数据进行高级分析
* 并行分析大型数据集

每个计算机程序执行一个或多个计算。这些计算通常按顺序执行。也就是说，当前计算必须在下一个计算开始之前完成。例如，考虑一个简单的计算`（2+2）*4`，其中必须首先计算加法得到`4`，然后再进行乘法得到 `16`。在该示例中，依次执行计算*并发*允许多个计算进行，而无需等待所有其他计算完成。这种计算形式在许多情况下都很有用。一个示例是输入/输出应用程序，如您在*第3章*中开发的聊天应用程序。当按顺序执行时，此类应用程序将浪费时间等待输入或输出操作完成。并发性允许将此时间用于其他任务，从而大大减少应用程序的执行时间。


Nim提供了许多内置的并发功能。其中包括`Futures`和`await`形式的异步I/O功能，以及用于创建新线程的`spawn`等。您已经看到了 *第3章* 中使用的一些。

Nim中的并发性仍在不断发展，这意味着本章中描述的功能可能会发生变化或被新的更健壮的功能所取代。但是Nim中并发的核心概念应该保持不变，本章将学习的内容也适用于其他编程语言。

除了向您展示Nim的并发特性之外，本章还将带领您完成一个简单解析器的实现，它将向您展示创建解析器的不同方法。然后，本章将通过优化解析器来结束，以便它是并发的，并且可以在多个CPU内核上并行运行。

6.1并发与并行
================================
如今，几乎所有操作系统都支持“多任务处理”，即在一定时间内执行多个任务的能力。任务通常称为“进程”，它是正在执行的计算机程序的实例。每个CPU一次只执行一个进程。多任务允许操作系统改变当前在CPU上执行的进程，而不必等待进程完成其执行*图6.1*显示了如何在多任务操作系统上同时执行两个进程。

图6.1.两个过程的并发执行
![alt ](../Images/ch06_process_execution.png)


由于CPU速度极快，进程A可以执行1纳秒，然后进程B可以执行2纳秒，然后过程A可以执行另一纳秒。这给人一种“同时”执行多个进程的印象。但这不可能发生，因为CPU一次只能执行一条指令。这种同时执行多个进程的明显现象称为并发。

近年来，多核CPU变得流行起来。这些类型的CPU由两个或多个独立的单元组成，它们可以同时运行多个指令。这允许多任务操作系统同时并行运行两个或多个进程*图6.2*显示了如何在双核CPU上并行执行两个进程。


Figure 6.2. 并行执行两个进程

![ch06 process execution parallel](../Images/ch06_process_execution_parallel.png)


与单核CPU相反，双核CPU实际上可以同时执行两个进程。这种类型的执行被称为并行，它只能在多个物理CPU上实现。请记住，尽管并发和并行之间有明显的相似之处，但两者并不相同。

除了进程之外，操作系统还管理*线程Thread*的执行。线程是进程的一个组件，同一进程中可以存在多个线程。它可以像进程一样并发或并行执行，尽管与进程不同，线程之间共享内存等资源。

为了充分利用多核CPU的能力，CPU密集型计算必须并行化。这可以通过使用多个进程来实现，尽管线程更适合于需要共享大量数据的计算。

您在*第3章*中看到的异步等待是严格并发的。因为异步代码总是在单个线程上运行，所以它不是并行的。这意味着它目前无法使用多核CPU的全部功能。

>便条：并行异步等待
Nim的未来版本很可能包括并行异步等待。

与异步等待不同，`spawn`是并行的，专门为CPU密集型计算而设计，可以从在多核CPU上执行中受益。

>便条 其他编程语言中的并行性
一些编程语言（如Python和Ruby）不支持线程级并行，因为它们的解释器中存在全局解释器锁。这防止了使用线程的应用程序使用多核CPU的全部功能。有一些方法可以克服这种限制，但它们需要使用不像线程那样灵活的进程

6.2在Nim中使用线程
=========================

既然您已经了解了并发和并行之间的区别，那么就可以学习如何在Nim中使用线程了。


在Nim中，有两个模块用于处理线程。 `threads` 模块[[19]]（#ftn.d5e6428）公开了手动创建线程的能力，使用此方法创建的线程立即执行指定的过程，并在该过程的运行时间内运行。还有实现*线程池*的  `threadpool` 模块[[20]]（#ftn.d5e6432），它公开了将指定过程添加到线程池的*任务队列*的 `spawn`。 `spawn`过程的行为并不意味着它将立即在单独的线程中运行。线程的创建完全由线程池管理。

接下来的部分将向您介绍两个不同的线程模块，因此不要对上一段中介绍的新术语感到不知所措。


6.2.1  `threads`线程模块和GC安全
-----------------------------------------

在本节中，我将查看`threads` 模块。但在开始之前，我必须解释Nim中线程的工作方式，特别是您将了解Nim中的**垃圾收集器安全性**。Nim和大多数其他编程语言中线程的工作方式有一个非常重要的区别。Nim的每个线程都有自己的独立内存堆。线程之间的内存共享受到限制，这有助于防止竞争条件并提高效率。

由于每个线程都有自己的垃圾收集器，因此效率得到了提高。在共享内存的线程中，执行其他业务代码时， 需要在垃圾收集器暂停所有线程。这可能会给应用程序添加有问题的暂停。

让我向您展示这个线程模型在实践中是如何工作的*清单6.1*显示了一个未编译的代码示例。

清单6.1.使用`Thread`更改全局变量。

```Nim
var data = "Hello World"               ❶

proc showData() {.thread.} =           ❷
  echo(data)                           ❸

var thread: Thread[void]               ❹
createThread[void](thread, showData)   ❺
joinThread(thread)                     ❻
```

[❶](#CO1-1) 定义一个新的全局变量 `data` 并赋值文本为 `"Hello World"`
[❷](#CO1-2) 定义一个新的函数，将在新线程中执行. 用`{.thread.}` 编译指示标识。 |
[❸](#CO1-3) 尝试显示 `data` 变量的值。
[❹](#CO1-4) 定义一个变量来存储新线程，泛型参数表示线程过程采用的参数类型。在这种情况下，`void` 表示过程不接受参数|
[❺](#CO1-5)  `createThread` 函数在新线程中执行指定的函数。
[❻](#CO1-6)  等待 `thread` 线程结束。

