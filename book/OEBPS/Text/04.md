

4
=


A tour through the standard library
===================================


This chapter covers:



* What is the standard library?
* A more in-depth look at modules
* The modules in Nim’s standard library
* Examples of how to use the modules in Nim’s standard library



Every programming language supports the notion of a *library*. A library is a collection of pre-written software which implements a list of behaviours. These behaviours can be accessed by other libraries or applications via a library-defined interface.


For example, a music playback library such as `libogg` might define `play` and `stop` procedures, the former of which will start playing music and the latter stop playing music. The `libogg` libraries' interface can be said to consist of those two procedures.


A library such as the one above can be reused by multiple applications, this means that the behaviours which the library implements do not have to be reimplemented for each application.


A *standard* library is a library which is always available as part of a programming language, because of this you will find that a standard library typically includes definitions of common algorithms, data structures, and mechanisms for interacting with the operating system.


The design of a standard library differs between languages, Python’s standard library rather famously follows the "batteries included" philosophy which embraces an inclusive design. C's standard library on the other hand takes a more conservative approach. As such, in Python you will for example find packages which allow you to process XML, send email messages and make use of the SQLite library. Whereas in C you will not.


The Nim standard library follows a similar "batteries included" principle. It is similar to Python in that regard, because it also contains packages for processing XML, sending email messages and making use of the SQLite library. This is of course not the extent of Nim’s standard library, it is a very rich library containing a wide range of modules. This chapter is dedicated to it and will show you some of its most useful parts.


In addition to describing what each part of the standard library does, I will also show examples of how each module in the standard library can be used. Let’s begin by looking at what a module is in more detail and how modules can be imported.


*Figure 4.1* and *Figure 4.2* show some of the most useful modules in Nim’s standard library.




Figure 4.1. The most useful pure modules


![ch04 overview pure](../Images/ch04_overview_pure.png)



Figure 4.2. The most useful impure modules


![ch04 overview impure](../Images/ch04_overview_impure.png)



4.1  Another look at modules
============================



The Nim standard library is made up of modules. A *module* in Nim is a file containing Nim code, and code inside of a module is isolated from all other code. The isolation restricts which types, procedures, variables and other definitions are accessible to code defined in a different module.


When a new definition is made inside a module it is not visible to any other modules by default. It is *private*. A definition can be made *public*, which means that it is visible to other modules, using the `*` character.




Listing 4.1. Module `example.nim`




```
var moduleVersion* = "0.12.0"
var randomNumber* = 42
```



The `example.nim` module defined above contains code which defines a `moduleVersion` variable. This variable is made *public* by the `*` character.


You might remember the `*` character from the previous chapter, where I introduced the `*` access modifier and used it to export identifiers in the `protocol` module. What I would like to expand on here are the different ways that modules can be imported. You should remember the basic `import` keyword, this keyword can be used to import the `example.nim` module defined above like so.




Listing 4.2. Module `main.nim`




```
import example   ❶
echo(moduleVersion)   ❷
```




|  |  |
| --- | --- |
| [❶](#CO1-1) | The `.nim` extension is not necessary |
| [❷](#CO1-2) | After importing the `example` module, we can access the `moduleVersion` variable because it is public. |





The `import` keyword does something very straightforward, it imports all the public definitions from a specified module. But what might not be immediately obvious is how it finds the specified module.


The Nim compiler has a configurable list of directories that it searches for modules. This list is configured in a special configuration file normally named `nim.cfg`. The compiler may use multiple configuration files, but there is one defined by the compiler that is always used. It usually resides in `$nimDir/config`, where `$nimDir` is the path to the Nim compiler. *Listing 4.3* shows what a small part of the default Nim configuration looks like. In *Listing 4.3*, each line specifies a directory which the Nim compiler will look at when searching for modules.




Listing 4.3. Some of the directories in Nim’s configuration file




```
path="$lib/pure"   ❶
path="$lib/impure"
path="$lib/arch"
path="$lib/core"
...   ❷
```




|  |  |
| --- | --- |
| [❶](#CO2-1) | The `$lib` is expanded by the Nim compiler to a full path, which leads to the location where Nim’s standard library has been installed. |
| [❷](#CO2-2) | The configuration file contains many more options, you may wish to take a look at it to see what bits of the compiler can be configured. |





 





> Tip Project config files |
| You can create a configuration file that is specific to your project. You can then use it to customize the behaviour of the compiler when compiling your project. Simply create a `main.nim.cfg` file, where `main` is the name of the file you are compiling. The config file must be placed beside your Nim source code file. You can then place any flags you would pass on the command-line verbatim in that file, for example `--threads:on`. |



When a module is imported using the `import` statement. The Nim compiler searches each of those directories in order. When those directories do not contain the specified module, then the compiler will search for files alongside the module currently being compiled. Because of this, in order for the code in *Listing 4.2* to compile, the `example.nim` module in *Listing 4.1* should be placed alongside the `main.nim` module in *Listing 4.2*. *Figure 4.3* shows how the compiler searches for the `example` module when compiling `main.nim`.




Figure 4.3. How the compiler searches for modules


![ch04 import search](../Images/ch04_import_search.png)

Each imported module, including the modules imported from the standard library, are compiled together with the main module. When compiling `main.nim`, the local `example` module and the standard library `system` module would be compiled before `main.nim` can be successfully compiled.


Modules can also be placed in subdirectories. For example, consider the directory structure shown in *Figure 4.4*.




Figure 4.4. The `example.nim` file was moved into the `misc` directory.


![ch04 import subdirectory](../Images/ch04_import_subdirectory.png)

The `example` module was moved into the `misc` directory. Because of this, the `main` module needs to be modified as shown in *Listing 4.4*.




Listing 4.4. Importing from a subdirectory




```
import misc/example
echo(moduleVersion)
```



The `misc` directory has simply been added to the `import` statement.




4.1.1  Namespacing
------------------



Namespaces are a common occurrence in many programming languages. They act as a context for identifiers, allowing the same identifier to be used from two different contexts. Language support for namespaces varies widely. C does not support them, C++ contains an explicit keyword for defining them and Python uses the module name as the namespace.


To get a better idea of what namespacing is used for, let’s look at an example use case. Assume that you wish to load images of two separate formats: PNG and BMP. Also assume that there are two libraries for reading such files available, one called `libpng` and the other called `libbmp`. It just so happens that both libraries define a `load` procedure which loads the image for you. If you want to use both libraries at the same time, how do you distinguish the two `load` procedures?


If those libraries are written in C then they would need to emulate namespaces. They would do this by prefixing the procedure names with the name of the library, so the procedures would be named `png_load` and `bmp_load` to avoid conflicts. C++ versions of those libraries might define namespaces such as `png` and `bmp`, the `load` procedures could then be invoked via `png::load` and `bmp::load` respectively. Python versions of those libraries don’t need to explicitly define a namespace, the module name is the namespace. In Python, if the PNG library defines its `load` procedure in a `png` module and the BMP library defines it in a `bmp` module, then the `load` procedures can be invoked via `png.load` and `bmp.load` respectively.


Just like in Python, namespaces in Nim are defined by individual modules. But there is one big difference, by default when a module is imported, all of its public definitions are placed in the namespace of the importing module. You can still specify the fully qualified name, but doing so is not required.




```
import example
echo(example.moduleVersion)   ❶
```




|  |  |
| --- | --- |
| [❶](#CO3-1) | Specify the module namespace explicitly by writing down the module name followed by a dot character. |




The module namespace only needs to be specified when the same definition has been imported from two different modules. Let’s say a new module called `example2.nim` was imported, `example2.nim` also defines a public `moduleVersion` variable. In that case, the code will need to explicitly specify the module name.




Listing 4.5. Module `example2.nim`




```
var moduleVersion* = "10.23"
```





Listing 4.6. Disambiguating identifiers




```
import example, example2   ❶
echo("Example's version: ", example.moduleVersion)
echo("Example 2's version: ", example2.moduleVersion)
```




|  |  |
| --- | --- |
| [❶](#CO4-1) | An `import` statement can import multiple modules, you just need to separate them by a comma. |





Compiling and running the code in *Listing 4.6* will result in the following output.




```
Example's version: 0.12.0
Example 2's version: 10.23
```


But if you attempt to display the value of `moduleVersion` without qualifying it:




```
import example, example2
echo(moduleVersion)
```


Then you will receive an error:




```
main.nim(2,6) Error: ambiguous identifier: 'moduleVersion' -- use a qualifier
```


You can prevent all the definitions from being imported into the importing module’s namespace by using a special `import` syntax.




Listing 4.7. Importing modules into their own namespace




```
from example import nil       ❶
echo(moduleVersion)           ❷
echo(example.moduleVersion)   ❸
```




|  |  |
| --- | --- |
| [❶](#CO5-1) | Import the `example` module without importing any of its definitions into this file’s namespace. |
| [❷](#CO5-2) | This will no longer work because `moduleVersion` is no longer in this file’s namespace. |
| [❸](#CO5-3) | The `moduleVersion` variable can be accessed by explicitly writing the module namespace. |





When using the `from` statement, the specific definitions that you want imported can be listed after the `import` keyword.




Listing 4.8. Importing only some of the definitions from a module




```
from example import moduleVersion   ❶
echo(moduleVersion)                 ❷
echo(example.randomNumber)          ❸
```




|  |  |
| --- | --- |
| [❶](#CO6-1) | This imports `moduleVersion` into this file’s namespace, all other public definitions need to be accessed via the `example` namespace. |
| [❷](#CO6-2) | The `moduleVersion` variable can again be accessed without explicitly writing the module namespace. |
| [❸](#CO6-3) | The `randomNumber` variable must be qualified. |





Certain definitions can be excluded using the `except` keyword.




Listing 4.9. Excluding some definitions when importing




```
import example except moduleVersion
echo(example.moduleVersion)   ❶
echo(moduleVersion)           ❷
echo(randomNumber)            ❸
```




|  |  |
| --- | --- |
| [❶](#CO7-1) | Accessing the `moduleVersion` variable via the module’s namespace still works. |
| [❷](#CO7-2) | Accessing the `moduleVersion` variable without qualifying the name does not work. |
| [❸](#CO7-3) | But accessing the `randomNumber` variable does. |





In Nim it is idiomatic to import all modules so that all identifiers end up in the importing module’s namespace and to only explicitly specify the namespace when the name is ambiguous. This is contrary to Python, which requires every identifier that is imported to be accessed via the module’s namespace. Unless the module is imported using the `from x import *` syntax.


The reason for this is because of Nim’s flexible Uniform Function Call Syntax and operator overloading. This also has the benefit that you do not need to constantly retype the module names.


You might not recall what UFCS is from *Chapter 1*. It’s rather simple, it allows any procedure to be called on an object as if the function were a method of the object’s class. Take a look at *Listing 4.10* to see what UFCS looks like.




Listing 4.10. Uniform Function Call Syntax




```
proc welcome(name: string) = echo("Hello ", name)

welcome("Malcolm")    ❶
"Malcolm".welcome()   ❶
```




|  |  |
| --- | --- |
| [❶](#CO8-1) | Both syntaxes are valid and perform the same action. |





That should give you a better idea about Nim’s module system. Let’s now look at Nim’s standard library in greater detail.







4.2  Overview of the standard library
=====================================



Nim’s standard library is split up into 3 major categories: pure, impure and wrappers.


This chapter will explore a select number of modules from a couple of these categories. The impure modules will also be explored at the end.




4.2.1  Pure modules
-------------------



A large proportion of Nim’s standard library is composed of pure modules. These modules are written completely in Nim and require no dependencies, they are preferred because of this. The pure modules themselves are further split up into multiple categories themselves.


Some of these categories include:



* The Core
* Collections and algorithms
* String handling
* Generic operating system services
* Math libraries
* Internet protocols
* Parsers






4.2.2  Impure modules
---------------------



Impure modules on the other hand consist of Nim code which uses external C libraries. For example, the `re` module implements procedures and types for handling regular expressions. It is an impure library because it depends on PCRE which is an external C library. This means that if your application imports the `re` module, it will not work unless the user installs the PCRE library on their system.




Shared libraries



Impure modules such as `re` utilize what is known as a shared library, typically a C library that has been compiled into a shared library file. On Windows these files use the `.dll` extension, on Linux the `.so` extension and on Mac OS X the `.dylib` extension. [[16]](#ftn.d5e4477)


When you import an impure module, your application will need to be able to find these shared libraries. They will need to be installed via your operating system’s package manager or bundled with your application. On Linux it is common to use a package manager, on Mac OS X both are fairly common, and on Windows bundling the dependencies with your application is the most popular.






4.2.3  Wrappers
---------------



Wrappers are the modules which allow these external C libraries to be used. They provide an interface to these libraries that in most cases matches the C interface exactly. Impure modules build on top of wrappers to provide a more idiomatic interface. You can use wrappers directly but doing so will not be easy, this is because you will need to use some of Nim’s unsafe features such as pointers and bit casts. Using wrappers directly can lead to errors because in most cases you will need to manage memory manually. Impure modules define abstractions to provide a memory safe interface which you can easily use in your source code without worrying about the low-level details of C.





4.2.4  Online Documentation
---------------------------



Before I start talking about the different modules in detail, I would like to mention that the Nim website contains documentation for the full standard library. A list of all the modules in the standard library can be viewed using the following URL: <http://nim-lang.org/docs/lib.html>. This URL always shows the documentation for the latest release of Nim, it also contains links to documentation for each module.


The documentation for each module contains links alongside each definition which point to the implementation of that definition. It can for example point to the line of code where a procedure is implemented, showing you exactly how it functions. Every part of Nim is open source, this includes its standard library. The ability to look at the source of the standard library allows you to see Nim code written by the Nim developers themselves, it also allows you to truly understand the behaviour of each part of the standard library and means that you can even modify it to your liking.




Figure 4.5. The documentation for the `os` module


![ch04 os module](../Images/ch04_os_module.png)

In addition to this, the list of modules given in the link above also includes community created modules. At the bottom of the page there is a list of Nimble packages. Nimble is a Nim package manager which makes the installation of these packages easy, you will learn more about it in the next chapter.


The list of Nimble packages is split into an official and unofficial list, the official packages are ones which are officially supported by the core Nim developers and as such they are much more stable than some of the unofficial packages. The official packages actually include modules which used to be part of the standard library but which have been transferred out in order to make the standard library a bit more lean.


Now let’s move onto looking at the pure modules in a little bit more detail. We will start with the core modules.




  


[[16]](#d5e4477) <https://en.wikipedia.org/wiki/Dynamic_linker#Implementations>







4.3  The core modules
=====================



The most important module in the core of the standard library is the `system` module. This module is the only module which is implicitly imported so you do not need to include `import system` at the top of each of your own modules. The reason that this module is imported automatically for you is that it contains commonly used definitions.


The `system` module includes definitions for all the primitive types, for example `int` and `string` are defined here. Common procedures and operators are also defined in this module. *Table 4.1* shows some examples of these.




Table 4.1. Some examples of definitions in the `system` module









| Definitions | Purpose | Examples |
| `+`, `-`, `*`, `/` | Addition, subtraction, multiplication, division on two numbers respectively. | `doAssert(5 + 5 == 10)` `doAssert(5 / 2 == 2.5)` |
| `==`, `!=`, `>`, `<`, `>=`, `<=` | General comparison operators. | `doAssert(5 == 5)` `doAssert(5 > 2)` |
| `and`, `not`, `or` | Bitwise and boolean operations. | `doAssert(true and true)` `doAssert(not false)` `doAssert(true or false)` |
| `add` | Adds a value to a string or sequence. | `var text = "hi"` `text.add('!')` `doAssert(text == "hi!")` |
| `len` | Returns the length of a string or sequence. | `doAssert("hi".len == 2)` |
| `shl`, `shr` | Bitwise shift left and shift right. | `doAssert(0b0001 shl 1 == 0b0010)` |
| `&` | Concatenation operator, joins two strings into one. | `doAssert("Hi" & "!" == "Hi!")` |
| `quit` | Terminates the application with a specified error code. | `quit(QuitFailure)` |
| `$` | Converts the specified value into a string. This is defined in the `system` module for some common types. | `doAssert($5 == "5")` |
| `repr` | Takes any value and returns its string representation. This differs from `$` because it works on any type, a custom `repr` does not need to be defined. | `doAssert(5.repr == "5")` |
| `substr` | Returns a slice of the specified string. | `doAssert("Hello".substr(0, 1) == "He")` |
| `echo` | Displays the specified values in the terminal. | `echo(2, 3.14, true, "a string")` |
| `items` | An iterator which loops through the items of a sequence or string. | `for i in items([1, 2]): echo(i)` |
| `doAssert`, `assert` [[a]](#ftn.d5e4665) | Raises an exception if the value specified is `false`. | `doAssert(true)` |
| 
[[a]](#d5e4665) The difference between `doAssert` and `assert` is that `assert` calls are removed when compiling with `-d:release` whereas `doAssert` calls are always present.
 |




In addition to the definitions listed above, the `system` module also contains types which map directly to C types, remember that Nim compiles to C by default and that these types are necessary to interface with C libraries. Interfacing with C is an advanced topic and I will go into more detail about it in *Chapter 8*.


The system module also includes the `threads` and `channels` modules, the definitions made in these modules are included in the `system` module as long as the `--threads:on` flag is specified when compiling. Threads in Nim are off by default and must be switched on explicitly. These modules implement threads which are a useful abstraction for concurrent execution. Concurrency will be touched on in more detail in *Chapter 6*.


Other modules in the core category include `threadpool` and `locks`, both of which implement different threading abstractions, `macros` which implements an API for metaprogramming, and a few other modules.


The main module in the core you should be interested in is the `system` module. The others are not as important and you will be using them only for specialised tasks like concurrency.


This section should have given you an idea of what some of the core modules implement, in particular the procedures and types defined in the implicitly imported `system` module. Now let’s look at the modules which implement data structures and common algorithms, and how they can be used.





4.4  Data structures and algorithms
===================================



A large proportion of data structures are defined in the `system` module, including ones which you have already been introduced to in *Chapter 2*: `seq`, `array`, and `set`.


Other data structures are implemented as separate modules in the standard library, these modules are listed under the "Collections and algorithms" category in the standard library documentation. They include the `tables`, `sets`, `lists`, `queues`, `intsets`, and `critbits` modules.


Many of those modules have niche use cases and as such I won’t go into much detail about them. The modules which I will talk about are the `tables` and `sets` modules. I will also look at some modules which implement different algorithms which deal with these data structures.




4.4.1  The `tables` module
--------------------------



Assume that you are writing an application which stores the average life expectancy of different kinds of animals. After adding all the data you may wish to look up the average life expectancy of a specific animal. The data can be stored in many different data structures.


One data structure that can be used to store the data is a sequence. Let me first give you a bit of a recap about the sequence type. The sequence type `seq[T]` defines a list of elements of type `T`. It can be used to store a dynamic list of elements of any type, dynamic refers to the fact that a sequence can grow to hold more items at runtime. *Listing 4.11* shows one way that the data describing the average life expectancy of different animals can be stored.




Listing 4.11. Defining a list of integers and strings.




```
var numbers = @[3, 8, 1, 10]   ❶
numbers.add(12)   ❷
var animals = @["Dog", "Racoon", "Sloth", "Cat"]   ❸
animals.add("Red Panda")       ❹
```




|  |  |
| --- | --- |
| [❶](#CO9-1) | Define a new variable of type `seq[int]` which holds some numbers. |
| [❷](#CO9-2) | Add the number `12` to the sequence `numbers`. |
| [❸](#CO9-3) | Define a new variable of type `seq[string]` which holds some animals. |
| [❹](#CO9-4) | Add the animal `"Red Panda"` to the sequence `animals`. |





In *Listing 4.11* the `numbers` variable holds each of the `animals`' ages. The animal’s names are then stored in the `animals` sequence. Each age stored in the `numbers` sequence has the same position as the animal it corresponds to in `animals`, but that’s not intuitive and has many issues. For example, it is possible to add an animal’s average age expectancy into `numbers`, without adding the corresponding animal’s name into `animals`, and vice versa. A better way is to use a data structure called a hash table.


A hash table is a data structure which maps keys to values. It stores a collection of (key, value) pairs, and the key appears only once in the collection. You can add, remove and modify these pairs as well as look up values based on a key. Hash tables typically support keys of any type. They are more efficient than any other lookup structure which makes their use popular. *Figure 4.6* shows how data about animals can be retrieved from a hash table by performing a lookup based on a key.




Figure 4.6. Looking up the value of the key `"Dog"` in the `animalsAges` hash table


![ch04 hash table](../Images/ch04_hash_table.png)

The `tables` module implements a hash table, allowing you to write the following.




Listing 4.12. Creating a hash table




```
import tables   ❶
var animalAges = toTable[string, int](  ❷
  {             ❸
    "Dog": 3,
    "Racoon": 8,
    "Sloth": 1,
    "Cat": 10
  })

animalAges["Red Panda"] = 12   ❹
```




|  |  |
| --- | --- |
| [❶](#CO10-1) | Remember that the hash tables are in the `tables` module, so it needs to be imported. |
| [❷](#CO10-2) | Create a new `Table[string, int]` out of the mapping defined above, the key and value types need to be specified as the compiler cannot reliably infer it in all cases. |
| [❸](#CO10-3) | Use the `{:}` syntax to define a mapping from `string` to `int`. |
| [❹](#CO10-4) | Add a fairly old Red Panda to the `animalAges` hash table. |





There are multiple different types of hash table defined in the `tables` module. The generic version defined as `Table[A, B]`, the `OrderedTable[A, B]` which remembers the insertion order, and the `CountTable[A]` which simply counts the number of each key. The ordered and count tables are used much less often than the generic table because their use cases are far more specific.


The `Table[A, B]` type is a generic type, in its definition the `A` refers to the type of the hash table’s key and the `B` refers to the type of the hash table’s value. There are no restrictions on the type of the key or the value. That is, as long as there is a definition of a `hash` procedure for the type specified as the key. You won’t run into this limitation until you attempt to use a custom type as a key, because a `hash` procedure is defined for most types in the standard library.




Listing 4.13. Using a custom type as a key in a hash table




```
import tables
type             ❶
  Dog = object   ❷
    name: string

var dogOwners = initTable[Dog, string]()   ❸
dogOwners[Dog(name: "Charlie")] = "John"   ❹
```




|  |  |
| --- | --- |
| [❶](#CO11-1) | The `type` keyword begins a section of code where types can be defined. |
| [❷](#CO11-2) | Defines a new `Dog` object with a `name` field of type `string`. |
| [❸](#CO11-3) | The `initTable` procedure can be used to initialise a new empty hash table. |
| [❹](#CO11-4) | Create a new instance of the `Dog` object and use that as the key, set the value of that key in the `dogOwners` hash table to `"John"`. |





Compiling *Listing 4.13* will result in the following output.




```
file.nim(7, 10) template/generic instantiation from here   ❶
lib/pure/collections/tableimpl.nim(92, 21) template/generic instantiation from here   ❷
lib/pure/collections/tableimpl.nim(43, 12) Error: type mismatch: got (Dog)            ❷
but expected one of:   ❸
hashes.hash(x: T)
hashes.hash(x: pointer)
hashes.hash(x: T)
hashes.hash(x: float)
hashes.hash(x: set[A])
hashes.hash(x: T)
hashes.hash(x: string)
hashes.hash(x: int)
hashes.hash(aBuf: openarray[A], sPos: int, ePos: int)
hashes.hash(x: int64)
hashes.hash(x: char)
hashes.hash(sBuf: string, sPos: int, ePos: int)
hashes.hash(x: openarray[A])
```




|  |  |
| --- | --- |
| [❶](#CO12-1) | This refers to `dogOwners[Dog(name: "Charlie")] = "John"`, where we are trying to use the `Dog` as the key. |
| [❷](#CO12-2) | These errors are inside the standard library because that is where the call to `hash(key)` is made. |
| [❸](#CO12-4) | The list below shows all the available definitions of the `hash` procedure. As you can see, there is no definition for the `Dog` type present in that list. |




The compiler rejects the code, with the excuse that it cannot find the definition of a `hash` procedure for the `Dog` type. Thankfully it’s easy to define a `hash` procedure for custom types.




Listing 4.14. Defining a `hash` procedure for custom types.




```
import tables, **hashes**       ❶
type
  Dog = object
    name: string

**proc hash(x: Dog): Hash =**   ❷
  **result = x.name.hash**      ❸
  **result = !$result**    ❹

var dogOwners = initTable[Dog, string]()
dogOwners[Dog(name: "Charlie")] = "John"
```




|  |  |
| --- | --- |
| [❶](#CO13-1) | Import the `hashes` module which defines procedures for computing hashes. |
| [❷](#CO13-2) | Define a `hash` procedure for the `Dog` type. |
| [❸](#CO13-3) | Use the `Dog`'s `name` field to compute a hash. |
| [❹](#CO13-4) | Use the `!$` operator to finalise the computed hash. |





The code in *Listing 4.14* shows the additions which make the example compile in bold. The `hashes` module is necessary to aid in computing a hash in the `hash` procedure. It defines the `Hash` type, the `hash` procedure for many common types including `string`, and the `$!` operator. The `$!` operator finalises the computed hash, something that is necessary when writing a custom `hash` procedure. The use of the `$!` operator ensures that the computed hash is unique.





4.4.2  The `sets` module
------------------------



Now let’s have a quick look at another data structure called the set. The basic `set` type as introduced in *Chapter 2* is defined in the `system` module. This `set` type has a limitation, its basetype is limited to an ordinal type of a certain size, specifically one of the following:



* `int8`, `int16`
* `uint8`/`byte`, `uint16`
* `char`
* `enum`



Attempting to define a `set` with any other base type, for example `set[int64]`, will result in an error.


The `sets` module defines a `HashSet[A]` type which does not have this limitation. Just like the `Table[A,B]` type, the `HashSet[A]` type requires a `hash` procedure for the type `A` to be defined. *Listing 4.15* shown below creates a new `HashSet[string]` variable.




Listing 4.15. Modelling an access list using a `HashSet`.




```
import sets   ❶
var accessSet = toSet(["Jack", "Hurley", "Desmond"])   ❷
if "John" notin accessSet:   ❸
  echo("Access Denied")
else:         ❹
  echo("Access Granted")
```




|  |  |
| --- | --- |
| [❶](#CO14-1) | Import the `sets` module where the `toSet` procedure is defined. |
| [❷](#CO14-2) | Define a new a `HashSet[string]` with a list of names. |
| [❸](#CO14-3) | Check if John is in the access set and if he is not, display the "Access Denied" message. |
| [❹](#CO14-4) | If John is in the access set then display the "Access Granted" message. |





Determining whether an element is within a set is much more efficient than within a sequence or array, because each element of a set does not need to be checked. This makes a very big difference when the list of elements grows.


In addition to the `HashSet[A]` type, the `sets` modules also defines an `OrderedSet[A]` type which remembers the insertion order.





4.4.3  The algorithms
---------------------



Nim’s standard library also includes an `algorithm` module that defines a selection of algorithms which work on some of the data structures mentioned so far, in particular sequences and arrays.


There are a number of algorithms in the `algorithm` module. The most useful is a sorting algorithm defined in the `sort` procedure. The procedure takes either an array or a sequence of values and sorts them according to a specified compare procedure. Let’s jump straight to an example, which sorts a list of names so you can display it to the user in alphabetical order, or make the process of searching the list much easier.




Listing 4.16. Sorting using the `algorithm` module




```
import algorithm   ❶
var numbers = @[3, 8, 67, 23, 1, 2]   ❷
numbers.sort(system.cmp[int])         ❸
doAssert(numbers == @[1, 2, 3, 8, 23, 67])   ❹

var names = ["Dexter", "Anghel", "Rita", "Debra"]   ❺
let sorted = names.sorted(system.cmp[string])       ❻
doAssert(sorted == @["Anghel", "Debra", "Dexter", "Rita"])   ❼
doAssert(names == ["Dexter", "Anghel", "Rita", "Debra"])     ❽
```




|  |  |
| --- | --- |
| [❶](#CO15-1) | Import the `algorithm` module which defines the `sort` and `sorted` procedures. |
| [❷](#CO15-2) | Define a new `numbers` variable of type `seq[int]` with some values. |
| [❸](#CO15-3) | Sort the `numbers` sequence in-place. Use a standard `cmp` procedure for integers defined in `system` when sorting. |
| [❹](#CO15-4) | The `numbers` sequence now contains the elements in ascending order. |
| [❺](#CO15-5) | Define a new `names` variable of type `array[4, string]` with some values. |
| [❻](#CO15-6) | Return a copy of the `names` array as a sequence with the elements sorted. Use the standard `cmp` procedure for strings defined in `system` when sorting. |
| [❼](#CO15-7) | The `sorted` sequence contains the elements in ascending alphabetical order. |
| [❽](#CO15-8) | The `names` array has not been modified. |





The code in *Listing 4.16* shows two different ways that both sequences and arrays can be sorted. Using the `sort` procedure, which sorts the list in-place. And alternatively, using the `sorted` procedure which returns a copy of the original list with the elements sorted. The former is more efficient because a copy of the original list does not have to be made.


Consider the `system.cmp[int]` procedure used in the `sort` call. Notice the lack of `()`, without it the procedure is not called but is instead passed as a value to the `sort` procedure. The definition of the `system.cmp` procedure is actually pretty simple.




Listing 4.17. The definition of the generic `cmp` procedure




```
proc cmp*[T](x, y: T): int =   ❶
  if x == y: return 0
  if x < y: return -1
  else: return 1

doAssert(cmp(6, 5) == 1)       ❷
doAssert(cmp(5, 5) == 0)       ❸
doAssert(cmp(5, 6) == -1)      ❹
```




|  |  |
| --- | --- |
| [❶](#CO16-1) | Define a new generic `cmp` procedure taking two parameters and returning an integer. |
| [❷](#CO16-2) | The `sort` procedure expects the specified `cmp` procedure to return a value that is larger than 0 when x > y. |
| [❸](#CO16-3) | Whereas when x == y to return exactly 0. |
| [❹](#CO16-4) | And when x < y to return a value that is less than 0. |





The `cmp` procedure is generic, it takes two parameters: `x` and `y`, both of type `T`. In *Listing 4.16* when the `cmp` procedure is passed to the `sort` procedure the first time, the `T` is bound to `int` because `int` is specified in the square brackets. In *Listing 4.17* the compiler can infer the `T` type for you, so there is no need to specify the types explicitly. You will learn more about generics in Chapter 8.


The `cmp` procedure will work for any `T` type as long as both the `==` and `<` operators are defined for it. The pre-defined `cmp` should be enough for most of your use cases, but you can of course write your own `cmp` procedures and pass them to `sort`.


The `algorithm` module includes many other definitions which work on both arrays and sequences. For example, a `reverse` procedure which reverses the order of the elements of a sequence or array, and a `fill` procedure which fills every position in an array with the specified value. For a full list of procedures make sure to take a look at the `algorithm` module documentation: <http://nim-lang.org/docs/algorithm.html>.





4.4.4  Other modules
--------------------



There are many other modules which implement data structures in Nim’s standard library. Before you decide to implement a data structure yourself, make sure to take a look at the list of modules in Nim’s standard library. It includes linked lists, queues, ropes and much more. A full list of modules is available at this URL: <http://nim-lang.org/docs/lib.html>.


There are also many more modules dedicated to manipulating data structures. The `sequtils` module is one example of that. It includes many useful procedures for manipulating sequences and other lists. These procedures should be familiar to you if you have any previous experience with functional programming. For example, `apply` which allows you to apply a procedure to each element of a sequence, `filter` which returns a new list with elements which have fulfilled a specified predicate, and much more. To learn more about it, take a look at its documentation: <http://nim-lang.org/docs/sequtils.html>.


This section has given you some examples of the most useful data structures and algorithms in Nim’s standard library. We can now move on to the next section where we will look at modules which allow us to make use of the services that an operating system provides.






4.5  Interfacing with the operating system
==========================================



In most cases the programs that you create will require an operating system to function. The operating system manages your computer’s hardware and software, and provides common services for computer programs.


These services are available using a number of operating system APIs, many of the modules in Nim’s standard library abstract these APIs in order provide a single Nim API that is cross-platform and is easy to use in Nim code. Almost all of the modules which do so are listed under the "Generic Operating System Services" category in the standard libraries' module list. These modules implement a range of operating system services including:



* Access to the file system
* Manipulation of file and folder paths
* Retrieval of environment variables
* Reading of command line arguments
* Execution of external processes
* Access to the current system time and date
* Manipulation of the time and date



Many of these services are essential to the successful implementation of some applications. In the previous chapter I have shown you how to read command line arguments and how to communicate with applications over a network. Both of these are services provided by the operating system, the latter of which is not in the above list because it has its own category in the standard library. I will talk about modules which deal with networks and internet protocols later on in this chapter.




4.5.1  Working with the file system
-----------------------------------



A typical file system consists primarily of files and folders. This is something that the 3 major operating systems *thankfully* agree on. But you do not need to look far to start seeing differences, something as simple as a file path is not even consistent. Take a look at *Table 4.2* which shows the file path to a `file.txt` file in the user’s home directory.




Table 4.2. File paths on different operating systems








| Operating System | Path to file in home directory |
| Windows | `C:\Users\user\file.txt` |
| Mac OS X | `/Users/user/file.txt` |
| Linux | `/home/user/file.txt` |




Note both the different directory separators as well as the different locations of what is know as the "home directory". This inconsistency proves problematic when wanting to write software which works on all three of those operating systems.


The `os` module defines constants and procedures which allow us to write code that is cross-platform. The following example shows how to create and write to a new file at each of the file paths defined in *Table 4.2*, without having to write it three times for each of the operating systems.




Listing 4.18. Write `"Some Data"` to `file.txt` in the home directory




```
import os   ❶
let path = getHomeDir() / "file.txt"   ❷
writeFile(path, "Some Data")           ❸
```




|  |  |
| --- | --- |
| [❶](#CO17-1) | The `os` module defines the `getHomeDir` procedure as well as the `/` operator used on the second line. |
| [❷](#CO17-2) | The `getHomeDir` proc returns the path to the home directory, returns a different path depending on the current operating system. The `/` operator is like the `&` concatenation operator but it adds a path separator between the home directory and `file.txt`. |
| [❸](#CO17-3) | The `writeFile` procedure is actually defined in the `system` module, it simply writes the specified data to the file at the path specified. |





To give you a better idea of how `path` is computed take a look at *Table 4.3*.




Table 4.3. The results of the path manipulation procedures









| Expression | Operating System | Result |
| `getHomeDir()` | Windows | `C:\Users\username\` |
| Mac OS X | `/Users/username/` |
| Linux | `/home/username/` |
| `getHomeDir() / "file.txt"` | Windows | `C:\Users\username\file.txt` |
| Mac OS X | `/Users/username/file.txt` |
| Linux | `/home/username/file.txt` |




 





> Tip The `joinPath` procedure |
| You can also use the equivalent `joinPath` instead of the `/` operator if you prefer, e.g. `joinPath(getHomeDir(), "file.txt")`. |



The `os` module includes other procedures for working with file paths including `splitPath`, `parentDir`, `tailDir`, `isRootDir`, `splitFile`, and more. The code in *Listing 4.20* shows how some of them can be used, in each `doAssert` line the right hand side of `==` shows the expected result.




Listing 4.19. Path manipulation procedures




```
import os                  ❶
doAssert(splitPath("usr/local/bin") == ("usr/local", "bin"))   ❷
doAssert(parentDir("/Users/user") == "/Users")      ❸
doAssert(tailDir("usr/local/bin") == "local/bin")   ❹
doAssert(isRootDir("/"))   ❺
doAssert(splitFile("/home/user/file.txt") == ("/home/user", "file", ".txt"))   ❻
```




|  |  |
| --- | --- |
| [❶](#CO18-1) | Import the `os` module in order to access the procedures used below the `import` statement. |
| [❷](#CO18-2) | Splits the path into a tuple containing a head and a tail. |
| [❸](#CO18-3) | Returns the path to the parent directory of the path specified. |
| [❹](#CO18-4) | Removes the first directory specified in the path and returns the rest. |
| [❺](#CO18-5) | Returns `true` if the specified directory is a root directory. |
| [❻](#CO18-6) | Splits the specified file path into a tuple containing the directory, filename, and file extension of the path specified. |





In addition to this the `os` module defines the `existsDir` and `existsFile` procedures for determining whether a specified directory or file exists. There are also a number of iterators which allow you to iterate over the files and directories in a specified directory path.




Listing 4.20. Displaying the contents of the home directory




```
import os     ❶
for kind, path in walkDir(getHomeDir()):      ❷
  case kind   ❸
  of pcFile: echo("Found file: ", path)       ❹
  of pcDir: echo("Found directory: ", path)   ❺
  of pcLinkToFile, pcLinkToDir: echo("Found link: ", path)   ❻
```




|  |  |
| --- | --- |
| [❶](#CO19-1) | Import the `os` module in order to access the `walkDir` iterator and the `getHomeDir` procedure. |
| [❷](#CO19-2) | Use the `walkDir` iterator to go through each of the files in your home directory, the iterator will *yield* a value whenever a new file, directory or link is found. |
| [❸](#CO19-3) | Check what the `path` variable references: a file, a directory, or a link? |
| [❹](#CO19-4) | When the `path` references a file then display the message `"Found file: "` together with the file path. |
| [❺](#CO19-5) | When the `path` references a directory then display the message `"Found directory: "` together with the directory path. |
| [❻](#CO19-6) | When the `path` references either a link to a file or a link to a directory, display the message `"Found link: "` together with the link path. |





Apart from all this, the `os` module implements many more procedures, iterators and types for dealing with the file system and more. The Nim developers ensure that the implementation is flexible and that it works on all operating systems and platforms. The amount of functionality implemented in this module is too large to fully go into in this chapter, so I strongly recommend that you look at this module in more depth to fully realise the extent of its functionality yourself. You can do so by looking at the `os` module’s documentation. The documentation includes a list of all the procedures defined in that module, together with examples and descriptions explaining how those procedures can be used effectively. The documentation for the `os` module can be accessed at the following URL: <http://nim-lang.org/docs/os.html>.





4.5.2  Executing an external process
------------------------------------



You may occasionally wish for your application to start the execution of another program. For example, you may wish to open your website in the user’s default browser. One important thing to keep in mind when doing this is that the execution of your application will be blocked until the execution of an external program finishes. As such executing processes is currently completely synchronous, just like the standard input reading introduced in the previous chapter.


The functionality for executing processes is all defined in the `osproc` module. This module defines multiple procedures for executing a process, some of them are simpler than others. The simpler procedures are very convenient but they do not always allow the same kind of customisation as to how the external process should be executed that the more complex procedures provide.


The simplest way to execute an external process is using the `execCmd` procedure, it takes a command as a parameter and executes it. After the execution of the command completes, it returns the exit code of that command. The standard output, standard error and standard input are all inherited from your application’s process. So you have no way of capturing the output from the process.


The `execCmdEx` procedure is almost identical to the `execCmd` procedure, but it returns both the exit code of the process and the output. Take a look at *Listing 4.22* to see how it can be used.




Listing 4.21. Using `execCmdEx` to determine some information about the operating system




```
import osproc            ❶

when defined(windows):   ❷
  let (ver, _) = execCmdEx("cmd /C ver")   ❸
else:
  let (ver, _) = execCmdEx("uname -sr")    ❹

echo("My operating system is: ", ver)      ❺
```




|  |  |
| --- | --- |
| [❶](#CO20-1) | Import the `osproc` module where the `execCmdEx` proc is defined. |
| [❷](#CO20-2) | Check whether this Nim code is being compiled on Windows. |
| [❸](#CO20-3) | If this Nim code is being compiled on Windows then execute `cmd /C ver` using `execCmdEx` and unpack the tuple it returns into two variables. |
| [❹](#CO20-4) | If this Nim is not being compiled on Windows then execute `uname -sr` using `execCmdEx` and unpack the tuple it returns into two variables. |
| [❺](#CO20-5) | Display the output from the execution of the command above. |





Compile and run this application and see what is displayed. *Figure 4.7* shows the output of *Listing 4.22* on my MacBook.




Figure 4.7. The output of *Listing 4.22*


![ch04 os version](../Images/ch04_os_version.png)

Keep in mind that this probably isn’t the best way to determine what the current operating system is. [[17]](#ftn.d5e5337)




The compile-time if statement



In *Chapter 2* the `when` keyword was introduced to you briefly. In *Listing 4.22* `when` is used to determine the operating system for which the current module is being compiled for. The `defined` procedure checks at compile-time whether the specified symbol is defined. When the code is currently being compiled for Windows the `windows` symbol is defined. So on Windows, the code immediately under the `when` statement is compiled, whereas the code in the `else` branch is not. On other operating systems the code in the `else` branch is compiled and the code above is ignored.


The scope rules are also a bit different, a `when` statement does not create a new scope. This is why it is possible to access the `ver` variable outside it.



*Listing 4.22* also shows the use of an underscore as one of the identifiers in the unpacked tuple, it tells the compiler that we are not interested in part of tuple. This is useful because it removes warnings about unused variables made by the compiler.


That’s the basics of executing processes using the `osproc` module. Together with a bit of some new Nim syntax and semantics thrown in. The `osproc` module contains other procedures which allow for more control of processes, including writing to the process' standard input and running more than one process at a time. Be sure to look at the documentation for the `osproc` module to learn more about it.





4.5.3  Other operating system services
--------------------------------------



There are of course many more modules which allow you to put the services provided by operating systems to use. These modules are a part of the "Generic Operating System services" category of the standard library. Some of them will be used in later chapters; others you can explore on your own. The documentation for these modules is a good resource to learn more, to find out more about these modules take a look at this URL: <http://nim-lang.org/docs/lib.html#pure-libraries-generic-operating-system-services>




  


[[17]](#d5e5337) There is a `osinfo` package available online which uses the OS API directly to get this information <https://github.com/nim-lang/osinfo>







4.6  Understanding and manipulating data
========================================



Every program deals with data, and so understanding and manipulating it is crucial. You have learned about ways to represent data in Nim both in *Chapter 2* and earlier on in this chapter.


The most used type for representing data is the `string` type, as it can represent just about any piece of data, an integer can just be represented as `"46"`, a date as `"June 26th"` and a list of values as `"2, Bill, King, Programmer"`.


There needs to be a way for our program to understand and manipulate this data. Understanding data can be done using a parser. A parser will look at a value, in many cases a textual value of type `string`, and build a data structure out of it. There is of course a possibility of the value being incorrect, so a parser will check for syntax errors while parsing the value.


The Nim standard library is full of parsers, there are so many of them that there is a full category named "Parsers" dedicated to them. The parsers which are available in the standard library can parse the following: command line arguments, configuration files in the `.ini` format, XML, JSON, HTML, CSV, SQL, and much more. You have already seen how to use the JSON parser in *Chapter 3*, in this section I will show you how to use some of the other parsers.


Many of the names of the modules that implement a parser begin with the word `parse`, for example `parseopt` and `parsexml`. Some of them have modules which implement a more intuitive API on top of them. Some examples of that are the XML modules: `xmldom`, `xmltree`, `xmldomparser`, `xmlparser`. The latter two modules create a tree-like data structure out of the `parsexml` module’s output. The former two modules are then used to manipulate the tree-like data structures. The `xmldom` module provides a web DOM-like API whereas the `xmltree` module provides a more idiomatic Nim API. The `json` module defines both a high-level API for dealing with JSON objects and a low-level parser which parses JSON and emits objects which represent the current data being parsed.




4.6.1  Parsing command-line arguments
-------------------------------------



Describing how each of these modules can be used for parsing would require its own chapter. Instead, I will look at a specific data parsing problem and show you some ways that this problem can be solved using the modules available in Nim’s standard library.


The problem I will look at is the parsing of command-line arguments. In *Chapter 3* you have retrieved the command-line arguments using the `paramStr()` procedure and used the returned `string` value directly. This worked well because the application did not support any options or flags.


Let’s say that you would like the application to support an optional `port` flag on the command-line, one which expects a port number to follow. You may for example be writing a server application, and want to give the user the option to select the port on which the server will run on. Executing an application called `parsingex` with such an argument would look like the following: `./parsingex --port=1234`. The `"--port=1234"` can be accessed with a `paramStr()` procedure call as shown in *Listing 4.23*.




Listing 4.22. Retrieving the command-line arguments using `paramStr`




```
import os                  ❶

let param1 = paramStr(1)   ❷
```




|  |  |
| --- | --- |
| [❶](#CO21-1) | The `os` module defines the `paramStr` procedure and so must be imported. |
| [❷](#CO21-2) | The command-line argument at index 1 will be equal to `"--port=1234"`, assuming the application is executed as shown above. |





Now you’ve got a `string` value in the `param1` variable, this value contains both the flag name and the value associated with it. But how do you extract those and separate them?


There are many ways that this can be done. Some less valid than others. I will show you a couple of them, because in doing so I will be showing you many different ways that the `string` type can be manipulated and understood by your program.


Let’s start by taking a substring of the original string value. The `substr` procedure defined in the `system` module allows us to do this. It takes a `string` value, a start index and an end index both represented as integers. It then returns a new copy of the string, starting at the specified first index and ending at the specified end index.





> Tip More ways to manipulate strings |
| Nim strings can be modified at runtime because they are mutable. This means that they can be modified in-place, without the need to allocate a new copy of the string. You can use the `add` procedure to append characters and other strings to them, and the `delete` (defined in the `strutils` module) to delete characters from them. |





Listing 4.23. Parsing the flag using `substr`




```
import os

let param1 = paramStr(1)
let flagName = param1.substr(2, 5)   ❶
let flagValue = param1.substr(7)     ❷
```




|  |  |
| --- | --- |
| [❶](#CO22-1) | Get the substring of `param1`, from index 2 to index 5. Will result in `"port"`. |
| [❷](#CO22-2) | Get the substring of `param1`, from index 7 until the end of the string. Will result in `"1234"`. |





*Figure 4.8* shows how the indexes passed to `substr` determine which substrings are returned.




Figure 4.8. The `substr` procedure


![ch04 substr](../Images/ch04_substr.png)



The slice operator



A series of two dots, otherwise known as the `..` operator can be used to create a `Slice` object. A `Slice` can then be fed into the `[]` operator which will return a substring. This is similar to the `substr` procedure but it supports reverse indexes using the `^` operator.





```
doAssert("--port=1234"[2 .. 5] == "port")    ❶
doAssert("--port=1234"[7 .. ^1] == "1234")   ❷
doAssert("--port=1234"[7 .. ^3] == "12")     ❸
```




|  |  |
| --- | --- |
| [❶](#CO23-1) | Same as using `substr(2, 5)`, returns a substring from index 2 to index 5. |
| [❷](#CO23-2) | Returns a substring from index 7 to the end of the string. The `^` operator counts back from the end of the string. |
| [❸](#CO23-3) | Returns a substring from index 7 to the end of the string minus 2 characters. |




The code in *Listing 4.24* will work, but only when the passed flag is exactly `"--port=1234"`. As soon as the user changes the port to `"--port="` it will break.


In order to improve this, let me introduce you to the `strutils` module. This module contains many definitions for working with strings. For example, `toUpper` and `toLower` for converting each character in a string to upper or lower case respectively, `parseInt` for converting a string into an integer, `startsWith` to determine whether a string starts with another string, and much more. There is a specific procedure which can help us split up the string properly, and that procedure is called `split`.




Listing 4.24. Parsing the flag using `split`




```
import os, strutils                     ❶

let param1 = paramStr(1)
let flagSplit = param1.split('=')       ❷
let flagName = flagSplit[0].substr(2)   ❸
let flagValue = flagSplit[1]            ❹
```




|  |  |
| --- | --- |
| [❶](#CO24-1) | The `strutils` module must be imported because the `split` procedure is defined there. |
| [❷](#CO24-2) | The `param1` string value is separated into multiple different strings at the location where a `=` occurs. The `split` procedure returns a sequence of strings, in this case `@["--port", "1234"]`. |
| [❸](#CO24-3) | Grab the first string in the sequence returned by `split` and remove the first two characters. |
| [❹](#CO24-4) | Grab the second string in the sequence returned by `split`. |





This is still poor man’s parsing but it does work. There is no error handling but the code should work for many different flags. But what about when requirements change, say for example one of our users prefers to separate the flag name from the value using the `:` symbol. This is actually easy to implement because the `split` procedure accepts a `set[char]` so we can specify `{'=', ':'}` and the string will be split on both `=` and `:`.


So `split` actually works very well for parsing something as simple as this, but I’m sure you can imagine cases where it would not be a good choice. For example, if our requirements change so that the flag name can now contain the `=` we run into trouble.


I will stop there, you will learn more about parsing in *Chapter 6* where you will be shown how to use the `parseutils` module to perform more advanced parsing.


Thankfully you do not need to parse command line arguments like this yourself. As I mentioned previously the Nim standard library contains a `parseopt` module which does this for you. *Listing 4.26* shows how it can be used to parse command-line arguments.




Listing 4.25. Parsing the flag using `parseopt`




```
import parseopt        ❶

for kind, key, val in getOpt():       ❷
  case kind            ❸
  of cmdArgument:      ❹
    echo("Got a command argument: --", key)
  of cmdLongOption, cmdShortOption:   ❺
    case key
    of "port": echo("Got port: ", val)
    else: echo("Got another flag --", key, " with value: ", val)
  of cmdEnd: discard   ❻
```




|  |  |
| --- | --- |
| [❶](#CO25-1) | Import the `parseopt` module which defines the `getOpt` iterator. |
| [❷](#CO25-2) | Iterate over each command line argument, the `getOpt` iterator yields 3 values, the kind of argument that was parsed, the key and the value. |
| [❸](#CO25-3) | Check the kind of argument that was parsed. |
| [❹](#CO25-4) | If a simple flag with no value was parsed just display the flag name. |
| [❺](#CO25-5) | If a flag with a value was parsed, check if it’s `--port` and display a specific message if it is showing the port value, otherwise display a generic message showing the flag name and value. |
| [❻](#CO25-6) | The command-argument parsing has ended, so we just do nothing. |





The code is a bit more verbose, but it handles errors for us, supports other types of flags and goes through each command-line argument. This parser is quite tedious, unfortunately the standard library does not contain any modules which build on top of it. There are many third-party modules which make the job of parsing and retrieving command-line arguments much easier, these are available through the Nimble package manager which I will introduce to you in the next chapter.


Now compile and run the code in *Listing 4.26* above. Try to pass different command-line arguments to the program and see what it outputs.





4.6.2  Conclusion
-----------------



This section should have give you some ideas of how to manipulate the most common and versatile type: the `string`. I have talked about the different parsing modules available in Nim’s standard library and also showed you how one of them can be used to parse command-line arguments. In addition to that I have introduced you to the `strutils` module which contains many useful procedures for manipulating strings, be sure to check out its documentation and the documentation of the other modules in more depth later.






4.7  Networking and the internet
================================



The Nim standard library offers a very large selection of modules that can be used for networking. You have already been introduced to the asynchronous event loop together with asynchronous sockets defined in the `asyncdispatch` and `asyncnet` modules respectively. These modules provide the building blocks for many of the modules in the standard libraries' "Internet Protocols and Support" category.


The standard library also includes the `net` module which is the synchronous equivalent of the `asyncnet` module. It also contains some procedures that can be used for both asynchronous sockets and synchronous ones.


The more interesting modules are the ones which implement certain internet protocols such as HTTP, SMTP, and FTP. HTTP stands for HyperText Transfer Protocol and it is the protocol that your web browser uses to request resources such as web pages from web servers on the internet. SMTP stands for Simple Mail Transfer Protocol and it is used for the transfer of emails. FTP stands for File Transfer Protocol and it is used to transfer files between multiple computers. The modules which implement these protocols are called `httpclient`, `smtp` and `asyncftpclient` respectively. There is also a `asynchttpserver` module which implements a high-performance HTTP server, this allows your Nim application to serve web pages to clients such as your web browser.


The main purpose of the `httpclient` module is the ability to request resources from the internet, for example the Nim website can be retrieved using this module as shown in *Listing 4.27*.




Listing 4.26. Requesting the Nim website using the `httpclient` module




```
import asyncdispatch     ❶
import httpclient        ❷

let client = newAsyncHttpClient()   ❸
let response = waitFor client.get("http://nim-lang.org")   ❹
echo(response.version)   ❺
echo(response.status)    ❻
echo(response.body)      ❼
```




|  |  |
| --- | --- |
| [❶](#CO26-1) | The `asyncdispatch` module is required. It defines an asynchronous event loop which is necessary to use the asynchronous http client. It defines the `waitFor` procedure which runs the event loop. |
| [❷](#CO26-2) | The `httpclient` module defines the asynchronous HTTP client and related procedures. |
| [❸](#CO26-3) | Create a new instance of the `AsyncHttpClient` type. |
| [❹](#CO26-4) | Request the Nim website using HTTP GET which retrieves the website. The `waitFor` procedure will run the event loop until the `get` procedure if finished. |
| [❺](#CO26-5) | Display the HTTP version that the server responded with. Likely `"1.1"`. |
| [❻](#CO26-6) | Display the HTTP status that the server responded with. If request successful then `"200 OK"`. |
| [❼](#CO26-7) | Display the body of the response. If the request was successful, this will be the HTML of the Nim website. |





The code in *Listing 4.27* will work for any resource requested. You should also be able to request any website URL using it.


These modules are all fairly simple to use. Be sure to check out their documentation for details about the procedures that they define and how those procedures can be used. There may be protocols which the standard library misses, or custom protocols that you would like to implement yourself. There is a wide range of networking protocols that have been implemented as libraries outside the standard library, these modules have been implemented by other Nim developers and can be found using the Nimble package manager which you will learn about in the next chapter.





4.8  Summary
============




* A library is a collection of modules, modules in turn implement a list of behaviours.
* Identifiers in Nim are private by default and can be exported using `*`.
* Modules are imported into the importing module’s global namespace by default.
* Only certain symbols can be imported using the `from module import x` syntax.
* The standard library is organised into pure, impure and wrapper categories.
* The `system` module is imported implicitly and contains many commonly used definitions.
* The `tables` module implements a hash table that can be used to store associative data.
* The `algorithms` module defines a `sort` procedure that can be used for sorting arrays and sequences.
* The `os` module contains many procedures for accessing the computer’s file system.
* Web pages can be retrieved using the `httpclient` module.





