

2
=


Getting started
===============


This chapter covers:



* Installing Nim and the Aporia IDE
* Nim basics
* Mastering control flow
* Using collection types
* Handling exceptions
* Defining data types



You will begin this chapter by setting up the Nim compiler and some tools to assist you in writing Nim code. You will then learn about Nim’s syntax, procedures, for loops, and other basic aspects of the language. Be aware that this chapter is long; it contains a lot of information to give you a taste of as much of the language as possible. Feel free to skip certain sections if you already know them, for example you can skip the "Setting up your environment" section if you’ve already got Nim set up.




2.1  Setting up your environment
================================



Before you begin writing Nim code, you have to install and set up the Nim compiler. The Nim compiler is the tool that will transform your Nim source code into a binary format which your computer can then execute. It is only used during development so application’s users will not need it.


You have the option of installing Aporia, the Nim IDE, as well. Aporia is a useful tool for beginning Nim programmers, as it allows them to compile and run Nim code easily, it can also be used as a Nim-centric alternative to popular source code editors such as gEdit, SublimeText or Atom.


In the following sections, you will learn how to install both the Nim compiler and Aporia IDE. You will then test the Nim development environment you set up by compiling and executing a Hello World example. Now, grab any computer, even a Raspberry Pi will work, [[6]](#ftn.d5e672) and follow along!




2.1.1  Installing the Nim compiler
----------------------------------



There are many ways to install the Nim compiler. For Windows operating systems, the Nim website offers an installation wizard which makes the installation process easy. The *Installation Wizard (Windows only)* sub-section describes the steps required to install Nim using this wizard. For Mac OS X, Linux and other supported operating systems the installation process is a bit more complicated. The *Archived Snapshot (All Platforms)* sub-section describes the steps required to install Nim on those operating systems.





> Note Possible problems |
| There is nothing more annoying than not being able to install something. The installation instructions below are detailed on purpose to ensure that you can install Nim successfully, but there is always a risk that you will run into trouble. As Nim evolves these instructions may become outdated. If you run into trouble please don’t let that discourage you. Consult the Nim website, [[7]](#ftn.d5e682) for up-to-date installation instructions as well as ways to get in touch with us if you run into problems. |





### Installation Wizard (Windows only)



The installation wizard is currently only available for Windows. Like many typical Windows installation wizards, it guides you step-by-step through the installation process. In addition to the Nim compiler itself, you will have the option of installing a number of other components including:



* Nim documentation
* A C compiler
* Support DLLs
* Aporia IDE



With the exception of the C compiler these components are all optional. The Nim compiler will not work without a C compiler alongside it. You will be given an option to select which components you wish to install.


**Download the installation wizard**


Navigate to the Nim download page, located at the following URL: <http://nim-lang.org/download.html>.


The *Binaries* section on the download page should list two installers. These are both Windows installers, and they install the latest version of the Nim compiler and related tools. The downloads page contains links to an installer for 32 and 64 bit versions of Windows. The 32 bit version will work on both 32 bit and 64 bit versions of Windows, choose it if you are unsure about the CPU architecture supported by your Operating System.


Click on the download link for the CPU architecture that matches your operating system’s architecture.


**Execute the installation wizard**


Execute the downloaded executable file. The Nim installation wizard should appear.


Click the button labelled *Next*. You should be presented with a license agreement. Click the *I Agree* button. You will then see a list of components similar to the one in *Figure 2.3*.




Figure 2.1. The component list that the installation wizard can install


![ch02 nim install components](../Images/ch02_nim_install_components.png)

I recommend that you select all of those components. You must select the "C Compiler (MingW)" option, unless you already have a C compiler installed.





|  |  |
| --- | --- |
| [Warning] | The external C compiler |
| A C compiler is very important. Without it the Nim compiler will not function properly. If you already have one installed then you may need to edit Nim’s configuration file to make use of it. It is usually better to just let the installation wizard install the C compiler. |



After selecting the components you wish to install, click the *Next* button. You will be given the option to select the installation directory, among other things. Click the *Next* button until the installation completes.


**Verify that the installation was successful**


You should then verify that the installation was successful. To do this, open a new command prompt. Then execute `nim -v`. You should see the version of the Nim compiler that you just installed, together with other information. *Figure 2.5* shows what that may look like.




Figure 2.2. Checking the Nim compiler’s version


![ch02 nim version check](../Images/ch02_nim_version_check.png)



Troubleshooting



If you instead get an error, then you may need to add the file path of the directory where the `nim.exe` file resides to your `PATH` environment variable. This is typically `C:\Program Files\Nim\bin`.


**Adding Nim to your PATH**


You need to access the advanced system settings. You can do so by opening Control Panel > System and Security > System. You should then see "Advanced system settings" in the left sidebar, click on it and a dialog should appear. The dialog will include an "Environment Variables" button which will display another dialog allowing you to edit the environment variables. Make sure to edit the `Path` variable either under the "System variables" or "User variables". Make sure the path you added is separated from the other paths by a semi-colon (`;`).


**Other issues**


If adding the Nim compiler to your `PATH` environment variable does not help then verify that a `nim.exe` file is in the directory path that you added to your `PATH`.


If you get stuck you can always get more help on the Nim Forum, or on IRC. Take a look at the *Getting Help* appendix for more information.



If you selected the "Aporia IDE" component during the installation, then you can safely skip the *Installing the Aporia IDE* section below. Assuming that you were successful in installing Nim. You are now ready to begin developing Nim software! The *Testing your new development environment* section will show you how to compile your first Nim application!





### Archived Snapshot (All platforms)



This installation method will work on all platforms. It relies on a compressed archive. This archive contains the C source code, which has been generated for a specific version of the Nim compiler. What you will be doing is compiling the Nim compiler yourself. This is currently necessary because pre-compiled binaries for Mac OS X and Linux are not available.


To compile the C source code, you need to have a C compiler installed on your system. If you do not already have one, then you will need to install one first.




Installing a C compiler



The installation of a C compiler is fairly straightforward. The recommended C compiler and the process for installing it differs depending on your operating system.


**Mac OS X**


The recommended C compiler on Mac OS X is clang. Clang can be installed in two ways.


If you have Homebrew, then simply execute `brew install clang` to install clang.


Otherwise, follow the following steps.



1. Open a terminal window.
2. Execute `clang` or `gcc`.



A dialog box asking whether you would like to install the "Command Line Developer Tools" should appear. Alternatively you can execute `xcode-select --install`.


Click the *Install* button. Wait for the installation to finish, then verify that the installation was successful by executing `clang --version`.


**Linux**


In all likelihood you already have a C compiler installed. Before attempting to install you can verify this by running `gcc --version` or `clang --version`.


The recommended C compiler for Linux is GCC. The installation instructions depend on your distribution’s package manager.


On yum-based distributions you should be able to execute `sudo yum install gcc` to install GCC.


On Debian-based distributions you can execute `apt-get` like so: `sudo apt-get install gcc`.


After the installation finishes, make sure to verify that it was successful by executing `gcc --version`.


**Windows**


The easiest way to install a C compiler on Windows is using the Nim installation wizard mentioned previously. Should that fail you can install GCC manually by installing the MinGW package available here: <http://www.mingw.org/>.



**Download the Nim compiler archive**


After you have a working C compiler installed. It is time to download the C sources of the latest version of the Nim compiler available.


Navigate to the Nim download page and scroll down until you see the download links for the generated C sources for Linux and Mac OS X.


You may see two download links, one of them a zip archive and another a tar.xz archive. If you are unsure which one to pick then download the zip archive.


**Extract the archive and move it to a safe location**


Once the download completes, extract the archive. You should be able to simply double click the zip archive in your operating system’s file manager to extract it.


You should see a folder containing files belonging to the Nim compiler. This folder’s name will likely be `nim-<ver>`. Where `<ver>` is the version of the Nim compiler that you downloaded. For example `nim-0.12.0`.


Move the Nim folder to a safe place. Somewhere where you would like to install it. For example `~/programs/nim`.


The `nim` directory should look similar to *Figure 2.7*.




Figure 2.3. The `nim` directory after it was extracted from the archive


![ch02 nim archive](../Images/ch02_nim_archive.png)

**Compile the Nim compiler**


Now open a terminal. Navigate into the `nim` directory using the `cd` command, for example `cd ~/programs/nim`. Your terminal should look similar to the one in *Figure 2.8*.




Figure 2.4. Terminal after navigating to `/home/dom/programs/nim`


![ch02 nim archive terminal](../Images/ch02_nim_archive_terminal.png)

You can now build the Nim compiler. Execute one of the `build` scripts. The `build.bat` and `build64.bat` scripts are for Windows and the `build.sh` script is for all other operating systems. To execute the `build.sh` script just type `sh build.sh` into the terminal.


Depending on the CPU power of your computer, this may take some time. But unless you are compiling Nim on a 1995 IBM NetVista, it shouldn’t take more than a minute.


When the compilation is successful, you should see SUCCESS at the bottom of your terminal. Similar to *Figure 2.9*.




Figure 2.5. The compilation succeeded


![ch02 nim archive success](../Images/ch02_nim_archive_success.png)




> Tip Getting help |
| Did the compilation fail? Are you having other issues? There are many ways to get help. One of the easiest is to ask on the Nim Forum or on IRC. For more information see the *Getting Help* appendix. |



The `bin` directory should now contain a `nim` binary. But the installation is not finished yet.


**Add Nim to your `PATH`**


In order for the `nim` binary to be visible to other applications, such as the terminal. You need to add the `bin` directory to your `PATH`. In my example above, the path you would need to add would be `/Users/dom/programs/nim/bin` because my username is `dom`.





> Note The `~` on Linux |
| Keep in mind that the `~` expands to `/home/<your_username>` on Linux, the examples above are for Mac OS X. |






> Tip How to add Nim to your `PATH` |
| **Windows**
See the *Installation Wizard (Windows only)* section for Windows-specific instructions.
**Mac OS X**
There are multiple ways to edit your PATH on Mac OS X. You can open the `/etc/paths` file (as root using `sudo nano /etc/paths` or your favourite editor) and append the Nim bin path to the bottom. Alternatively, you can edit the `~/.profile` file and add `export PATH=$PATH:/home/user/path/to/Nim/bin` to the bottom.
**Linux**
If you want the change to be system-wide you can edit the `/etc/profile` file. To make Nim only available for your user you can edit the `~/.profile` file. In both cases you should add `export PATH=$PATH:/home/user/path/to/Nim/bin` to the bottom of those files. |



**Verify that the installation was successful**


Ensure that you have completed these steps successfully by opening a new terminal window and executing `nim -v`. The output should look similar to the following:




```
Nim Compiler Version 0.14.2 (2016-08-09) [MacOSX: amd64]
Copyright (c) 2006-2016 by Andreas Rumpf

git hash: e56da28bcf66f2ce68446b4422f887799d7b6c61
active boot switches: -d:release
```


Assuming that you were successful in installing Nim. You are now ready to begin developing Nim software! Before testing your new development environment you have the option of installing the Aporia IDE, the next section describes the process of installing it. You may choose to skip this if you would like to use another IDE or text editor for writing Nim code. The *Testing your new development environment* section will show you how to compile your first Nim application!






2.1.2  Installing the Aporia IDE
--------------------------------





Figure 2.6. Main Aporia window


![aporia](../Images/aporia.png)

The installation of Aporia is entirely optional, but I strongly recommend it. Aporia integrates with the Nim compiler so it makes experimenting with Nim easier. With Aporia you will be able to compile and run Nim source code by pressing the F5 key on your keyboard. Later in this section, you will also learn how to compile Nim source code using the command line, so you will not miss out by using a different source code editor.


Releases of Aporia can be downloaded from GitHub, you will find detailed instructions on how to install it on your operating system at the following URL: <https://github.com/nim-lang/Aporia#readme> If you have used the Windows installer then you likely have Aporia installed already.





2.1.3  Testing your new development environment
-----------------------------------------------



You should now have a basic Nim development environment set up. This setup should include the Nim compiler, and may also include Aporia or a different source code editor with support for Nim syntax highlighting.


Let’s test our new environment with our first Nim program: Hello World!


Open your source code editor of choice and type in the following short piece of code.




Listing 2.1. Hello World




```
echo "Hello World!"
```



Now save the file as `hello.nim`. Then open a new terminal in the directory that contains the file you just saved and execute `nim c -r hello.nim`.




Nim command syntax



The Nim command syntax takes the form of `nim command [options] projectFile.nim`, where the `options` are optional. Some common commands include:









| Command | Description |
| `c`, `compile` | Compiles the `projectFile.nim` and all its dependencies into an executable using the default backend (C). |
| `cpp` | Compiles the `projectFile.nim` and all its dependencies using the C++ backend. Result is an executable. |
| `js` | Compiles the `projectFile.nim` and all its dependencies using the JavaScript backend. Result is a javascript file. |
| `check` | Parses the `projectFile.nim` file and checks it for errors. Displays all the errors found. |



For a full list execute `nim --help` and `nim --advanced`. When compiling using the C/C++ backends passing in the `-r` flag will run the resulting executable after compilation. Arguments to this executable can be passed after the `projectFile.nim` param: `nim c -r projectFile.nim arg1 arg2`.





> Tip Aporia |
| In Aporia, you can simply press F5 to compile and run your program. You don’t even have to save it manually! |



This command will compile the `hello.nim` file you have written, generating as the output a brand new binary file. Indeed, the `c` subcommand stands for `compile`. Once the compilation finishes, the binary will be executed. This operation is performed automatically by the Nim compiler if you specify the `-r` option, which stands for "run".


At this point, if you have followed along and performed these steps yourself (I strongly encourage you to do this!), you may be wondering what to make of all these messages being output to your screen. These messages come from the Nim compiler. By default the Nim compiler will display information about which modules it is currently processing to notify you of progress. Other information includes warnings, errors and other messages triggered by your source code. Listing 2.2 shows a sample of annotated output from the Nim compiler.




Listing 2.2. Compiler output




```
config/nim.cfg(54, 3) Hint: added path: '~/.nimble/pkgs/' [Path]   ❶
Hint: used config file '~/nim/config/nim.cfg' [Conf]   ❷
Hint: system [Processing]   ❸
Hint: hello [Processing]
CC: hello   ❹
CC: stdlib_system
[Linking]
Hint: operation successful (9407 lines compiled; 1.434 sec total; 14.143MB; Debug Build) [SuccessX]
/Users/dominikp/nim-in-action/examples/hello   ❺
Hello World!   ❻
```




|  |  |
| --- | --- |
| [❶](#CO1-1) | The compiler has added Nimble packages to its module search path |
| [❷](#CO1-2) | The compiler used a config file located in `~/nim/config/nim.cfg` |
| [❸](#CO1-3) | The compiler is parsing and compiling the `system` module to C |
| [❹](#CO1-4) | The compiler is using a C compiler to compile the `hello` module to a binary format |
| [❺](#CO1-5) | The compiler is executing the resulting binary located at that file path |
| [❻](#CO1-6) | The output from the resulting binary’s execution |





You’re probably surprised at just how short the Hello World example is. In comparison to other programming languages like C, Nim does not require a `main` function, which reduces the amount of code needed for this example drastically. In Nim, top-level statements are executed from the top of the file to the bottom, one by one.





|  |  |
| --- | --- |
| [Warning] | Performance |
| Top-level statements are in general harder to optimise for the compiler. In order to get maximum performance, use a `main` procedure and compile with the `-d:release` flag. |



Congratulations are now in order! You have successfully written your first Nim application. But more importantly, you have successfully set up a Nim development environment and are now ready to begin learning the basics of the Nim programming language.





> Note Getting Help |
| In case you run into trouble, take a look at *Appendix A: Getting Help.* (TODO) |






  


[[6]](#d5e672) Seriously though, please don’t use a Raspberry Pi for development.




[[7]](#d5e682) <http://nim-lang.org/>







2.2  Nim syntax
===============



The syntax of a programming language is a set of rules, which govern the way programs in that programming language are written. In the previous section you got a small taste of Nim’s syntax in *Listing 2.1: Hello World*.


Most languages share many similarities in terms of syntax. This is especially true for the C family of languages, which happen to also be the most popular. So much so that 4 of the most popular programming languages take a heavy syntactic inspiration from C. [[8]](#ftn.d5e1032) Nim’s syntax on the other hand differs significantly from the C family of languages. Nim aims to be highly readable, so it often uses keywords instead of punctuation. This makes Nim very similar to Python and Pascal, and is precisely where Nim’s syntax takes most of its inspiration from.


In this section I will teach you the basics of Nim’s syntax. Learning the syntax is a very important first step, as it teaches you the specific ways in which Nim code should be written.




2.2.1  Keywords
---------------



Most programming languages have a notion of a keyword and Nim is no exception. A keyword is a word with a special meaning associated with it; when it is used in a specific context. Because of this you may not use these words as identifiers in your source code.





> Tip Stropping |
| You can get around this limitation by using *stropping*, see *Defining variables and other storage* to learn more. |



As of version 0.12.0, Nim has 70 keywords. [[9]](#ftn.d5e1045) This may sound like a lot, but you must remember that you will not be using most of them. This will be due to the fact that some of them do not yet have a meaning, but are reserved for future versions of the language, while others have minor use cases.


The most commonly used keywords allow you to:



* Specify conditional branches
* Define variables, procedures and types
* Handle runtime errors in your code



The keywords which allow this include `if`, `case`, `of`, `var`, `let`, `proc`, `type`, `object`, `try`, `except` and more. You will learn exactly what these keywords mean, and how to use them in the next sections of this book. For a full list of keywords, consult the Nim manual available at <http://nim-lang.org/docs/manual.html#lexical-analysis-identifiers-keywords>.





2.2.2  Indentation
------------------



Many programmers indent their code to make the program’s structure more apparent. In most programming languages this is not a requirement and serves only as an aid to human readers of the code. In those languages, keywords and punctuation are often used to delimit code blocks. In Nim, just like in Python, the indentation itself is used to delimit code blocks.


Let me give you a simple example to demonstrate the difference. The following 3 code samples written in C, Ruby and Nim respectively all do the same thing. But note the different ways in which code blocks are delimited.




Listing 2.3. C




```
if (42 >= 0) {
  printf("42 is greater than 0");
}
```





Listing 2.4. Ruby




```
if 42 >= 0
  puts "42 is greater than 0"
end
```





Listing 2.5. Nim




```
if 42 >= 0:
  echo "42 is greater than 0"
```



As you can see, C uses curly brackets to delimit a block of code, Ruby uses the keyword `end`, and Nim uses indentation. Nim also uses the colon character at the line which precedes the start of the indentation. This is required for the if statement and for many other statements. But as you continue learning about Nim, you will see that the colon character is not required for all statements which start an indented code block.


Note also the use of the semicolon in *Listing 2.3: C*. This is required at the end of each line in some programming languages. Again, mostly the C family of languages require this. It tells the compiler where a line of code ends. This means that you can have a single statement span multiple lines, or have multiple statements span the same line. In C you would achieve both, respectively, like this:




```
printf("The output is: %d",
  0);
printf("Hello"); printf("World");
```


Nim does not have this requirement. The semicolon is optional and can be used to write two statements on a single line. Spanning a single statement over multiple lines is a bit more complex, you can only split up a statement after punctuation and the next line must be indented. For example:




```
echo("Output: ",    ❶
  5)
echo(5 +            ❶
  5)

echo(5              ❷
  + 5)
echo(5 +
5)                  ❷
```




|  |  |
| --- | --- |
| [❶](#CO2-1) | Both of these statements are correct because they have been split after the punctuation and the next line has been indented. |
| [❷](#CO2-3) | This statement has been incorrectly split up before the punctuation. |
| [❸](#CO2-4) | This statement has been incorrectly indented after the split. |




Because indentation is important in Nim you need to be consistent in its style. The convention states that all Nim code should be indented by 2 spaces. The Nim compiler currently disallows tabs because the inevitable mixing of spaces and tabs can have detrimental effects, especially in a whitespace significant programming language.





2.2.3  Comments
---------------



Comments in code are very important. Because they allow you to add additional meaning to pieces of code. Comments in Nim are written using the hash character `#`. Anything following a hash character will be a comment until the start of a new line. A multi-line comment can be created via `#[` and `]#`, code can also be disabled using `when false:`. For example:




```
# Single line comment
#[
Multi line comment
]#
when false:
  echo("Commented out code")
```


The former type of multi-line comment can be used to comment out both text and code. The latter should only be used to comment out code. The compiler will still parse the code and ensure that the code is still syntactically valid, but the code will not be included in the resulting program. This is because the compiler checks `when` statements at compile-time.




  


[[8]](#d5e1032) TIOBE Index, <http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html>




[[9]](#d5e1045) Nim keywords, <http://nim-lang.org/docs/manual.html#lexical-analysis-identifiers-keywords>







2.3  Nim basics
===============



Now that you have a basic understanding of Nim syntax, you have a good foundation for learning some of the semantics of Nim. In this section, you will learn some of the essential pieces of knowledge every Nim programmer uses on a daily basis. You will learn about the static types most commonly used in Nim, the details of mutable and immutable variables, and how to separate commonly used code into standalone units by defining procedures.




2.3.1  Basic types
------------------



Nim is a statically typed programming language. This means that each identifier in Nim has a type associated with it at compile-time. When you compile your Nim program, the compiler ensures that your code is type safe. If it is not, then compilation terminates and the compiler outputs an error. This is in contrast to dynamically typed programming languages, such as Ruby, which will only ensure that your code is type safe at runtime.


By convention, type names start with an uppercase letter. Built-in types do not follow this convention, so it is easy for you to make a distinction between built-in types and user-defined types by checking the first letter of their name’s case. Nim supports many built-in types, including ones for dealing with the C *Foreign Function Interface*. I won’t cover all of them here, but later in this book and throughout this chapter I will teach you about the advanced built-in types.





> Note Foreign function interface |
| A foreign function interface is what allows us to use libraries written in other programming languages. Nim includes types which are native to C and C++. This covers a wide range of libraries as many of them are written in either C or C++. |



Most of the built-in types are defined in the `system` module, which is imported automatically in your source code. You can qualify these types, for example like so `system.int`, but you don’t have to.





> Tip Modules |
| Modules are imported using the `import` keyword, you will learn more about modules later in this book. |





Table 2.1. Basic types








| Type | Description and uses |
|--|--|
| `int` | The integer type is the type used for whole numbers, for example `52`. |
| `float` | The `float` is the type used for numbers with a decimal point, for example `2.5`. |
| `string` | The type used to store multiple characters, string literals are created by placing multiple characters inside double quotes, for example: `"Nim is awesome"`. |
| `bool` | The boolean type stores one of two values, either `true` or `false`. |
| `char` | The character type stores a single ASCII character, character literals are created by placing a character inside single quotes, for example `'A'`. |




**INTEGER**


The integer type represents numerical data without a fractional component, i.e. a whole number. The amount of data this type can store is finite so there are multiple versions of it in Nim, each suited to different size requirements. The main integer type in Nim is `int`, it is the type you should be using most in your Nim programs.




Table 2.2. Integer Types










| Type | Size | Range | Description |
|--|--|--|--|
| `int` | Architecture dependent. 32 bit on 32 bit systems, 64 bit on 64 bit systems. | **32bit:** `-2,147,483,648` to `2,147,483,647` **64bit:** `-9,223,372,036,854,775,808` to `9,223,372,036,854,775,807` | Generic *signed* two’s complement integer. Generally you should be using this type in most programs. |
| `int8` `int16` `int32` `int64` | 8 bit 16 bit 32 bit 64 bit | `-128` to `127` `-32768` to `32767` `-2,147,483,648` to `2,147,483,647` `-9,223,372,036,854,775,808` to `9,223,372,036,854,775,807` | *Signed* two’s complement integer. These types can be used if you want to be explicit about the size requirements of your data. |
| `uint` | Architecture dependent. 32 bit on 32 bit systems, 64 bit on 64 bit systems. | **32 bit:** `0` to `4,294,967,295` **64 bit:** `0` to `18,446,744,073,709,551,615` | Generic *unsigned* integer. |
| `uint8` `uint16` `uint32` `uint64` | 8 bit 16 bit 32 bit 64 bit | `0` to `255` `0` to `65,535` `0` to `4,294,967,295` `0` to `18,446,744,073,709,551,615` | *Unsigned* integer. These types can be used if you want to be explicit about the size requirements of your data. |




An integer literal in Nim can be represented using decimal, octal, hexadecimal or binary notation.




Listing 2.6. Integer literals




```
let decimal = 42
let hex = 0x42
let octal = 0o42
let binary = 0b101010
```



The example above defines 4 integer variables. It assigns a different integer literal to each of them, using the 4 different integer literal formats. I did not specify a type for any of the variables I have defined. The Nim compiler will infer the correct type based on the integer literal that I have specified. In this case all variables will have the type `int`. The way the compiler determines which integer type to use is by looking at the size of the integer literal. The type is `int64` if the integer literal exceeds the 32 bit range, otherwise it is `int`. What if you want to use a specific integer type for your variable? There are multiple ways to accomplish this. For example:




```
let a: int16 = 42   ❶
let b = 42'i8   ❷
```




|  |  |
| --- | --- |
| [❶](#CO3-1) | Explicitly declaring `decimal` to be of type `int16` |
| [❷](#CO3-2) | Using a *type suffix* to specify the type of the integer literal. |




 





|  |  |
| --- | --- |
| [Warning] | Integer size |
| Explicitly using a small integer type such as `int8` may result in a compile-time or, in some cases, a runtime error. Take a look at the ranges above to see what size of integer can fit into which integer type, you should be careful not to attempt to assign an integer that is bigger or smaller than the type can hold. |



Nim supports type suffixes for all integer types, both signed and unsigned. The format is `'iX` where `X` is the size of the signed integer, and `'uX` where X is the size of the unsigned integer. [[10]](#ftn.d5e1302)


**FLOATING-POINT**


The floating-point type represents an approximation of numerical data with a fractional component. The main floating-point type in Nim is `float`.




Listing 2.7. Float literals




```
let a = 1'f32
let b = 1.0e19
```



The compiler will implicitly use the `float` type for floating-point literals. You can specify the type of the literal using a type suffix. Similar to integer literals, there are 2 type suffixes for floats which correspond to the available floating-point types: `'f32` and `'f64` corresponding to `float32` and `float64` respectively. Exponents can also be specified after the number. Variable `b` in the example will be equal to 1x1019 (1 times 10 to the power of 19).


**BOOLEAN**


The boolean type represents one of two values: usually a true or false value. In Nim the boolean type is called `bool`.




Listing 2.8. Boolean literals




```
let a = false
let b = true
```



The `false` and `true` values of a boolean must begin with a lower case.


**CHARACTER**


The character type represents a single character. In Nim the character type is called `char`, it cannot represent UTF-8 characters but instead encodes ASCII characters. Because of this `char` is really just a number.


A character literal in Nim is a single character enclosed in quotes. The character may also be an escape sequence introduced by a `\` backwards slash.




Listing 2.9. Character literals




```
let a = 'A'
let b = '\109'
let c = '\x79'
```






> Tip Unicode |
| The `unicode` module contains a `Rune` type which can hold any unicode character. |





Table 2.3. Common character escape sequences








| Escape sequence | Result |
|--|--|
| `\r`, `\c` | Carriage return |
| `\l` | Line feed |
| `\t` | Tabulator |
| `\\` | Backslash |
| `\'` | Apostrophe |
| `\"` | Quotation mark |




 





|  |  |
| --- | --- |
| [Warning] | Newline escape sequence |
| Newline `\n` is not allowed in a character literal as it may be composed of multiple characters on some platforms. On Windows, it is `\r\l` (carriage return followed by line feed) whereas on Linux it is just `\l` (line feed). Specify the character you want explicitly, for example `'\r'` to get a carriage return, or use a string. |



**STRING**


The string type represents a sequence of characters. In Nim the string type is called `string`, it is a list of characters terminated by `'\0'`. The string type also stores its length. A string in Nim supports UTF-8, but for processing UTF-8 text the `unicode` module should be used.


There are multiple ways to define string literals.




```
let text = "The book title is \"Nim in Action\""
```


When defining string literals this way, certain characters must be escaped in them. For instance the double-quote character (`"`) should be escaped as `\"` and the backward slash character (`\`) as `\\`. String literals support the same character escape sequences that character literals support, see the above table for a good list of the common ones. One major additional escape sequence that string literals support is `\n` which produces a newline, the actual characters which are produced depend on the platform.


The need to escape some characters makes some things tedious to write. One example is Windows file paths:




```
let filepath = "C:\\Program Files\\Nim"
```


Nim supports raw string literals which do not require escape sequences. Apart from the double-quote character, `"` which still needs to be escaped as `""`, any character placed in a raw string literal will be stored verbatim in the string. A raw string literal is a string literal preceded by an `r`:




```
let filepath = r"C:\Program Files\Nim"
```


It is also possible to specify multi-line strings using triple quoted string literals.




```
let multiLine = """foo
  bar
  baz
"""
echo multiLine
```




Listing 2.10. Output




```
foo
  bar
  baz
```



These string literals may contain any character, including the double-quote character without any escape sequences. Triple quoted string literals are enclosed between three double-quote characters, so your string literal may not repeat the double-quote character 3 times. There is no way to include 3 double-quote characters in a triple quoted string literal.


The indentation added to the string literal defining the `multiLine` variable causes leading whitespace to appear at the start of each line. This can be easily fixed by the use of the `unindent` procedure, it lives in the `strutils` module so you must first import it.




```
import strutils
let multiLine = """foo
  bar
  baz
"""
echo multiLine.unindent
```




Listing 2.11. Output




```
foo
bar
baz
```






2.3.2  Defining variables and other storage
-------------------------------------------



You have already seen some examples of how to define storage using the `let` keyword in the previous section, when I showed you some of the many literals supported by Nim. Storage in Nim is defined using 3 different keywords. In addition to the keyword `let`, which you have already seen used, you can also define storage using `const` and `var`.




```
let number = 10
```


By using the `let` keyword you will be creating what is known as an immutable variable, a variable which can only be assigned to once. In the example above, a new immutable variable named `number` is created, the identifier `number` is bound to the value `10`. If you attempt to assign a different value to this variable your program will not compile:




Listing 2.12. numbers.nim




```
let number = 10
number = 4000
```





Listing 2.13. Output




```
numbers.nim(2, 1) Error: 'number' cannot be assigned to
```



Nim also supports mutable variables using the keyword `var`. Use them if you intend on changing the value of a variable. The example above can be fixed by replacing the `let` keyword with the `var` keyword.




```
var number = 10
number = 4000
```


In both examples, the compiler will infer the type of the `number` variable based on the value assigned to it. In this case `number` will be an `int`. You can specify the type explicitly by writing the type after the variable name and separating it with a colon character (`:`). By doing this you can omit the assignment, which is useful when you don’t want to assign a value to the variable when defining it.





|  |  |
| --- | --- |
| [Warning] | Immutable variables |
| Immutable variables must be assigned a value when they are defined because their values cannot change. This includes both `const` and `let` defined storage. |





```
var number: int
```


A variable’s initial value will always be binary zero, this will manifest in different ways, depending on the type. For example, by default integers will be 0 and strings will be `nil`. `nil` is a special value which signifies the lack of a value for any reference type, more on this later. In the example above `number` will be 0 because it is an integer.


The type of a variable cannot change. For example, assigning a `string` to an `int` variable will result in a compile-time error:




Listing 2.14. typeMismatch.nim




```
var number = 10
number = "error"
```





Listing 2.15. Output




```
typeMismatch.nim(2, 10) Error: type mismatch: got (string) but expected 'int'
```



Nim also supports constants. Because the value of a constant is also immutable, constants are similar to immutable variables defined using `let`. But a Nim constant differs in one important way: their value must be computable at compile-time.




Listing 2.16. Constant example




```
proc fillString(): string =
  result = ""
  echo("Generating string")
  for i in 0 .. 4:
    result.add($i)

const count = fillString()
```






> Tip Procedures |
| Don’t worry about not understanding the details of procedures in Nim yet. You will be introduced to them in the next sub-section. |



The `fillString` procedure in the example above will generate a new string, equal to `"01234"`. The constant `count` will then be assigned this string.


I have added the `echo` at the top of `fillString``s body, in order to show you that it is executed at compile-time. Try compiling the example using Aporia or in a terminal by executing `nim c file.nim`. You will see `"Generating string"` amongst the output. Running the binary will never display that message because the result of the `fillString` procedure is embedded in it.


In order to generate the value of the constant, the `fillString` procedure must be executed at compile-time by the Nim compiler. You have to be aware though that not all code can be executed at compile-time. For example if a compile-time procedure uses the FFI you will find that the compiler will output an error similar to `Error: cannot 'importc' variable at compile time`.


The main benefit of using constants is efficiency. The compiler can compute a value for you at compile-time, saving time which would be otherwise spent at runtime in your program. The obvious downside is longer compilation time but could also be a larger executable size. As with many things, you must find the right balance for your use case. Nim gives you the tools but you must use them responsibly.[[11]](#ftn.d5e1512)


You can also specify multiple variable definitions under the same `var`, `let`, or `const` keyword. To do this add a newline after the keyword and indent the identifier on the next line:




```
var
  text = "hello"
  number: int = 10
  isTrue = false
```


The identifier of a variable is its name. It can contain any characters, as long as the name does not begin with a number and does not contain two consecutive underscores. This applies to all identifiers, including procedure and type names. Identifiers can even make use of unicode characters:




```
var 火 = "Fire"
let ogień = true
```




Stropping



As you may recall from the *Nim Syntax* section, there are identifiers in Nim which are reserved. Such identifiers are called *keywords*, and because they have a special meaning they cannot be used as names for variables, types, or procedures.


In order to get around this limitation you can either, pick a different name, or explicitly mark the identifier using backticks ```. The latter of which is called *stropping*. The listing below shows how it can be used.




```
var `var` = "Hello"
echo(`var`)
```


The `var` keyword is enclosed in backticks allowing a variable with that name to be defined.



Unlike in many other programming languages, identifiers in Nim are case insensitive with the exception of the first letter of the identifier. This is to help distinguish a variable name, which must begin with a lower case letter, from a type name which must begin with an upper case letter.


Identifiers in Nim are also *style insensitive*, this allows identifiers written in `camelCase` to be equivalent to identifiers written in `snake_case`. The way this is accomplished is by ignoring the underscore character in identifiers, thus `fooBar` is equivalent to `foo_bar`. You are free to write identifiers in whichever style you prefer, even when they are defined in a different style. If you want to follow Nim’s style conventions then use `camelCase` for variables and procedures, and `PascalCase` for types.





2.3.3  Procedure definitions
----------------------------



Procedures allow you to separate your program into different units of code. Typically procedures contain code which performs a single task. Having been given some input data, usually in the form of one or more parameters.


In this section we are going to explore procedures in Nim. In other programming languages a procedure may be known as a function, method or subroutine. Each programming language attaches different meanings to these terms, Nim is no exception. A procedure in Nim can be defined using the `proc` keyword, followed by the procedure name, parameters, optional return type, `=`, and the procedure body. Figure 2.11 shows the syntax of a Nim procedure definition.




Figure 2.7. The syntax of a Nim procedure definition


![proc def](../Images/proc_def.png)

The procedure in Figure 2.11 named `myProc` takes one parameter `name` of type `string`, and returns a value of type `string`. The procedure body implicitly returns a concatenation of the string literal `"Hello "` and the parameter `name`.


Calling a procedure is done by writing the name of the procedure followed by parentheses: `myProc("Dominik")`. Any parameters can be specified inside the parentheses. Calling the `myProc` procedure with a `"Dominik"` parameter will cause the string `"Hello Dominik"` to be returned.


Whenever procedures with a return value are called, their result must be used in some way.




```
proc myProc(name: string): string = "Hello " & name
myProc("Dominik")
```


Compiling the above example will result in an error: `file.nim(2, 7) Error: value of type 'string' has to be discarded`. This error occurs as a result of the value returned by the `myProc` procedure being implicitly discarded. In most cases ignoring the result of a procedure is a bug in your code, the result could describe an error that occurred or give you a piece of vital information. You will likely want to do something with the result, for example store it in a variable or pass it to another procedure via a call. In cases where you really do not want to do anything with the result of a procedure, you can use the `discard` keyword to tell the compiler to be quiet:




```
proc myProc(name: string): string = "Hello " & name
discard myProc("Dominik")
```





|  |  |
| --- | --- |
| [Warning] | Order of procedures |
| It is important to note that the order of procedures and procedure calls matters. When calling a procedure, it must be defined above the call site like in the example above. This will likely be changed in a future version of Nim. |



The `discard` keyword simply lets the compiler know that you are happy to ignore the value that the procedure returns.


When a procedure returns no values, the return type can be omitted. In that case the procedure is said to return `void`. The following are two examples of writing procedures which return no value:




```
proc noReturn() = echo("Hello")
proc noReturn2(): void = echo("Hello")
```


It is idiomatic to avoid writing the redundant `void` in procedure definitions. The special `void` type is useful in other contexts, for example generics which you will learn about in *Chapter 9*.


Nim allows you to cut down on unnecessary syntax even further. If your procedure takes no parameters you can omit the parenthesis:




```
proc noReturn = echo("Hello")
```


**Returning values from procedures**


Earlier in this section I have mentioned that the body of the `myProc` procedure implicitly returns the string value, it is implicit because no `return` keyword is used.


A procedure body can contain multiple statements, separated either by a semicolon or a newline character. In the case where the last expression of a procedure has a non-void value associated with it, that expression will be implicitly returned from that procedure. You can always use the `return` keyword as the last statement of your procedure if you wish, but doing so is not idiomatic or necessary. The `return` keyword is still necessary for early returns from a procedure. The following code listing shows different examples of returning values from procedures.




```
proc implicit: string =
  "I will be returned"

proc discarded: string =
  discard "I will not be returned"

proc explicit: string =
  return "I will be returned"

proc resultVar: string =
  result = "I will be returned"

proc resultVar2: string =
  result = ""
  result.add("I will be ")
  result.add("returned")

proc resultVar3: string =
  result = "I am the result"
  "I will cause an error"

assert implicit() == "I will be returned"
assert discarded() == nil
assert explicit() == "I will be returned"
assert resultVar() == "I will be returned"
assert resultVar2() == "I will be returned"
# resultVar3 does not compile!
```





> Note Assert |
| The code listing above uses `assert` to show you the output that you should expect when calling each of the defined procedures. You will learn more about `assert` when it comes time to test your code in the later sections of this book. |



Just like a variable’s default value, a procedure’s return value will be binary zero by default. Nim actually supports a lot of different methods of setting the return value, and you are free to combine them.


Every procedure with a return type that is not `void`, has a `result` variable declared inside its body implicitly. This `result` variable is mutable and is of the same type as the procedure’s return type. It can be used just like any other variable. The 2 different `resultVar` procedures show some examples of how to take advantage of this variable. You should make use of it whenever you can, instead of defining your own variable and then returning it explicitly.


There are some restrictions when combining implicit returns and the usage of the `result` variable. These restrictions prevent ambiguities from occurring. In the `resultVar3` procedure, what should be returned, the last expression or the value that `result` was assigned? The compiler does not choose for you, it simply tells you to correct the ambiguity by showing an error.


So far I have been explicitly specifying the return type of procedures. You may recall that this is not necessary for variable definition. It is also possible to ask the compiler to infer the return type of your procedure for you. In order to do this you need to use the `auto` type.




```
proc message(recipient: string): auto =
  "Hello " & recipient

assert message("Dom") == "Hello Dom"
```


While this is handy, you should specify the type explicitly whenever possible. This makes it easier for you and others to determine the return type of a procedure, without needing to understand the procedure’s body.





|  |  |
| --- | --- |
| [Warning] | Type inference |
| Type inference for procedures is still a bit experimental in Nim. You may find that it is limited in some circumstances, especially if you are used to more advanced forms of type inference such as those found in Haskell or OCaml. |



**Procedure parameters**


A procedure with multiple parameters can be defined by, listing the parameters and separating them using the comma character.




```
proc max(a: int, b: int): int =
  if a > b: a else: b

assert max(5, 10) == 10
```


You don’t need to repeat the type of parameters if they are specified consecutively:




```
proc max(a, b: int): int =
  if a > b: a else: b
```


Default parameters can be used to ask for arguments which can be optionally specified at the call site. Default parameters are introduced by assigning a value to a parameter using the equals character, the type can also be omitted in that case:




```
proc genHello(name: string, surname = "Doe"): string =
  "Hello " & name & " " & surname

assert genHello("Peter") == "Hello Peter Doe"              ❶
assert genHello("Peter", "Smith") == "Hello Peter Smith"   ❷
```




|  |  |
| --- | --- |
| [❶](#CO4-1) | In this case the default value for the `surname` argument is used. |
| [❷](#CO4-2) | In this case the default value is overriden with the string literal `"Smith"`. |




A procedure taking a variable number of parameters can be specified using the `varargs` type:




```
proc genHello(names: varargs[string]): string =
  result = ""          ❶
  for name in names:   ❷
    result.add("Hello " & name & "\n")   ❸

assert genHello("John", "Bob") == "Hello John\nHello Bob\n"
```




|  |  |
| --- | --- |
| [❶](#CO5-1) | Initialise the result variable with a new string. |
| [❷](#CO5-2) | Iterate through each of the arguments. You will learn more about for loops in the *Control Flow* section. |
| [❸](#CO5-3) | Add the string `"Hello"` concatenated with the current argument and a newline character to the `result` variable. |




**Procedure overloading**


The act of overloading a procedure is a feature that you may not have come across yet, but one which is commonly used in Nim. Procedure overloading is the ability to define different implementations of procedures with the same name. Each of these procedures share the same name but accept different parameters. Depending on the arguments passed to the procedure, the appropriate one is picked by the compiler.


As an example, consider a `getUserCity` procedure. It may take two parameters: a `firstName` and `lastName`.




```
proc getUserCity(firstName, lastName: string): string =
  case firstName
  of "Damien": return "Tokyo"
  of "Alex": return "New York"
  else: return "Unknown"
```





> Note Case statements |
| Case statements might still be new to you, they will be explained later in the *Control Flow* section. |



This kind of procedure may be used to retrieve a person’s city of residence from a database based on the name specified. You may also wish to offer an alternative, something more unique such as an ID number. To do this you can overload the `getUserCity` procedure like so:




```
proc getUserCity(userID: int): string =
  case userID
  of 1: return "Tokyo"
  of 2: return "New York"
  else: return "Unknown"
```


This way you can reuse the name, but are still able to use the different implementations. As shown here:




```
doAssert getUserCity("Damien", "Lundi") == "Tokyo"
doAssert getUserCity(2) == "New York
```


**Anonymous procedures**


Sometimes you may wish to pass procedures as parameters to other procedures. To do this, you can create a procedure at the call site and pass it to the procedure that you are calling. The following code listing shows how this can be done.




```
import sequtils
let numbers = @[1, 2, 3, 4, 5, 6]   ❶
let odd = filter(numbers, **proc (x: int): bool = x mod 2 != 0**)   ❷
assert odd == @[1, 3, 5]            ❸
```




|  |  |
| --- | --- |
| [❶](#CO6-1) | Definition of an immutable variable holding a list of numbers. |
| [❷](#CO6-2) | The `filter` procedure used to filter out even numbers. |
| [❸](#CO6-3) | Assertion to show the output. |




 





> Note The `@` symbol |
| The `@` symbol creates a new sequence, you will learn about more about it in the next section. |



These procedures are aptly named *anonymous procedures*, because there is no name associated with them. In the above example the anonymous procedure is highlighted in bold.


The anonymous procedure gets a single parameter `x` of type `int`, this parameter is one of the items in the `numbers` sequence. The job of this anonymous procedure is to determine whether that item should be filtered out or whether it should remain. When the procedure returns `true` then the item is not filtered out.


The `filter` procedure is the one doing the actual filtering, it takes two parameters: a sequence and an anonymous procedure. It then iterates through each item and uses the anonymous procedure it got, to see whether to filter the item out or to keep it. The `filter` procedure then returns a new sequence, which includes only the items which the anonymous procedure determined should be kept and not filtered out.


In the case of the example above, the resulting sequence will only contain odd numbers. This is reflected in the anonymous procedure, which checks whether dividing each item by 2 results in a remainder. If a remainder is produced then `true` is returned because that means the number is odd.


The syntax for anonymous procedures is a bit cumbersome. Thankfully Nim supports some syntactic sugar for defining anonymous procedures, as well as procedure types. In order to use the syntactic sugar, you must import the `future` module. The syntax sugar is not part of the language but is instead defined in the standard library. This is achieved using macros which you will learn about later on in *Chapter 9*.


Compare the original and note the differences shown in bold.




```
import sequtils
let numbers = @[1, 2, 3, 4, 5, 6]   ❶
let odd = filter(numbers, **proc (x: int): bool = x mod 2 != 0**)   ❷
assert odd == @[1, 3, 5]            ❸
```




```
import sequtils, **future**
let numbers = @[1, 2, 3, 4, 5, 6]
let odd = filter(numbers, **(x: int) -> bool => x mod 2 != 0**)
assert odd == @[1, 3, 5]
```


The syntax sugar doesn’t actually make the definition that much shorter, but it does still remove some of the noise. It can be shortened further using type inference: `x => x mod 2 != 0`. But keep in mind that in some cases this may not work. The compiler may not be able to infer the types for your anonymous procedure. In that case, you will need to explicitly state the types. The example above uses the `->` symbol to specify the types.





> Tip Documentation |
| The documentation for each module contains links under each procedure definition to the source code for that procedure. Take a look at it to learn more about the procedures mentioned in this book. The documentation is available on Nim’s website: <http://nim-lang.org/> |



The `->` symbol can also be used stand-alone in place of procedure types. For example, when defining a procedure which takes another procedure as a parameter.




```
proc isValid(x: int, validator: **proc (x: int): bool**) =
  if validator(x): echo(x, " is valid")
  else: echo(x, " is NOT valid")
```




```
import future
proc isValid(x: int, validator: **(x: int) -> bool**) =
  if validator(x): echo(x, " is valid")
  else: echo(x, " is NOT valid")
```


The `proc` keyword can be omitted and the `:` is replaced by the `->` symbol.


This ends the "Nim basics" section. You have now read a large proportion of this chapter, and so far it was very heavy with information. Don’t worry if you don’t remember everything that you’ve read or you don’t understand some concepts, the next chapter will put these ideas into practice and solidify your knowledge. Feel free to go back over what you’ve read so far at any time. For now let us move on to the next section.




  


[[10]](#d5e1302) <http://nim-lang.org/docs/manual.html#lexical-analysis-numerical-constants>




[[11]](#d5e1512) With great power comes great responsibility







2.4  Collection types
=====================



Collections such as lists, arrays, sets and more are incredibly useful. In this section I will talk about the three most commonly used collection types in Nim; the `array`, `seq`, and `set` types.


**Array**


The `array` type represents a list of a static amount of items. This type is similar to C arrays, but offers more memory safety as shown in the following example:




```
var list: array[3, int]
list[0] = 1
list[1] = 42
assert list[0] == 1
assert list[1] == 42
assert list[2] == 0   ❶

echo list.repr   ❷

echo list[500]   ❸
```




|  |  |
| --- | --- |
| [❶](#CO7-1) | The array contains 3 elements, any elements which have not been set are given a default value. |
| [❷](#CO7-2) | Will output: `[1, 42, 0]`. The `$` is not currently defined for arrays, so `repr` must be used. The `repr` procedure converts any variable into a string, but the resulting string sometimes contains debug information like the memory address of the variable. |
| [❸](#CO7-3) | Compilation will fail with: "Error: index out of bounds" |




Arrays are value types, just like `int`, `float` and many others. This means that they are allocated on the stack. This is similar to C arrays, but differs completely from Java’s arrays which are reference types and are stored on the heap.


Arrays are static in size, so an array cannot change its size once after it is declared. This is why the compiler can give us an error when we try to access an index outside its bounds. In C, checks for index bounds are not made and so it is possible to access memory that is outside the bounds of the array. Nim performs these checks at compile-time and at runtime. The runtime checks are performed as long as the `--boundsChecks` option is not turned off.





|  |  |
| --- | --- |
| [Warning] | The `-d:release` flag |
| Compiling with the `-d:release` flag will turn the bounds checks off. This will result in higher performance but less safety. |





Note about array bounds



It is possible to define arrays with a custom range. By default they range from `0` to the number specified in the array type, but you can also specify the lower bound:





Listing 2.17. Array of 2 integers




```
var list: array[-10 .. -9, int]
list[-10] = 1
list[-9] = 2
```


This is useful when your array indices do not start at 0.



An array constructor can be used to assign a list of items to the array at the site of its definition:




```
var list = ["Hi", "There"]
```


You can iterate over most collection types using a for loop. Iterating over a collection type will yield a single item from the collection during each iteration. If you prefer to iterate over each index rather than each item, you can access an array’s bounds using the `low` and `high` fields and then iterate from the lowest index to the highest:




```
var list = ["My", "name", "is", "Dominik"]
for item in list:                 ❶
  echo(item)

for i in list.low .. list.high:   ❷
  echo(list[i])
```




|  |  |
| --- | --- |
| [❶](#CO8-1) | Loop through each item |
| [❷](#CO8-2) | Loop through each index |




**Sequences**


Arrays are static in size. You cannot add more items to them, you can only overwrite existing items with new data. This is where Nim’s sequences come in, they are dynamic in size and can grow to as many items as needed. As long as your memory permits it.


You have already seen examples of sequences in the previous section. You will find more details in this section.


Sequences are defined using the `seq` type:




```
var list: seq[int] = @[]
list[0] = 1     ❶

list.add(1)     ❷

assert list[0] == 1
echo list[42]   ❸
```




|  |  |
| --- | --- |
| [❶](#CO9-1) | Assign `1` to the first item in the sequence. This will result in an index out of bounds exception at runtime because there are currently no items in the sequence. |
| [❷](#CO9-2) | Append `1` as an item to the `list` sequence. |
| [❸](#CO9-3) | Attempt to access an item which does not exist, an index out of bounds exception will be raised. |




Sequences are stored on the heap and as such are garbage collected. This means that they need to be initialized before they are used, just like strings.




```
var list: seq[int]
echo(list[0])
```


Accessing the items of an uninitialized sequence will result in a segmentation fault at runtime. Copy the code listing above into your favourite text editor and save it as `segfault.nim`, then compile and run it. If you’re using Aporia just press F5, or just open a terminal and execute `nim c -r segfault.nim`. You should see that your program crashes with the following output:




```
Traceback (most recent call last)
segfault.nim(2)          segfault
SIGSEGV: Illegal storage access. (Attempt to read from nil?)
```


As long as your program is not compiled in release mode, any crashes will display a traceback which shows you the procedure calls leading up to your program’s crash. In this case the number in the parentheses corresponds to line 2 in the source code, `echo(list[0])`. This hints that `list` is `nil`, and that it must be initialized. You will learn a lot more about this type of error later in the book.


A sequence can be initialized in two ways: using the sequence constructor syntax (`@[]`) which is used in the example above, and using the `newSeq` procedure. Each is more or less appropriate depending on the use case.





|  |  |
| --- | --- |
| [Warning] | The sequence constructor |
| When using the empty sequence constructor you must be careful to specify the type of the sequence.


```
var list = @[]
```


The example above will not work because the compiler has no way of knowing what type of sequence you want to define! This is not a problem when you are constructing a non-empty sequence: `var list = @[4, 8, 15, 16, 23, 42]`. Because the compiler knows that the sequence type is `seq[int]`. |



The `newSeq` procedure provides another way to construct a sequence. It is also an important optimisation, you should use it when you know the size of the sequence you are going to be creating ahead of time.




```
var list = newSeq[string](3)
assert list[0] == nil   ❶
list[0] = "Foo"   ❷
list[1] = "Bar"
list[2] = "Baz"

list.add("Lorem")   ❸
```




|  |  |
| --- | --- |
| [❶](#CO10-1) | The items will exist but will not be initialized. |
| [❷](#CO10-2) | You can assign new values to them easily. |
| [❸](#CO10-3) | The `seq` can still grow in size, new items can be added. |




The size of the sequence that you specify in the call to `newSeq` will correspond to the amount of items that the new sequence will contain. The items themselves will not be initialized, and you may still add more items to the sequence if you wish.


Iterating over a sequence is done in the same way as iterating over an array. One thing you should note when iterating over the index of sequences is, that while sequences do have a `low` and `high` field, it’s more idiomatic to use the `len` field which gives you the length of the sequence. Because unlike arrays the `low` field is always 0.




```
let list = @[4, 8, 15, 16, 23, 42]
for i in 0 .. <list.len:
  stdout.write($list[i] & " ")
```




Listing 2.18. Output




```
4 8 15 16 23 42
```



The range of iteration is inclusive, so we must subtract 1 from the length of the sequence in order to iterate fewer times. This is achieved by prefixing it with the `<` operator, you can also simply subtract 1 but using the `<` operator is more idiomatic.


You have already seen an example of manipulating sequences using the `filter` procedure. You can find more procedures which manipulate sequences both in the `system` and `sequtils` modules.


**Sets**


The third collection type that I will show you is the `set` type. The `set` type stores a collection of distinct values. A `set[int16]` for example stores a distinct collection of integers. But because of the nature of sets, only unique numbers can be stored.


A Nim set’s base type must be an ordinal type. An ordinal type is a type with values which can be counted. The `char` type is ordinal because there is a clear order for its values; `'A'` is followed by `'B'`, `'B'` is followed by `'C'` and so on. A `string` is not an ordinal type because there is no clear order for its values.


This restriction only applies to the built-in `set` type. There is also another set type in the `sets` module called `HashSet` which supports any type as its base type. But the built-in `set` type is more efficient and thus should be used whenever possible.


The `set` type is a value type and so does not need to be initialized.




```
var collection: set[int16]
assert collection == {}
```


A set is constructed using `{}`. A list of values is specified inside the curly brackets and each item is separated by a comma.


A set pays no attention to the order of the items that it stores, so you cannot access items in it via an index. Sets are useful for cases where you want to check for the presence of a certain value in a collection, this is where the `in` keyword comes in.




```
let collection = {'a', 'x', 'r'}
assert 'a' in collection
```


While simple, sets can be used to perform some interesting checks.




```
let collection = {'a', 'T', 'z'}
let isAllLowerCase = {'A' .. 'Z'} * collection == {}
assert(not isAllLowerCase)
```


One of the operations that can be performed on sets is the intersection of two sets using the `*` operator. This returns a new set containing the values which the intersected sets have in common. I use this to check whether the set `collection` contains any uppercase letters. A set constructor can contain ranges of items too, in the example above the range `'A' .. 'Z'` is deduced by the compiler to contain all the upper case letters.


Sets are often used in the standard library to represent a collection of unique flags. In other languages such as C this may be represented by an integer, which is interpreted as a sequence of boolean bits. In comparison to sets, this approach is very unsafe and often leads to errors.


I now encourage you to experiment with these collection types to gain a deeper insight into how they work. You will be using the types throughout this book and throughout your time writing Nim programs.





2.5  Control Flow
=================



There are many ways to control the flow of execution in Nim. The most common is the if statement, which you have already seen in action in the *Nim Syntax* section of this chapter.


The if statement is a conditional statement, when its condition is true its body is executed. Nim’s if statement is similar to the if statement in other languages. It supports multiple "else if" blocks specified using the `elif` keyword and an "else" block using the `else` keyword.




```
if age > 0 and age <= 10:
  echo("You're still a child")
elif age > 10 and age < 18:
  echo("You're a teenager")
else:
  echo("You're an adult")
```


Switch statements are also supported, although in Nim they are known as case statements because they begin with the `case` keyword. They reduce repetition when you need to handle many different conditions.




```
case variable
of "Arthur", "Zaphod", "Ford":
  echo("Male")
of "Marvin":
  echo("Robot")
of "Trillian":
  echo("Female")
else:
  echo("Unknown")
```


Where the case statement differs from other languages is in the lack of fallthrough, which is present in many languages derived from C. An `of` branch in a case statement can contain a list of values to be matched, as well as a range similar to the ones used in set constructors. For example, matching every number from 0 to 9 can be done like this: `of 0 .. 9:`.


In Nim every statement can be an expression. One case where this is useful is when you wish to assign a value depending on a condition:




```
let ageDesc = if age < 18: "Non-Adult" else: "Adult"
```


You can use the case statement as an expression in a similar way.


The flow of your program can also be controlled using loops. There are two looping statements in Nim. You have already seen examples of one of them: the for loop. There is also a while loop that you can use.


The while loop is the most basic of the looping statements. It consists of a condition which gets evaluated before each loop, if that condition is `true` the loop continues.




```
var i = 0      ❶
while i < 3:   ❷
  echo(i)      ❸
  i.inc        ❹
```




|  |  |
| --- | --- |
| [❶](#CO11-1) | Declare a new mutable variable and assign it the value `0`. |
| [❷](#CO11-2) | Loop while the variable `i` is less than `3`. |
| [❸](#CO11-3) | Display the current value of the variable `i`. |
| [❹](#CO11-4) | Increment the `i` variable (add 1 to its current value). |






Listing 2.19. Output




```
0
1
2
```



Just like in other languages, the `continue` and `break` keywords allow you to control a loop. The `continue` keyword will skip the current iteration, and restart from the top of the loop body. The `break` keyword will end the iteration.


You can also nest looping statements. If you do so you may find that you cannot easily `break` out of both of the loops at once. You can specify a label to the `break` keyword, a label is introduced with the `block` keyword, the execution will then resume after the body of the `block`.




```
block label:
  var i = 0
  while true:                 ❶
    while i < 5:              ❷
      if i > 3: break label   ❸
      i.inc                   ❹
                              ❺
```




|  |  |
| --- | --- |
| [❶](#CO12-1) | This loop will iterate forever. |
| [❷](#CO12-2) | Loop while variable `i` is less than 5. |
| [❸](#CO12-3) | Once `i` is greater than 3, jump out of the block named `label`. |
| [❹](#CO12-4) | Increment the variable `i`. |
| [❺](#CO12-5) | Execution will resume here once `break label` is called. |




The `block` keyword can also be used to introduce a new scope.


Nim supports a concept of iterators. These are similar to procedures, but they use the `yield` keyword to return multiple values. The for statement uses iterators for each loop iteration, an iteration occurs when the iterator being called yields a new value.


The for loop is most commonly used to iterate over a list of values. There are many general iterators which work on sequences and other collection types, but also specific iterators like the `walkFiles` iterator. The `walkFiles` iterator, when given a pattern, iterates over the files in the current directory that match that pattern. For example, in order to find all the files ending with a `.nim` extension in the current directory, you would do something like this:




```
import os          ❶
for filename in walkFiles("*.nim"):   ❷
  echo(filename)   ❸
```




|  |  |
| --- | --- |
| [❶](#CO13-1) | Import the `os` module which defines the `walkFiles` iterator. |
| [❷](#CO13-2) | Iterate over each file name with the `.nim` extension. |
| [❸](#CO13-3) | Display the file name during each iteration. |




The for loop in Nim is most similar to Python:




Figure 2.8. For loop syntax in Nim


![for loop](../Images/for_loop.png)

In Python you can iterate over any object that defines the `__iter__` method, this can be done implicitly without needing to call the `__iter__` method in the for loop. Nim supports a similar mechanism:




```
for item in @[1, 2, 3]:
  echo(item)
```


In the above example, Nim will implicitly call an iterator by the name of `items`. The specific `items` iterator that will be called will depend on the type of the value specified after the `in` keyword, in this case it is `seq[int]`.


If an `items` iterator that matches the type cannot be found, then the compilation will fail with a type mismatch error:




```
for i in 5:
  echo i
```




Listing 2.20. Compilation output




```
file.nim(1, 10) Error: type mismatch: got (int literal(5))
but expected one of:
system.items(a: array[IX, T])
system.items(E: typedesc[enum])
system.items(s: Slice[items.T])
system.items(a: seq[T])
system.items(a: openarray[T])
system.items(a: string)
system.items(a: set[T])
system.items(a: cstring)
```



You will learn how to define your own iterators later in this book.


The `items` iterator is only invoked whenever you specify one variable in the for loop, a `pairs` iterator is invoked for two variables. The values that the `pairs` iterator typically returns are the current iteration index and the current item at that index:




```
for i, value in @[1, 2, 3]: echo("Value at ", i, ": ", value)
```




Listing 2.21. Output




```
Value at 0: 1
Value at 1: 2
Value at 2: 3
```



There is no default name for an iterator yielding three values or more.





2.6  Exception handling
=======================



Exceptions are yet another method of controlling flow. Raising an exception will cause the execution of a program to cease until the exception is caught or the program exits.


Handling exceptions in Nim is very similar to Python. Exceptions are caught using a try statement, with one or more `except` branches specifying the exception type to be handled.


A new exception is raised using the `raise` keyword. An exception is an object consisting of a message describing the error that occurred. You can create new exceptions using the `newException` procedure. One of the most powerful features of Nim are its brilliant tracebacks, when an exception is raised and never caught your program will display a a stack traceback and quit:




Listing 2.22. Raising an exception




```
proc second() =
  raise newException(IOError, "Somebody set us up the bomb")

proc first() =
  second()

first()
```





Listing 2.23. Output




```
Traceback (most recent call last)
file.nim(7)              file
file.nim(5)              first
file.nim(2)              second
Error: unhandled exception: Somebody set us up the bomb [IOError]
```



A traceback gives us a list of events leading up to the crash of our program. It is a very useful debugging tool. Each line in the traceback is a call to a procedure, the number in the parentheses is the line number where the call was made, and the name on the right is the procedure that was called.


These tracebacks will be your best friend throughout your time working with the Nim programming language.


In order to stop your program from crashing you must handle the exceptions, and decide what your program should do when these exceptions occur. You can handle exceptions by wrapping the affected code in a try statement. The top part of a try statement consists of the `try` keyword, followed by a colon which is then followed by indented code. The bottom of a try statement consists of one or more `except` branches. Each `except` branch matches a specific exception that should be caught, if the `except` branch omits the exception type then all exceptions are caught. When an exception is matched the corresponding `except` branches' code is executed.




Listing 2.24. The try statements




```
try:
    ❶
except ErrorType:
    ❷
except:
    ❸
```




|  |  |
| --- | --- |
| [❶](#CO14-1) | The code statements which will be checked for exceptions. |
| [❷](#CO14-2) | The code statements which will be executed when the code under the `try` raises an `ErrorType` exception. |
| [❸](#CO14-3) | The code statements which will be executed when the code under the `try` raises another type of exception. |





Let’s rewrite *Listing 2.24* to handle the exception by using a try statement.




Listing 2.25. Handling an exception using a try statement




```
proc second() =
  raise newException(IOError, "Somebody set us up the bomb")   ❶

proc first() =
  try:      ❷
    second()
  except:   ❸
    echo("Cannot perform second action because: " &            ❹
      getCurrentExceptionMsg())   ❺

first()
```




|  |  |
| --- | --- |
| [❶](#CO15-1) | Raise a new `IOError` exception. |
| [❷](#CO15-2) | The `try` statement will catch any exceptions raised in its body. |
| [❸](#CO15-3) | Catch all exceptions. |
| [❹](#CO15-4) | Display a message stating that the second action could not be performed, and displaying the message of the exception that was caught. |
| [❺](#CO15-5) | The `getCurrentExceptionMsg()` procedure returns the message of the exception that was just caught. |







Listing 2.26. Output




```
Cannot perform second action because: Somebody set us up the bomb
```



The exception is raised in the `second` procedure. But because it is called under the `try` statement, the exception is caught. The `except` branch is then executed leading to the output shown above.


You should now know the basics of exception handling in Nim and be able to debug and handle simple exceptions on your own. Exceptions are a very important feature of the Nim programming language. Your knowledge of exceptions will be continually expanded throughout this book.





2.7  User defined types
=======================



The ability to define custom data structures is essential in many programming languages. Defining them in Nim is simple, and while they support some OOP features their semantics do not unnecessarily bog you down in any OOP concepts.


A basic object definition in Nim is equivalent to a C struct type, and can be passed to C via the FFI. All types are defined under a `type` section. An object definition can be placed under the `type` keyword or alongside it. The definition starts with the name of the type, followed by `=`, the `object` keyword, a new line and then an indented list of fields:




```
type
  Person = object
    name: string
    age: int
```


A `type` section can define multiple types, and you should collect related types under it. Just like procedures, types must be defined above the code in which they are used.


A variable utilising the `Person` type defined above can be declared just like any other variable:




```
var person: Person
```


We can initialize the `Person` type using the object construction syntax:




```
var person = Person(name: "Neo", age: 28)
```


You can specify all, some or none of the fields. The type is an `object` so its memory will be allocated on the stack. Because any instances of this type live on the stack they cannot be `nil`, just like other types that live on the stack.


Whenever defining a new variable, you cannot change where exactly it is allocated. You must change the type definition itself. You can use the `ref object` keywords in order to define a data type which will live on the heap.


Types defined with the `ref` keyword are known as reference types, because when they are passed as parameters to a procedure they are never copied but are always passed by reference. This allows you to modify the original data stored in the passed variable from inside your procedure. A non-`ref` type passed as a parameter to a procedure is immutable and cannot be modified.




Listing 2.27. Mutable and immutable parameters




```
type
  PersonObj = object          ❶
    name: string
    age: int
  PersonRef = ref PersonObj   ❷

proc setName(person: PersonObj) =
  person.name = "George"      ❸

proc setName(person: PersonRef) =
  person.name = "George"      ❹
```




|  |  |
| --- | --- |
| [❶](#CO16-1) | When both non-ref and ref types are defined, the convention is to use an `Obj` suffix for the non-ref name and a `Ref` suffix for the ref name. |
| [❷](#CO16-2) | In this case you don’t need to repeat the definition. |
| [❸](#CO16-3) | This will fail, you cannot modify a non-ref parameter as it might have been copied before being passed to the procedure. The parameter is said to be immutable. |
| [❹](#CO16-4) | This will work because `PersonRef` is defined as a ref. |





The code listing above gives you a small taste of the behavior that ref and non-ref types exhibit. It also introduces the syntax used to access the fields of an object and to assign new values to these fields.


Objects are not the only way to define data types. There are two other kinds of types: tuples and enums. Tuples are similar to objects, the key difference is that they use structural typing whereas objects use nominative typing.




Nominative vs. structural typing



The key difference between nominative typing and structural typing is the way in which equivalence of types is determined.


Consider the following example.




```
type
  Dog = object
    name: string

  Cat = object
    name: string

let dog: Dog = Dog(name: "Fluffy")
let cat: Cat = Cat(name: "Fluffy")

echo(dog == cat)   ❶
```




|  |  |
| --- | --- |
| [❶](#CO17-1) | `Error: type mismatch: got (Dog, Cat)` |




The compiler gives an error because the `Dog` and `Cat` types are not equivalent. This is because they have been defined separately with two different names.


Let’s replace the `object` with `tuple`.




```
type
  Dog = tuple
    name: string

  Cat = tuple
    name: string

let dog: Dog = (name: "Fluffy")
let cat: Cat = (name: "Fluffy")

echo(dog == cat)   ❶
```




|  |  |
| --- | --- |
| [❶](#CO18-1) | `true` |




In this case the compiler is happy to compile this code. The resulting executable displays the message `true`, because the `dog` and `cat` variables contain the same data. The compiler does not look at the names of the types, instead it looks at their structure to determine that they are equivalent.


That is the fundamental difference between tuples and objects.



There are many different ways that tuples can be defined. The two of the most compact ways are shown in the following code listing.




```
type
  Point = tuple[x, y: int]
  Point2 = (int, int)
```


You will note that a tuple does not need to define the names of its fields. As long as the order and type of the values in two tuple types matches, then they are equivalent.




```
let pos: Point = (x: 100, y: 50)
doAssert pos == (100, 50)
```


When a tuple’s fields have no names you can still access them by using the indexing operator: `[]`. When a name is defined then the fields can be accessed in the same way that object fields can be accessed.


Nim also supports *tuple unpacking*. A tuple’s fields can be assigned directly to multiple identifiers. For example:




```
let pos: Point = (x: 100, y: 50)
let (x, y) = pos      ❶
let (left, _) = pos   ❷
doAssert x == pos[0]
doAssert y == pos[1]
doAssert left == x
```




|  |  |
| --- | --- |
| [❶](#CO19-1) | You can specify any name, as long as the number of fields on the left of the equals sign is the same as the number of fields in the tuple. |
| [❷](#CO19-2) | You can use a single `_` (underscore) in order to discard fields. |




Tuples are useful for lightweight types with few fields, they are most commonly used as a way to return multiple values from procedures.


An enum or enumerated type is the third and final type that I will introduce to you in this section. It is very similar to ANSI C’s enums. An enum defines a collection of identifiers which have some meaning attached to them. In Nim enums have an order attached to them, which means they are ordinal types and can be used in case statements and as the base type of sets.




Listing 2.28. Enumerator type




```
type
  Color = enum
    colRed,
    colGreen,
    colBlue

let color: Color = colRed
```



In the above code listing I define a new Color enum. You will note that when specifying the values from this enum you do not need to prefix them with the name of this enum. I have added a prefix to each value to make them a little bit more distinguishable. There is a pragma called `pure` which makes it mandatory to prefix each of the enum’s values with the name of that enum followed by a dot.




```
type
  Color {.pure.} = enum
    red, green, blue

let color = Color.red
```


Depending on your use case you may wish to prefix the enum values manually with something that is shorter than the enum’s name, or you can let Nim enforce the prefix automatically with the `pure` pragma.


Enums can be used to create a collection of meaningful identifiers and they are most commonly used to denote flags.


This section gave you a small taste of the different ways that types can be defined in Nim. Nim’s type system is very powerful and this was by no means an extensive description of it all.





2.8  Summary
============




* The Nim compiler can be downloaded from the Nim website.
* Nim uses indentation to delimit scope and `#` for comments.
* The basic types include `int`, `float`, `char`, `string` and `bool`.
* Mutable and immutable variables can be defined using the `var` and `let` keywords respectively.
* A value assigned to a constant must be computable at compile-time.
* Procedures are defined using the `proc` keyword.
* The `result` variable is implicitly defined in every procedure with a return type.
* An array stores a constant amount of items.
* A sequence can grow dynamically at runtime.
* The flow of your application can be controlled via the `if` or `case` statement.
* One or more statements can be executed multiple times with the `while` statement.
* Collection types can be iterated through using the `for` statement.
* A `try` statement can be used to handle exceptions at runtime.
* Multiple different data types can be defined under a single `type` section.
* Non-reference types cannot be modified from inside a procedure.
* Tuples can be used to return multiple values from a single procedure.





