

1
=


Why Nim?
========


This chapter covers:



* Why should you learn Nim?
* Comparison to other programming languages
* Use cases
* Strengths and weaknesses



Nim is still a relatively new programming language. In fact, you are holding one of the very first books about it. The language is still not fully complete, but core aspects like its syntax, the semantics of procedures, methods, iterators, generics, templates, and more are all set in stone. Despite this, there has been a significant interest in Nim from the programming community, because of the unique set of features that it implements and offers to its users.


This chapter includes answers to questions that you may ask before learning Nim, such as why you might want to use it. I will, among other things, outline some of the common practical uses of Nim, compare it to other programming languages and discuss some of its strengths and weaknesses. Towards the end I will also briefly discuss the type of reader that this book has been written for.




1.1  What is Nim?
=================



Nim is a general-purpose programming language designed to be efficient, expressive and elegant. All three of these goals are difficult to achieve at the same time, so the designers of Nim have given each of them different priorities. Efficiency being the most important and elegance being the least.


Despite the fact that elegance is relatively unimportant to Nim’s design, it is still considered during the design process. Because of this, the language remains elegant in its own right. It is only when trade-offs between efficiency and elegance need to be made, that efficiency wins.


On the surface, Nim shares many of Python’s characteristics. In particular many aspects of its syntax, including the use of indentation to delimit scope as well as the tendency to use words instead of symbols for certain operators. There are also other aspects not related to the syntax, for example the highly user friendly exception tracebacks as shown below.




```
Traceback (most recent call last)
request.nim(74)          request
request.nim(25)          getUsers
json.nim(837)            []
tables.nim(147)          []
Error: unhandled exception: key not found: totalsForAllResults [KeyError]
```


But there are also many differences. Especially when it comes to the semantics of the language. The major differences lie within the type system and execution model which you will learn about in the next sections.




A little bit about Nim’s history



The development of Nim was started in 2005 by Andreas Rumpf. It wasn’t long before the project gained support and mamy contributions from the open source community, with many volunteers around the world contributing code via pull requests on GitHub. [[1]](01_split_000.html#ftn.d5e27)






> Tip Contributing to Nim |
| The compiler, standard library and related tools are all open source and written in Nim. The project is available on GitHub, and everyone is encouraged to contribute. Contributing to Nim is a good way to learn how it works and to contribute to its development. |





1.1.1  Use cases
----------------



Nim was designed to be a general purpose programming language from its inception. As such, it consists of a wide range of features to make it usable for just about any software project. This design makes it a good candidate for writing software in a wide variety of application domains ranging from web applications to kernels.


Whilst it may support practically any application domain, this does not make it the right choice for everything. Certain aspects of the language make it more suitable for some categories of applications than others. This does not mean that these applications cannot be written using Nim; it just means that Nim may not support the code styles that are well suited for writing those kinds of applications.


One feature of the language makes it particularly well suited to systems programming. You will find that Nim is a compiled language, but the way in which it is compiled is special. When source code is compiled by the Nim compiler, it is first translated into C code. C is a pretty old but well supported systems programming language; because of this, more direct and easier access to the physical hardware of the machine is allowed. As such, Nim is very well suited to writing operating systems, compilers, device drivers, embedded system software, and more. Despite the fact that it is still a new programming language, there are already many examples of such projects. For example, a very simple operating system called NimKernel is available on GitHub here: <https://github.com/dom96/nimkernel>.





> Note How does Nim compile source code? |
| The full details of Nim’s unusual compilation model and it’s benefits are described in a later section title *How does it work?*. |



Applications written in Nim are very fast, in many cases just as fast as applications written in C and more than 13 times faster than applications written in Python. Efficiency is prioritised the most, and there are features provided which make optimizing code easy. This goes hand in hand with a soft real-time garbage collector, which allows you to specify the amount of time that should be spent collecting memory. This becomes important during game development, where an ordinary garbage collector may slow down the rendering of frames on the screen, if it takes up too much time collecting memory. It is also useful in real-time systems which need to run in very strict time frames.


Applications which perform input/output operations such as reading files or sending data over a network are also well supported by Nim. Web applications for example can be written easily using a number of web frameworks like Jester. [[2]](01_split_000.html#ftn.d5e45) Nim’s script-like syntax together with the powerful asynchronous input/output support makes rapid development of these applications easy.


Command-line applications can benefit greatly from Nim’s efficiency. In addition to this, the fact that Nim applications are compiled means that they are standalone and so do not require any bulky runtime dependencies. This makes their distribution incredibly easy. One example of such an application that has been written in Nim is Nimble; it is a package manager for Nim and allows users to install packages containing Nim libraries and applications.


Those are just some examples of the use cases that Nim can be used for, it is of course not an exhaustive list. Another thing to keep in mind is that at the time of writing Nim is still in development, not having yet reached version 1.0. There are certain features that have not been implemented yet, which can make Nim less suited for certain applications. For example, Nim includes a JavaScript backend that allows you to write JavaScript applications for your web pages in Nim. This backend works but does not yet support all of the features of JavaScript that are needed to write good client-side web applications. This will improve with time.


You should now know a little bit about what Nim is, its history and some of the applications that it’s particularly well suited for. The next sub-sections demonstrate some of Nim’s features and talk about how Nim works.





1.1.2  Core features
--------------------



In many ways Nim is very innovative. Many of Nim’s features can’t be found in any other programming language. If you enjoy learning new programming languages, especially those with interesting and unique features, then this is definitely the language for you.


In this section we will look at some of the core features of Nim. In particular the features which make Nim stand out from other programming languages. In summary, the core features include:



* A facility called *metaprogramming* used for, among many things, moulding the language to your needs.
* Style insensitive variable, function, and type names. This feature, which is slightly controversial, allows you to treat identifiers in whatever style you wish no matter whether it is `camelCase` or `snake_case`.
* A type system that is rich in features such as generics, which make code easier to write and maintain.
* Compilation to C which allows Nim programs to be efficient and portable. The compilation itself is also very fast.
* An optional Garbage Collector that is interchangeable.



**Metaprogramming**


The most practical as well as in some sense unique feature of Nim is its extensive metaprogramming support. Metaprogramming allows you to read, generate, analyse and transform source code. It was by no means a Nim invention, but there is no other programming language with metaprogramming that is so extensive and at the same time easy to pick up as Nim’s. If you’re familiar with Lisp then you might have some experience with metaprogramming already.


Metaprogramming allows you to treat code as data, in the form of an *Abstract Syntax Tree*. This allows you to manipulate existing code as well as generate brand new code while your application is being compiled.


Metaprogramming in Nim is special because languages with good metaprogramming features typically belong to the Lisp family of languages. If you are already familiar with the likes of Java or Python then you will find it easier to start using Nim than Lisp. You will also find it more natural to learn how to use Nim’s metaprogramming features rather than Lisp’s.


While generally an advanced topic, metaprogramming is a very powerful feature which you will get to know in far more detail in *Chapter 9* of this book. One of the main benefits that metaprogramming offers is the ability to remove boilerplate code. Metaprogramming also allows the creation of domain specific languages, for example:




```
html:
  body:
    p: "Hello World"
```


The DSL above specifies a bit of HTML code. Depending on how it is implemented, the DSL will likely be translated into Nim code resembling the following:




```
echo("<html>")
echo("  <body>")
echo("    <p>Hello World</p>")
echo("  </body>")
echo("</html>")
```


Which itself will result in the following output:




```
<html>
  <body>
    <p>Hello World</p>
  </body>
</html>
```


Metaprogramming in Nim allows you to define domain specific language and mix them freely together with your ordinary Nim code. Languages like the one above have many use cases, for example the one above can be used to create HTML templates for your web apps.


This feature is at the centre of Nim’s design, it is very much the intention of the designer of Nim to encourage users to use metaprogramming in order to accommodate their style of programming. One example of this is the fact that while Nim does offer some Object Oriented Programming features, there is no class definition construct in Nim. Instead anyone wishing to use OOP in Nim in a similar style to that of other languages should use metaprogramming to allow them to do so.


**Style insensitivity**


Another interesting and likely unique feature of Nim is style insensitivity. One of the hardest things a programmer has to do is to come up with names for all sorts of identifiers like variables, functions and modules. In many programming languages these names cannot contain whitespace, so programmers were forced to adopt another way of separating multiple words in a single name. As is often the case, multiple differing methods were devised. The most popular being `snake_case` and `camelCase` which are still debated to this day. Nim allows you to use `snake_case` even if the identifier has been defined using `camelCase`, and vice versa. This allows you to write code in your preferred style even if the library which you are utilizing uses a different style for its identifiers.




Listing 1.1. Style insensitivity




```
import strutils   ❶
echo("hello".to_upper())   ❷
echo("world".toUpper())    ❸
```




|  |  |
| --- | --- |
| [❶](01_split_000.html#CO1-1) | The `strutils` module defines a procedure called `toUpper` |
| [❷](01_split_000.html#CO1-2) | We can call it using `snake_case`… |
| [❸](01_split_000.html#CO1-3) | … or, as it was originally defined using `camelCase`. |





This works because Nim considers the identifiers `to_upper` and `toUpper` to be equal. When comparing identifiers, Nim considers the case of the first character, but it does not bother with the case of the rest of the identifier’s characters ignoring the underscores as well. This means that the identifiers `toUpper` and `ToUpper` are not equal because the case of the first character differs.


This allows type names, which by convention begin with an upper case letter, to be distinguished from variable names, which by convention begin with a lower case letter. *Listing 1.2* below shows one scenario where this convention is useful.




Listing 1.2. Style insensitivity and type identifiers




```
type
  Dog = object   ❶
    age: int   ❷

let dog = Dog(age: 3)   ❸
```




|  |  |
| --- | --- |
| [❶](01_split_000.html#CO2-1) | The `Dog` type is defined with an uppercase first letter. |
| [❷](01_split_000.html#CO2-2) | Only primitive types such as `int` start with a lowercase letter. |
| [❸](01_split_000.html#CO2-3) | A `dog` variables can be safely defined because it will not clash with the `Dog` type. |





**Powerful type system**


One of the many characteristics which differentiate programming languages from one another is their type system. The main purpose of a type system is to reduce the opportunities for bugs in your programs. Other benefits which a good type system provides are the possibility of certain compiler optimisations, better documentation of code and more.


There are many different categories used to classify a programming language’s type system. The main categories are the static and dynamic type systems. In most cases a programming language is not on the extreme end of either of those type systems, it incorporates ideas from both. This is done because both require certain trade-offs. While static typing finds more errors at compile-time, it also decreases the speed at which programs can be written. Dynamic typing is the exact opposite.


Nim is statically typed. But unlike some statically typed programming languages it also incorporates many features which make development fast. Type inference is a good example of that, types can be resolved by the compiler without the need for you to write the types out yourself, unless you choose to write them out of course. Because of that your program is still bug free and your development speed is not hindered. Nim also incorporates some dynamic type-checking features such as runtime type information which allows for dynamic dispatch of functions.


One way that a type system will ensure that your program is free of bugs is by verifying memory safety. Some programming languages like C are not memory safe, because they allow programs to access memory which has not been assigned for their use. Other programming languages are memory safe, at the expense of not allowing programs to access low-level details of memory, which in some cases is necessary. Nim combines both, it is memory safe as long as you don’t use any of the unsafe types such as `ptr` in your program, at the same time the `ptr` type is necessary when interfacing with C libraries and supporting these unsafe features makes Nim a powerful systems programming language.


By default, Nim protects you against every type of memory error. Arrays are bounds checked at compile-time or at runtime when compile-time checks are not possible, preventing both buffer overflows and buffer over-reads. Pointer arithmetic is not possible for reference types as they are entirely managed by Nim’s garbage collector, this prevents issues such as dangling pointers and other memory issues related to managing memory manually. Lastly, variables are always initialised by Nim to their default values, which prevents variables containing unexpected and corrupt values.


Finally, one of the most important features of Nim’s type system is the ability to utilize generic programming. Generics in Nim allow for a great deal of code reuse without sacrificing type safety. One of the things they allow is to specify that a single function can accept multiple different types. You may for example have a `showNumber` procedure which displays both integers and floats on the screen.




```
proc showNumber(num: int | float) =
  echo(num)

showNumber(3.14)
showNumber(42)
```


In the listing above the `showNumber` procedure accepts either an `int` type or a `float` type. The `|` operator is used to specify that both `int` and `float` can be passed to the procedure. This listing is a very simple demonstration of Nim’s generics, you will learn a lot more about Nim’s type system as well as generics in the later chapters.


**Compilation**


I have mentioned in the previous section that the Nim compiler compiles source code into C first, and then feeds that source code into a C compiler. You will learn a lot more about how this works in detail in the *How does it work?* section, but right now let me talk about some of the many practical advantages that this compilation model has. The C programming language is very well established as a systems programming language and has been in use for over 40 years. C is one of the most portable programming languages, with multiple implementations for Windows, Linux, Mac OS X, x86, amd64, arm and many other more obscure operating systems and platforms. C compilers support everything from a super computer to a micro-controller, they are also very mature and implement many powerful optimizations which makes C very efficient.


Nim takes advantage of these aspects of C, including its portability, widespread use and efficiency.


Compilation to C also makes it very simple to use existing C and C++ libraries. In order to do so, all you need is to write some simple wrapper code. The process of writing this code can be done much faster by using a tool called `c2nim`, this tool converts C and C++ header files to Nim code which wraps those files.





> Note c2nim |
| The `c2nim` tool cannot translate every single piece of C/C++ code out there, in some cases you may need to manually edit parts of the code. Look for more information in *Chapter 8*. |



There are very many libraries written in C and C++, many of which are very popular. You can use all of these libraries very easily from Nim. This works both ways, so you can also write libraries which can then be used from C and other programming languages.




Figure 1.1. Compilation backends


![ch01 compilation backends](../Images/ch01_compilation_backends.png)

The Nim compiler can also compile Nim source code into Objective C and JavaScript. Objective C is the language mainly used for iOS software development. By compiling to Objective C, you have the ability to write iOS applications natively in Nim. This also includes Android applications which can be written using Java or C. Nim doesn't currently compile to Java, but it does compile to C. By doing so, Nim can also be used to create Android applications. JavaScript is the client-side language used by billions of websites, it is sometimes called the "assembly language of the web" because it is the only programming language that is supported by all the major web browsers. By compiling Nim to JavaScript you can write client-side applications for web browsers in Nim.


You may now be wondering just how fast Nim is at compiling software. Perhaps you are thinking that it is very slow, after all Nim needs to translate source code to an intermediate language first. But in fact the Nim compiler is one of the fastest out there. Nim even rivals Go, the language designed with compilation speed in mind. As an example, the Nim compiler which consists of around 100,000 lines of Nim code takes only about 11 seconds to compile on a MacBook Pro with a 2.7 GHz Intel Core i5 CPU.


**Memory management**


C and C++ both require you to manually manage memory, carefully ensuring that what you allocate is deallocated once it is no longer needed. Nim on the other hand manages memory for you using a garbage collector. There are reasons why you may want to avoid garbage collectors though, they are considered by many to be inadequate for certain application domains like embedded systems and games. For this reason, Nim supports a number of different garbage collectors with different applications in mind. The default garbage collector is real-time so it allows you to specify the amount of time it should spend on collecting memory. It is well suited for real-time systems and games, because it will not pause your applications for unknown periods of time. The garbage collector can also be removed completely, giving you the ability to manage memory yourself.





> Tip Garbage collectors |
| Switching between garbage collectors is easy, you just need to specify the `--gc:<theGc>` flag during compilation and replace `<theGc>` with one of either `markandsweep`, `boehm`, or `none`. |



This was just a small taste of Nim’s most prominent features. There is of course a lot more to it, not just the unique and innovative features but also the unique composition of features from existing programming languages which makes Nim as a whole very unique indeed. Now let me tell you exactly how Nim works.





1.1.3  How does it work?
------------------------



One of the things that makes Nim unique is its implementation. Every programming language has an implementation in the form of an application, which either interprets the source code, or compiles the source code into an executable. These implementations are called an interpreter and compiler respectively. While some languages may have multiple implementations, Nim’s only implementation is a compiler. The compiler compiles Nim source code by first translating the code to another programming language called C, then passing that C source code to a C compiler which then compiles it into a binary executable. The executable is a file containing instructions which indicate the specific tasks that the computer should perform, these instructions include ones specified in the original Nim source code. Let’s say that you have written a calculator program, in the compilation process the executable is the program itself, it is what you execute in order to run your calculator and start feeding it calculations you wish it to perform. *Figure 1.2* shows how a piece of Nim code is compiled into an executable.




Figure 1.2. How Nim compiles source code


![ch01 compilation](../Images/ch01_compilation.png)

Most programming languages have compilers which do not have this extra step, they themselves compile the source code into a binary executable. Some programming language implementations don’t even compile code at all. *Figure 1.3* shows how different programming languages transform source code into something which can perform tasks as programmed by the source code.




Figure 1.3. How the Nim compilation process compares to other programming languages


![ch01 compilation alt](../Images/ch01_compilation_alt.png)

As you can see Nim becomes a part of the C compilation process, in order to compile the C source code that was generated by the Nim compiler. This does mean that the Nim compiler depends on an external C compiler such as GCC or clang. But despite this, compilation is still very fast. The result of the compilation is an executable. It can be executed in order to perform the instructions defined by the initial source code. These instructions result in a number of actions being performed, one of these actions may be something as complex as the download of a file from the internet or as simple as the addition of two inputs.


This should give you a good idea of the way in which Nim source code is transformed into a working application and how this process is different to the one used in other programming languages. When developing Nim applications, every time you make a change to your source code you will need to recompile it. It is good to be aware of this compilation process, as it will be exactly the same for each compilation. The next section will evaluate Nim in terms of its positive and negative aspects.





  


[[1]](01_split_000.html#d5e27) Current open Nim pull requests, <https://github.com/nim-lang/Nim/pulls>




[[2]](01_split_000.html#d5e45) <https://github.com/dom96/jester>







1.2  Nim’s benefits and shortcomings
====================================



I think that while it is important to understand the reasons why you might want to use a language, it is also just as important to learn about the reasons why that language may not be correct for your particular use case.


In the spirit of that, this section will first compare Nim to a number of other programming languages. I will use a variety of characteristics and factors that are typically used in such comparisons. After that you will learn about some of the areas where Nim might still need to catch up with other languages, it is after all a very new programming language.




1.2.1  Benefits
---------------



There are many programming languages out there. As you read this book you may wonder how Nim compares to the programming languages that you are familiar with. There are many ways to compare programming languages, multiple factors that can be considered including their speed, expressiveness, development speed, readability, language’s ecosystem and more. I will talk about some of these here.


**Nim is efficient**


The speed of a programming language is one characteristic that is often used to compare multiple programming languages. One of Nim’s goals is efficiency, so it should be no surprise that it is a very efficient programming language.


C is one of the most efficient programming languages, so you may be wondering how Nim compares. In the previous section, I told you that the Nim compiler first translates Nim code into an intermediate language. By default the intermediate language is C, which suggests that the performance of Nim is very similar to C, and that is in fact true. Because of this feature Nim can be used as a complete replacement for C. Nim has similar performance, results in software which is more reliable than software written in C, features an improved type system, supports generics, and implements an advanced form of metaprogramming. In comparison to C, metaprogramming in Nim is unique as it does not use a preprocessor but is instead a part of the main compilation process. In general you can expect to find many modern features in Nim which you are not going to find in C, so picking Nim as a C replacement makes a lot of sense.


*Table 1.1* shows the results of a small benchmark. Nim matches C’s speed and is significantly faster than Python. [[3]](01_split_000.html#ftn.d5e224)




Table 1.1. Time taken to calculate which numbers of the first 100 million are prime








| Programming language | Time (seconds) |
| C | 2.6 |
| Nim | 2.6 |
| Python (CPython) | 35.1 |




In this benchmark the runtime of the Nim application matches the speed of the C one and is significantly faster than the one implemented in Python. Micro benchmarks such as this one are often unreliable, but they are one of the only ways of getting an idea as to the speed of a programming language. Nim’s performance matches that of C which is already one of the most efficient programming languages out there.


**Nim is readable**


Nim is a very expressive language, much like Python from which it borrows some syntax, including the wonderful indentation delimited scope. Nim code is not cluttered by the curly brackets and semicolons of C-like programming languages such as JavaScript and C++, nor does it require the `do` and `end` keywords that are present in languages such as Ruby.


This makes Nim very easy to write but also, more importantly, easy to read. Good code readability goes a long way, it makes debugging easier which leads to less time spent debugging, allowing you to spend more time writing beautiful Nim code and as a result cut down on your development time.


Take a look at the following examples and don’t worry if you don’t understand them yet. The examples implement a function that calculates the Fibonacci sequence which is defined as the following: `0, 1, 1, 2, 3, 5, 8, …`. This sequence begins with `0` and `1`, with the next numbers in the sequence equal to the sum of the previous two numbers. The examples in *Listing 1.3* and *Listing 1.4* calculate this sequence and display it to the user.




Listing 1.3. Iterating through the Fibonacci sequence in Nim




```
proc fibonacci(n: int64) =
  ## Displays the first ``n`` amount of numbers in the fibonacci sequence.
  var first = 0
  var second = 1

  echo first
  echo second

  for i in 0 .. <n:
    swap first, second
    second += first
    echo second

fibonacci(90)
```





Listing 1.4. Iterating through the Fibonacci sequence in Java




```
public class Fibonacci {
  /*
   * Displays the first ``n`` amount of numbers in the
   * fibonacci sequence.
   */
  public static void fibonacci(int n)
  {
    long first = 0;
    long second = 1;

    System.out.println(first);
    System.out.println(second);

    for(int i = n; i > 0; i--)
    {
      long temp = first;
      first = second;
      second = temp;

      second += first;
      System.out.println(second);
    }
  }

  public static void main(String[] args) {
    fibonacci(90);
  }
}
```



Despite the simplicity of this algorithm, the amount of noise in the Nim code is considerably lower than in the Java code. The Nim code is a lot more readable and compact, whereas the Java code is full of boilerplate. One example in Nim is that all of the code that is in the global scope is executed as if it was in a `main` method, this eliminates the need to specify that method leading to more compact code.


**Nim stands on its own**


I have already mentioned this earlier, but I think it is worth revisiting in order to describe how other languages handle this and why some do require a runtime.


Compiled programming languages such as Nim, C, Go, D, and Rust produce an executable which is native to the operating system on which the compiler is running on. Compiling a Nim application on Windows will result in an executable which can only be executed on Windows. Similarly compiling it on Mac OS X will result in one which can only be executed on Mac OS X. The CPU architecture also comes into this, compilation on ARM will result in an executable which is only compatible with ARM CPUs. This is how things work by default, but it is possible to instruct the compiler to compile an executable for a different operating system and CPU combination through a process known as *cross-compilation*.





> Tip Cross-compilation |
| One common use case would be compiling for ARM devices such as the Raspberry Pi, where the CPU is typically slow meaning that compilation on the device is slow too.foonote:[More information about cross-compilation can be found here: <http://nim-lang.org/docs/nimc.html#cross-compilation>] |



This problem is one of the major reasons why the JVM was created. You may have heard the phrase "write once, run anywhere". This is a slogan created by Sun Microsystems to illustrate the cross-platform benefits of the Java programming language. A Java application only needs to be compiled once, and the result of this compilation is a JAR file which holds all of the compiled Java classes. The JAR file can then be executed by the Java Virtual Machine in order to perform the programmed actions on any platform and architecture. This makes the JAR file a platform and architecture agnostic executable. The downside to this is that the Java Virtual Machine must be installed on the user’s system in order to run these JAR files. Adding another dependency is not ideal, the JVM is very big and may not be suitable for certain use cases, it also adds another piece of software which may contain bugs and security issues. But on the other hand it does allow the Java application to only be compiled once.


Python, Ruby and Perl are similar to this. They also utilize a virtual machine to execute code. In Python’s case a virtual machine is used to optimize the execution of Python code, but it is mostly hidden away as an implementation detail of the Python interpreter. The Python interpreter parses the code, determines what actions that code is describing and immediately executes those actions. There is no compilation step like with Java, C or Nim. But the advantages and disadvantages are mostly the same as the JVM’s, in order to execute a Python application the system needs to have a Python interpreter installed. But again, it does mean that you don’t have to worry about cross compilation.




Write once, run anywhere



Similar to the "write once, run anywhere" slogan, other programming languages adopted the "write once, compile anywhere" philosophy which describes the fact that the programming language is only cross-platform at the source code level. In other words, you do not need to write platform specific code. This applies to languages such as C, Pascal and Ada. But these languages still require platform specific code when dealing with more specialised features of the operating system, such as creating new threads or downloading the contents of a web page. Nim goes a step further, its standard library abstracts away the differences between operating systems and allows you to utilize a lot of the features that modern operating systems offer today.



Unfortunately in many cases virtual machines and interpreters cause more problems than they solve. The number of the common CPU architectures and the most popular operating systems is not that large and so compiling for them is not that difficult. It is often the case with applications written in interpreted languages, that the source code is distributed to the user and they are expected to install the correct version of the interpreter or virtual machine.


One example of the difficulty associated with distributing such applications is with the recent introduction of Python 3. It has caused many issues for software which was originally written in Python 2, due to the fact that Python 3 is not backward compatible with Python 2. As of the time of writing, Python 3 was released 8 years ago and there are still libraries written for Python 2 which do not work with the Python 3 interpreter. [[4]](01_split_000.html#ftn.d5e289) If something like this occurred with a compiled programming language then the binaries would at least still continue to work.


Nim can be used as a replacement for all interpreted programming languages as a more efficient, less dependent, and just as or more expressive language. In particular Python is a good candidate for replacement as the languages share many similarities.


**Nim is flexible**


Software may be written in different styles. The different styles and capabilities of programming languages are defined by their supported programming paradigms. A programming paradigm is the fundamental style of writing software. A paradigm you may be familiar with is OOP (Object Oriented Programming), this paradigm is often taught as part of Computer Science courses at university. It allows programmers to model real world objects and their relationships using code.


Nim is a multi-paradigm programming language, this means that it supports multiple programming paradigms. Unlike some of the popular programming languages, Nim does not focus on the OOP paradigm. It is mainly a procedural programming language, with varying support for OOP, functional, declarative, concurrent programming and more programming styles.


That is not to say that OOP is not well supported by Nim. OOP as a programming style is simply not forced upon you. Common OOP features which are supported include inheritance, polymorphism, and dynamic dispatch.


To give you a better idea of what the procedural paradigm looks like, let me show you the one big difference between the OOP paradigm and the procedural paradigm now. In the OOP paradigm, methods and attributes are bound to objects, and the methods operate on their own data structure. In the procedural paradigm, procedures are standalone entities which operate on data structures. This may be hard for you to visualise, so I will show you some code examples to illustrate it better.





> Tip Subroutine terminology |
| In the above paragraph I mentioned the terms `methods` and `procedures`, these are simply another name for subroutines or functions. A `method` is the term used in the context of OOP, a `procedure` in the context of procedural programming, and a `function` in the context of functional programming. |



The following code listings show the same application. The first is written in Python using the OOP style described above. The second is written in Nim using the procedural style described above.




Listing 1.5. Barking dog modelled using OOP in Python




```
class Dog:
  def bark(self):   ❶
    print("Woof!")

dog = Dog()
dog.bark()   ❷
```




|  |  |
| --- | --- |
| [❶](01_split_000.html#CO3-1) | The `bark` method is associated with the `Dog` class by being defined within it. |
| [❷](01_split_000.html#CO3-2) | The `bark` method can be directly invoked on the `dog` object by accessing the method via the dot. |







Listing 1.6. Barking dog modelled using procedural programming in Nim




```
type
  Dog = object

proc bark(self: Dog) =   ❶
  echo("Woof!")

let dog = Dog()
dog.bark()   ❷
```




|  |  |
| --- | --- |
| [❶](01_split_000.html#CO4-1) | The `bark` method is not directly associated with the `Dog` type by being defined within it. This method could also easily be defined outside this module. |
| [❷](01_split_000.html#CO4-2) | The `bark` method can still be directly invoked on the `dog` object, despite the fact that the procedure is not associated with the `Dog` type as it is associated in the Python version. |





In the Python code, the method `bark` is placed under the `class` definition. In the Nim code, the method `bark` (called a procedure in Nim) is not bound to the `Dog` type in the same way as it is in the Python code, it is independent of the definition of the `Dog` type. Instead its first argument specifies the type it is associated with.


Something similar could also be implemented in Python but it would not allow us to call the `bark` method in the same manner, we would be forced to call it like so: `bark(dog)`. Explicitly passing the dog variable to the method as its first argument. The reason this is not the case with Nim is because Nim has been designed to rewrite `dog.bark()` to `bark(dog)`, allowing you to call methods using the traditional OOP style without having to explicitly bind them to a class.


This ability is referred to as Uniform Function Call Syntax and has multiple advantages. It allows you to create new procedures on existing objects externally and allows procedure calls to be chained.





> Tip Classes in Nim |
| Defining classes and methods in Nim in a manner similar to Python is also possible. As mentioned earlier metaprogramming can be used to do this. The community has already created numerous libraries which emulate the syntax.[[5]](01_split_000.html#ftn.d5e352) |



Another paradigm that Nim has support for is the functional programming paradigm. While the OOP paradigm has been popular for many years now, the functional paradigm in comparison is not as popular, but in recent years it has seen a surge in popularity. Functional programming is a style of programming which primarily avoids the changing of state and the use of mutable data. It introduces the use of certain features such as first-class functions, anonymous functions and closures which are all supported by Nim.


Let’s take a look at an example to show the differences between programming in a procedural style and a functional one. The following code listings show code which separates people’s names into a first and last name. The first code listing shows it in a functional style and the second in a procedural style.




Listing 1.7. Iterating over a sequence using functional programming in Nim




```
import sequtils, future, strutils   ❶
let list = @["Dominik Picheta", "Andreas Rumpf", "Desmond Hume"]   ❷
list.map(  ❸
  (x: string) -> (string, string) => (x.split[0], x.split[1])   ❹
).echo   ❺
```




|  |  |
| --- | --- |
| [❶](01_split_000.html#CO5-1) | Import the `sequtils`, `future` and `strutils` module. These modules define the `map`, `→`, and `split` procedures respectively. |
| [❷](01_split_000.html#CO5-2) | Define new `list` variable containing a list of names. |
| [❸](01_split_000.html#CO5-3) | The `map` procedure is used to iterate over the `list`. |
| [❹](01_split_000.html#CO5-4) | The `map` procedure takes a closure which specifies how to modify each item in the list. |
| [❺](01_split_000.html#CO5-5) | The modified list is then displayed on the screen. |







Listing 1.8. Iterating over a sequence using a procedural style in Nim




```
import strutils     ❶
let list = @["Dominik Picheta", "Andreas Rumpf", "Desmond Hume"]
for name in list:   ❷
  echo((name.split[0], name.split[1]))   ❸
```




|  |  |
| --- | --- |
| [❶](01_split_000.html#CO6-1) | Import the `strutils` module which defines the `split` procedure. |
| [❷](01_split_000.html#CO6-2) | A for loop is used to iterate over each item in the `list`. |
| [❸](01_split_000.html#CO6-3) | The code inside the for loop is executed during each iteration, in this case each name is split into two and displayed as a tuple. |





The functional version uses the `map` procedure to iterate over the variable `list`, which contains a list of names. Whereas the procedural version uses a for loop. Both versions split the name into a first name and a last name. They then display the result in a tuple. There is a lot of new terms being thrown at you here, don’t worry if you are not familiar with them as you will be introduced to them in the next chapter. The output of the code listings will look similar to this:




```
(Field0: Dominik, Field1: Picheta)
(Field0: Andreas, Field1: Rumpf)
(Field0: Desmond, Field1: Hume)
```


Nim is incredibly flexible and allows you to write software in many different styles. This was just a small taste of some of the most popular paradigms supported by Nim, and how they compare to Nim’s main paradigm. More obscure paradigms are also supported, and support for more can be introduced easily using metaprogramming.


**Nim catches errors ahead of time**


Nim is a statically typed programming language and as such it provides a certain level of type safety that dynamically typed programming languages do not provide.


Throughout this chapter I have been vaguely comparing Python to Nim. While Nim does take a lot of inspiration from Python. They do differ in one important way: Python is dynamically typed. Despite the fact that Nim is statically typed it does feel very dynamic as it supports type inference and generics. You will learn what this means in the second chapter, but think of it as a way to retain the high development speed that dynamically typed programming languages allow, while also providing extra type safety at compile-time.


In addition to Nim being statically typed, it also implements an exception tracking mechanism that is entirely opt-in. Exception tracking allows you to ensure that a procedure will not raise any exceptions or will only raise exceptions from a pre-defined list. This prevents unexpected crashes by ensuring that you handle exceptions.


**Summary**


This section compared Nim to some other programming languages based on characteristics such as efficiency, dependencies of the resulting software, flexibility of the language and the language’s ability to catch errors before the software is deployed. Based on these characteristics alone, Nim is a very good candidate for replacing some of the most popular programming languages out there including Python, Java, C and more.


For reference, here is a table showing a list of programming languages and some of the features that they do and do not support.




Table 1.2. Common programming language features














| Programming language | Type System | Generics | Modules | GC | Syntax | Metaprogramming | Execution |
| Nim | Static and strong | Yes | Yes | Yes, multiple and optional [[a]](01_split_000.html#ftn.d5e450) | Python-like | Yes | Compiled binary |
| C | Static and weak | No | No | No | C | No | Compiled binary |
| C++ | Static and weak | Yes | No | No | C-like | Limited [[b]](01_split_000.html#ftn.d5e490) | Compiled binary |
| D | Static and strong | Yes | Yes | Yes, and optional | C-like | Yes | Compiled binary |
| Go | Static and strong | No | Yes | Yes | C-like | No | Compiled binary |
| Rust | Static and strong | Yes | Yes | No | C-like | Limited [[c]](01_split_000.html#ftn.d5e543) | Compiled binary |
| Java | Static and strong | Yes | Yes | Yes, multiple [[d]](01_split_000.html#ftn.d5e559) | C-like | No | Executed via Java Virtual Machine |
| Python | Dynamic and strong | N/A | Yes | Yes | Python | Yes [[e]](01_split_000.html#ftn.d5e583) | Executed via Python interpreter |
| Lua | Dynamic and weak | N/A | Yes | Yes | Modula-like [[f]](01_split_000.html#ftn.d5e601) | Yes via Metalua | Executed via Lua interpreter or Lua JIT compiler |
| 
[[a]](01_split_000.html#d5e450) Nim supports ref counting, a custom GC, and Boehm. Nim also allows the GC to be switched off altogether.


[[b]](01_split_000.html#d5e490) C++ only offers metaprogramming through templates, there is limited CTFE (Compile Time Function Execution) and no AST macros


[[c]](01_split_000.html#d5e543) Rust has some support for declarative macros through its `macro_rules!` directive, no built-in procedural macros that allow you to transform the AST except for compiler plugins, and no CTFE (Compile Time Function Execution)


[[d]](01_split_000.html#d5e559) <http://www.fasterj.com/articles/oraclecollectors1.shtml>


[[e]](01_split_000.html#d5e583) You can modify the behaviour of functions, including manipulating their AST using the `ast` module, but only at runtime.


[[f]](01_split_000.html#d5e601) Uses `do` and `end` keywords to delimit scope.
 |







1.2.2  Areas where Nim still needs to improve
---------------------------------------------



Nothing in this world is perfect; programming languages are no exception. There is no perfect programming language that can solve each problem in the most reliable and quickest manner. Each programming language has its strengths and weaknesses. Nim is no exception.


This chapter has so far been focusing almost solely on Nim’s strengths. There is a lot of good things about Nim that I have not mentioned in this chapter, and you will discover what those things are throughout this book. But it would be unfair for me to only talk about Nim’s strengths. Nim is still a relatively young programming language, so there are of course areas where the language can still improve.


**Nim is still young and immature**


All programming languages go through a period of immaturity. Some of Nim’s more advanced and new features are still unstable. Using them can result in buggy behavior in the compiler like for example crashes. In reality crashes don’t happen very often, also the unstable features of the language are opt-in which means that you can’t accidentally use them.


Nim has a package manager called Nimble, and while other programming languages may have thousands of packages available, as of writing Nim only has about 400. This means that in some situations you may need to write libraries for certain tasks yourself. This situation is of course improving, with new packages being created by the Nim community every day. *Chapter 5* will show you how to create your own Nimble packages.


**Nim’s user base and community is still quite small**


Nim has very few users in comparison to the mainstream programming languages such as Python or Java. The result is that unfortunately there is very few jobs that ask for knowledge of Nim. Finding a company that uses Nim in production is rare, but when it does happen the demand for good Nim programmers tends to make the salaries quite high.


On the other hand, one of the most special things about Nim is that its development is very open. Nim’s creator, Andreas Rumpf, and many other Nim developers (including me) discuss Nim’s future development plans on GitHub and on IRC openly. Anyone is free to challenge these plans and because the community is still quite small it is very easy to do so. IRC is also a great place for newcomers to ask questions about Nim and to meet fellow Nim programmers!





> Tip IRC |
| Take a look at the *Getting Help* appendix to learn how to connect to IRC! |



Having said all of this, these problems are temporary. Nim has a bright future ahead of it, and you can help shape it. This book will teach you how!




  


[[3]](01_split_000.html#d5e224) <http://hookrace.net/blog/what-is-special-about-nim/#good-performance>




[[4]](01_split_000.html#d5e289) <http://py3readiness.org/>




[[5]](01_split_000.html#d5e352) <https://nim-by-example.github.io/oop_macro/>





1.3  Who is this book for?
==========================



This book is by no means a beginners book, it assumes that you have knowledge of at least one other programming language and that you have experience writing software in that programming language. Because of this fundamentals of programming will not be explained in this book, as an example I expect you to be aware of basic programming language features such as functions, variable and types.


This book will teach you how to develop practical software in the Nim programming language. Useful features which are present in all programming languages such as concurrency, parallelism, user defined types, the standard library and more will be covered. In addition, features which you may not be familiar with but that are offered by Nim such as asynchronous Input/Output, Metaprogramming, the Foreign Function Interface and more will also be covered.





1.4  Summary
============




* Nim is still a very new programming language, it has not yet reached version 1.0.
* Nim has been designed to be efficient, expressive and elegant (in that order).
* Nim is an open source project that is developed entirely by the Nim community of volunteers. Nim was created by Andreas Rumpf in 2005.
* Nim is general purpose and can be used to develop anything from web applications to kernels.
* Nim is a compiled programming language which compiles to C and takes advantage of C’s speed and portability.
* Nim supports multiple programming paradigms including OOP, procedural programming and functional programming.
* Nim has multiple innovative features which make it appealing to enhusiasts, including style insensitivity and metaprogramming.
* Nim is still very new which makes it a bit immature and it’s user base is still quite small.












