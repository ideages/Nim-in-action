

7
=


Building a Twitter clone
========================


This chapter covers:



* Developing a Twitter clone in Nim
* Storing and querying for data in an SQL database
* Generating HTML and sending it to the user’s browser
* Deploying your web application



Web applications have become extremely popular in recent years as a result of the widespread use of web browsers and the convenient nature of most web applications. Web applications are convenient because they can be used immediately without the installation of any additional software.


Web-based email is one of the most widely used types of web applications. Email providers such as Gmail, Outlook, Yahoo, and ProtonMail all provide custom email clients implemented as web applications. Desktop email clients are also widely used, but most users opt to use the web-based email clients that are more convenient. You have likely used at least one such web-based email client before.


Developers have created many types of web applications. Many of them have always been used in the form of a web application, whereas others were originally desktop applications. Web browsers are continually evolving, they include more features than ever before. Web browsers can now even use your computer’s graphics card to render 3D graphics in real-time. These features make it easier to develop native applications for the web and the cross-platform nature of web browsers makes the development of web applications much more appealing.


Many technologies and programming languages support the development of web applications. Some programming languages were even specifically designed to be used for web development. PHP being the most famous example of one such language. Other programming languages were designed with other use cases in mind. But due to one or more of their characteristics, programmers found that the languages were well suited for web development.


Large web applications that consist of many components are typically written in multiple different programming languages. The languages and technologies are chosen so that they match the requirements of that component. In most cases the core infrastructure is written in a single language, with a few small specialised components being written in one or two different programming languages. YouTube for example uses C, C++, Java and Python for its many different components, but the core infrastructure is written in Python.


Thanks to the great speed of development that Python provides, YouTube was able to evolve quickly by responding to changes in a fast manner and implementing new ideas rapidly. Performance was not a big factor at first except in specialised cases where C extensions were used to achieve greater performance.


Smaller web applications are typically written in a single programming language. The choice of that programming language differs, but it is typically a scripting language like Python, Ruby or PHP. These languages are favoured for their expressive and interpreted characteristics which allows web applications to be iterated on quickly.


Unfortunately applications written in those languages are typically slow. This has resulted in problems for some major websites. For example Twitter, which was initially written in Ruby has recently moved to Scala, because Ruby turned out too slow to handle the high volume of tweets posted by users every day.


Websites can also be written in languages such as C++, Java and C# which are compiled. These languages produce very fast applications but development in them is not as fast as in Python or other scripting languages. This is due to the fact that compile times in those languages are slow, which means that you must spend more time waiting to test your application after you have introduced some changes to it. Those languages are also not as expressive as Python or other scripting languages.


Nim is a hybrid, it is both a compiled language and a scripting language. In many ways it is as expressive as any scripting language and as fast as any compiled language. Compilation times in Nim are also very fast. This makes Nim a good language for developing efficient web applications elegantly.


This chapter will lead you through the development of a web application. Specifically, it will show you how to develop a web app that is very similar to Twitter. Of course developing a full Twitter clone would take far too much time and effort, the version that will be developed in this chapter will be significantly simplified.


You will need some knowledge of SQL for this chapter. Specifically you will need to know how to understand the structure and semantics of common SQL statements, including `CREATE TABLE` and `SELECT`.




7.1  Architecture of a web application
======================================



Developers make use of many different architectural patterns when designing a web application. Many web frameworks are based on the very popular model-view-controller pattern and its variants. One example of an MVC framework is Ruby on Rails.


Model-view-controller is an architectural pattern which has been traditionally used for graphical user interfaces on the desktop. As it turned out, this pattern is also very good for web applications which incorporate an interface that is presented to the user. The MVC pattern is composed of three distinct components. The components have been specifically chosen so that they are independent of each other. The three components in an MVC are the *model* which acts as a data store, *view* which presents data to the user and *controller* which gives the user the ability to control the application. *Figure 7.1* shows how the three different components communicate.




Figure 7.1. The three different components in the MVC architecture and how they interact


![ch07 mvc](../Images/ch07_mvc.png)

Consider a simple calculator application consisting of a number of buttons and a display. In this case, the *model* would be a simple database which stores the numbers which have been typed into the calculator, the *view* would be the display which shows the result of the current calculation, and the *controller* would detect any button presses and control the *view* and *model* accordingly. *Figure 7.2* shows a simple graphical calculator with the different components labelled.




Figure 7.2. The three different MVC components as seen on a calculator’s GUI


![ch07 mvc calculator](../Images/ch07_mvc_calculator.png)

It is a good idea to design web applications using this pattern. Especially when writing very large web applications. Using this pattern ensures that your code does not mix database code, HTML generation code, and logic code together. This makes large web applications easier to maintain. Depending on the use case, a variant of this pattern can also be used, one which separates code in a less strict fashion or vice versa.


When designing the architecture of a web application, you may already naturally separate your code into logical independent units. Doing so can achieve the same benefits as using the MVC pattern, with the additional benefit of making your codebase more specific to the problem you are solving. It is not always necessary to abide by architectural patterns and there are some web frameworks that are pattern-agnostic. These types of frameworks are more suited for small web applications, or applications which don’t need to incorporate all of the components of the MVC pattern.


For every web framework that forces the MVC pattern on you, there is at least one web framework which doesn’t. Sinatra is one example of such a framework. It is written in Ruby just like Ruby on Rails, but unlike Ruby on Rails it has been designed to be minimalistic. In comparison to Ruby on Rails, Sinatra is much lighter as it lacks much of the functionality that is common in fully fledged web application frameworks, such as:



* Accounts, authentication, and authorization.
* Database abstraction layers.
* Input validation and input sanitation.
* Templating engines.



This makes Sinatra very simple to work with but means that it does not support as many features out of the box as Ruby on Rails does. Sinatra instead encourages other developers to work on additional packages which implement the missing functionality.


The term *microframework* is used to refer to minimalistic web application frameworks like Sinatra. Many microframeworks exist, some based on Sinatra and written in various programming languages. There is even one written in Nim and it is called Jester.


Jester is a microframework heavily based on Sinatra. At the time of writing, it is one of the most popular Nim web frameworks out there. Jester will be used to develop the web application in this chapter as it is easy to get started with and it is the most mature out of all the Nim web frameworks. Jester is hosted on Github at the following URL: <https://github.com/dom96/jester>. Later on in this chapter you will see how to install Jester using the Nimble package manager, right now let me explain how a microframework like Jester is used to write web applications.




7.1.1  Routing in microframeworks
---------------------------------



Fully fledged web frameworks usually require a big application structure to be created before development of the web application can begin. Microframeworks can be used immediately, all that is needed is a simple definition of a route. *Listing 7.1* shows a simple route definition in Jester.




Listing 7.1. A `/` route defined using Jester




```
routes:
  get "/":
    resp "Hello World!"
```



To better understand what a *route* is, let me first explain how your web browser retrieves web pages from web servers. *Figure 7.3* shows an HTTP request to twitter.com.




Figure 7.3. An HTTP request to twitter.com


![ch07 http example](../Images/ch07_http_example.png)

When you’re browsing the internet and you navigate to a different website or web page, your web browser requests that page using a certain URL. For example, when navigating to the front page of Twitter your web browser first connects to twitter.com then asks the Twitter server to send it the contents of the front page. The exchange occurs using the HTTP protocol and looks something like the one shown in *Listing 7.2*.




Listing 7.2. A simple HTTP GET request




```
GET / HTTP/1.1      ❶
Host: twitter.com   ❷
  ❸
```




|  |  |
| --- | --- |
| [❶](#CO1-1) | This line specifies three pieces of information. The first is the type of HTTP request used, the second is the *path* of the page requested, and the third is the HTTP protocol version. |
| [❷](#CO1-2) | The HTTP request may include one or more headers. The `Host` header specifies the domain name that the web browser has connected to. |
| [❸](#CO1-3) | An empty line is sent to ask the server for a response. |





Note the similarities between the information in *Listing 7.2* and *Listing 7.1*. The two important pieces of information are the `GET` which is a type of HTTP request and the `/` which is the path of web page requested. The `/` path is a special path which refers to the front page.


In a web application the path is used to distinguish between different routes. This allows you to respond with different content depending on the page requested. Jester receives similar HTTP requests to the one in *Listing 7.2*, it checks the path and executes the appropriate route accordingly. *Figure 7.4* below shows this operation in action.




Figure 7.4. HTTP requests and routing in Jester


![ch07 jester routing](../Images/ch07_jester_routing.png)

An ordinary web application will define multiple such routes, the routes will include the likes of `/register`, `/login`, `/search` and more. The web application that you will develop will include similar routes. Some routes will perform certain actions such as tweeting whereas others will simply retrieve information.





7.1.2  The architecture of Tweeter
----------------------------------



Tweeter is the name which I will use to refer to the simplified version of Twitter that you will develop as part of this chapter. Obviously implementing every one of Twitter’s features would take far too much time and effort, as such Tweeter will consist of the following features:



* Posting up to 140 character messages.
* Subscribing to another user’s posts, called *following* in Twitter and many other social media websites.
* Viewing the messages posted by other users you are following.



Some features which will be explicitly not implemented are:



* User authentication: the user will simply be able to type in their username and login with no registration required.
* Search including hashtags.
* Retweeting, replying to messages, or liking messages.



That’s a pretty small set of features but it should be more than enough to teach you the basics of web development in Nim. Through these features you will learn:



* How web application projects are structured
* How to store data in a SQL database
* How to use Nim’s templating language
* How to use the Jester web framework
* How the resulting application can be deployed on a server



The architecture of Tweeter will roughly follow the MVC architectural pattern explained earlier.


The following information will need to be stored in a database:



* Posted messages, and the users that posted them.
* The username of each user.
* The names of the users that each user is following.



When developing web applications it is useful to abstract database operations into a separate module. In Tweeter this module will be called `database` and it will define procedures for reading and writing to a database. This maps well onto the *model* component in the MVC architecture.


HTML will need to be generated based on the data provided by the `database` module. For that purpose two separate views will be created. One of the views will contain procedures to generate HTML for the front page and the other will contain procedures to generate HTML for the timelines of different users. Each procedure will generate a different piece of HTML. For example, there will be a `renderMain` procedure which will generate an HTML page and also a `renderUser` procedure which will generate a small bit of HTML representing a user.


Finally the main source code file which includes the routes will act as the controller. It will receive HTTP requests from the web browser and based on those requests it will perform the following actions:



* Retrieve the appropriate data from the database.
* Build the HTML code based on that data.
* Send the generated HTML code back to the requesting web browser.



*Figure 7.5* shows the process of developing these three components along with their features.




Figure 7.5. The architecture of Tweeter


![ch07 tweeter architecture](../Images/ch07_tweeter_architecture.png)






7.2  Starting the project
=========================



You should now have an idea of what you will be building as part of this chapter. The previous section described how web applications are generally designed and described how Tweeter will be designed specifically. This section will describe the first steps needed to begin the project, which will include:



* Setting up Tweeter’s directory structure
* Initialising a Nimble package
* Building a simple Hello World Jester web application



Just like in *Chapter 3*, let’s start by creating the directories and files necessary to hold the project. Create a new `Tweeter` directory in your preferred code directory, for example `C:\code\Tweeter` or `~/code/Tweeter`. Then create a `src` directory inside it and a Nim source code file inside that `src` directory named `tweeter.nim`. Your directory structure should look like the one shown in *Listing 7.3*.




Listing 7.3. Tweeter’s directory structure




```
Tweeter
└── src   ❶
    └── tweeter.nim
```



The web framework that this project will be using is Jester. This is an external dependency which will need to be downloaded in order for Tweeter to compile. This dependency could be downloaded manually but thankfully that is not necessary, because Jester is a Nimble package which means that Nimble can download it for you.


*Chapter 5* showed you how to use Nimble and explained how it works. In this chapter you will use Nimble during development. In order to do so you will need to first create a `.nimble` file. You may recall that Nimble’s `init` command can be used to generate one quickly.


In order to initialise a `.nimble` file in your project’s directory follow these steps.



1. Open a new terminal window.
2. `cd` into your project directory, by executing something like `cd ~/code/Tweeter`. Make sure to replace `~/code/Tweeter` with the location of your project.
3. Execute `nimble init`.
4. Answer the prompts given by Nimble. You can use the default values for most of them by simply pressing enter.



If you have done everything correctly your terminal window should look something like this.




Figure 7.6. Successful initialisation of a Nimble package


![ch07 nimble init](../Images/ch07_nimble_init.png)

Now open the `Tweeter.nimble` file that was created by Nimble. It should look similar to the following.




Listing 7.4. The `Tweeter.nimble` file




```
# Package

version       = "0.1.0"
author        = "Dominik Picheta"
description   = "A simple Twitter clone developed in Nim in Action."
license       = "MIT"

# Dependencies

requires "nim >= 0.13.1"
```



As you can see by the last line, in order for the `Tweeter` package to successfully compile the Nim compiler’s version must at least be `0.13.1`. The `requires` line specifies the dependency requirements of the `Tweeter` package. You will need to edit this line to introduce a requirement on the `jester` package. To do so, simply edit the last line so that it reads `requires "nim >= 0.13.1, jester >= 0.0.1"`. Alternatively you can add `requires "jester >= 0.0.1"` at the bottom of the `Tweeter.nimble` file.


You will also need to add `bin = @["tweeter"]` to the `Tweeter.nimble` file. This is to let Nimble know which files in your package need to be compiled. Make sure your `Tweeter.nimble` file now contains the following.




Listing 7.5. The final `Tweeter.nimble` file




```
# Package

version       = "0.1.0"
author        = "Dominik Picheta"
description   = "A simple Twitter clone developed in Nim in Action."
license       = "MIT"

**bin = @["tweeter"]**

# Dependencies

requires "nim >= 0.13.1"
```



Now open up `tweeter.nim` again and write the following code into it.




Listing 7.6. A simple Jester test




```
import asyncdispatch      ❹

import jester             ❶

routes:                   ❷   ❹
  get "/":                ❺   ❸
    resp "Hello World!"   ❻   ❸

runForever()              ❼
```




|  |  |
| --- | --- |
| [❶](#CO2-2) | This module defines the `runForever` procedure which is used to run the event loop. |
| [❷](#CO2-3) | This imports the Jester web framework. |
| [❸](#CO2-5) | These are part of the Domain Specific Language defined by Jester. |
| [❹](#CO2-1) | Starts the definition of the routes. |
| [❺](#CO2-6) | Defines a new route which will be executed when the `/` path is accessed using a HTTP GET request. |
| [❻](#CO2-8) | Respond with the text `Hello World!`. |
| [❼](#CO2-10) | Run the asynchronous event loop forever. |





Go back to your terminal and execute `nimble c -r src/tweeter`. Your terminal should show something similar to the following:




Figure 7.7. The successful compilation and execution of `tweeter`


![ch07 nimble c tweeter](../Images/ch07_nimble_c_tweeter.png)

Compiling your project using Nimble will ensure that all dependencies of your project are satisfied. If you have not previously installed the Jester package, Nimble will install it for you before compiling Tweeter.


As you can see in *Figure 7.7*, Jester lets you know in its own whimsical way the URL that you can use to access your web application. Now open a new tab in your favourite web browser and navigate to the URL given to you by Jester, typically <http://localhost:5000/>. Upon navigating, you should see the message "Hello World" as shown in *Figure 7.8* below.




Figure 7.8. Hello World from Jester


![ch07 jester hello](../Images/ch07_jester_hello.png)

Your web application will continue running and responding to as many requests as you throw at it. You can terminate it by pressing Ctrl + C, that is the Control and C keys together.


That should give you a good starting point for the development of Tweeter. It is a slow start, but it shows you just how easy it is to get started with Jester especially with the assistance of Nimble.


Now let’s move onto implementing Tweeter, the first task will be implementing the `database` module.





7.3  Storing data in a database
===============================



Many applications need to store data permanently. A database stores organised collections of data, there are many different types of databases which organise the data in different ways. These databases have many different implementations so there is a lot of choice when it comes to choosing a database for your project.


Because Nim is still relatively young, it does not support as many databases as some of the more popular programming languages such as C++ or Java. It does however support many of the most popular ones including Redis which is a key-value database, MongoDB which is a document-oriented database, MySQL which is a relational database and many more.


If you are familiar with databases, you will know that both Redis and MongoDB are what is known as NoSQL databases. As the name suggests, these databases do not support the Structured Query Language for making queries on the database. Instead they implement their own language which typically is not as mature or sophisticated as SQL.


It’s likely that you have more experience with relational databases than any of the many different types of NoSQL databases. You will be happy to hear that Nim supports three different SQL databases out of the box. MySQL, SQLite and PostgreSQL are all supported via the `db_mysql`, `db_sqlite` and `db_postgres` modules respectively.


Tweeter will need to store the following information:



* Messages posted by users with metadata which includes the user that posted the message and the time it was posted at.
* Information about specific users including their usernames and the names of users that they are following.



All of the databases that I mentioned can be used to store this information. The choice of database depends on the requirements. Throughout this chapter I will be using a SQL database for development, I will do this because of their popularity. The specific implementation I will use is SQLite because it is far easier to get started with than MySQL or PostgreSQL.


A `database` module is going to implement the storage and querying of the specific information related to the messages and users of Tweeter. This module will be designed in a way so that it can easily be extended to use a different database implementation later.




7.3.1  Setting up the types
---------------------------



Begin by creating a new `database.nim` file in Tweeter’s `src` directory. You can start by defining types in that file. These types will be used to store information about a specific message and user. *Listing 7.7* shows what those definitions look like.




Listing 7.7. The types used to hold information about a Tweeter message and user.




```
import times       ❶
type   ❷
  User* = object   ❸
    username*: string   ❹
    following*: seq[string]   ❺

  Message* = object     ❻
    username*: string   ❼
    time*: Time    ❽
    msg*: string   ❾
```




|  |  |
| --- | --- |
| [❶](#CO3-1) | Import the `times` module as it defines the `Time` type which is needed in the definition for `Message`. |
| [❷](#CO3-2) | Begin a new type definition section. |
| [❸](#CO3-3) | Define a new `User` value type. |
| [❹](#CO3-4) | Define a string `username` field in the `User` type. |
| [❺](#CO3-5) | Define a sequence `following` in the `User` type, this will hold a list of usernames that the user has followed. |
| [❻](#CO3-6) | Define a new `Message` value type. |
| [❼](#CO3-7) | Define a string `username` field in the `Message` type. This field will specify a unique name of the user that posted the message. |
| [❽](#CO3-8) | Define a floating point `time` field in the `Message` type. This field will store the time and date that the message was posted at. |
| [❾](#CO3-9) | Define a string `msg` field in the `Message` type. This field will store the actual message that was posted. |





Both types and their fields are exported using the `*` character. The `User` type will represent information about a single specific user and the `Message` type will similarly represent information about a single specific message. To help illustrate this better, take a look at *Figure 7.9* which shows a sample Twitter message.




Figure 7.9. A sample Twitter message


![ch07 twitter message](../Images/ch07_twitter_message.png)

An instance of the `Message` type can be used to represent the data in that message. *Listing 7.8* shows how the data can be represented in this way.




Listing 7.8. Representing *Figure 7.9* using an instance of `Message`




```
var message = Message(
  username: "d0m96",
  time: parse("18:16 - 23 Feb 2016", "H:mm - d MMM yyyy"),   ❶
  msg: "Hello to all Nim in Action readers!"
)
```




|  |  |
| --- | --- |
| [❶](#CO4-1) | `parse` is a procedure defined in the `times` module that can parse a given time in the specified format and return a `TimeInfo` object which holds that time. |





*Figure 7.9* does not include information about the people I follow, but we can speculate and create an instance of the `User` type for it anyway.




Listing 7.9. Representing a user using an instance of `User`




```
var user = User(
  username: "d0m96",
  following: @["nim_lang", "ManningBooks"]
)
```



The `database` module needs to provide procedures which return such objects. Once those objects are returned, it’s simply a case of turning the information stored in those objects into HTML. The HTML can then be rendered by the web browser.





7.3.2  Setting up the database
------------------------------



Before the procedures for querying and storing data are created, the database schema needs to be created and a new database initialised with it.


For the purposes of Tweeter this is pretty simple. The `User` and `Message` types above map pretty well to a `User` and `Message` table. All that you need to do is create those tables in your database.





> Note ORM 
 You may be familiar with Object-relational mapping libraries which mostly automate the creation of tables based on objects. Unfortunately Nim does not yet have any mature ORM libraries that could be used. Feel free to play around with the libraries that have been released on Nimble. 



I will be using SQLite for Tweeter’s database. SQLite is easy to get started with as the full database can be embedded directly in your application’s executable. Other database software needs to be set up ahead of time and configured to run as a separate server.


The creation of tables in the database is a one off task that is only performed when a fresh database instance needs to be created. Once the tables are created the database can be filled with data and subsequently queried. I will show you how to write a quick Nim script which will create the database and all the required tables.


Create a new file called `createDatabase.nim` inside Tweeter’s `src` directory. *Listing 7.10* shows the code that you should start off with.




Listing 7.10. Connecting to a SQLite database




```
import db_sqlite

var db = open("tweeter.db", "", "", "")   ❶

db.close()
```




|  |  |
| --- | --- |
| [❶](#CO5-1) | The `open` procedure creates a new database at the location specified. In this case it will create a `tweeter.db` file in `createDatabase`'s working directory. |





The `db_sqlite` modules' API has been designed so that it is compatible with the other database modules including `db_mysql` and `db_postgres`. This way you can simply change the imported module to use a different database. It is also the reason why the `open` procedure in the `db_sqlite` module has three parameters which are not used.


The code in *Listing 7.10* doesn’t do much except initialising a new SQLite database at the specified location, or opening an existing one should one exist. The `open` procedure returns a `DbConn` object which can then be used to talk to the database. Let me show you how to begin creating the tables.


The act of creating the tables requires some knowledge of SQL. *Figure 7.10* shows what the tables will look like after they are created.




Figure 7.10. The database tables


![ch07 db tables](../Images/ch07_db_tables.png)

*Listing 7.11* shows how to create the tables which are necessary to store the data contained in the `User` and `Message` objects.




Listing 7.11. Creating tables in a SQLite database




```
import db_sqlite

var db = open("tweeter.db", "", "", "")

db.exec(sql"""
  CREATE TABLE IF NOT EXISTS User(           ❶
    username text PRIMARY KEY                ❷
  );
""")

db.exec(sql""" 
  CREATE TABLE IF NOT EXISTS Following(      ❶
    follower text,        ❸
    followed_user text,   ❹
    PRIMARY KEY (follower, followed_user),   ❺
    FOREIGN KEY (follower) REFERENCES User(username),       ❻
    FOREIGN KEY (followed_user) REFERENCES User(username)   ❻
  );
""")

db.exec(sql"""
  CREATE TABLE IF NOT EXISTS Message(        ❶
    username text,        ❼
    time integer,         ❽
    msg text NOT NULL,    ❾
    FOREIGN KEY (username) REFERENCES User(username)        ❻
  );
""")

echo("Database created successfully!")

db.close()
```




|  |  |
| --- | --- |
| [❶](#CO6-1) | This SQL statement will create a new table, as long as the database does not already contain it. |
| [❷](#CO6-2) | Specifies that the `User` table should contain a `username` field and that it should be a primary key. |
| [❸](#CO6-4) | This field contains the username of the follower. |
| [❹](#CO6-5) | This field contains the username of the user that `follower` is following. |
| [❺](#CO6-6) | This specifies that both the `follower` and `followed_user` fields are together the primary key. |
| [❻](#CO6-7) | This creates a foreign key constraint which ensures that the data added to the database is correct. |
| [❼](#CO6-10) | This field contains the username of the user that posted the message. |
| [❽](#CO6-11) | This field contains the time when the message was posted, stored as Unix Time, the number of seconds since 1970-01-01 00:00:00 UTC. |
| [❾](#CO6-12) | This contains the actual message text, a `NOT NULL` key constraint is also present to ensure that it is not null. |





Whew. That’s a lot of SQL. Let me explain it in a bit more detail. Each `exec` line executes a separate piece of SQL, if that SQL is not executed successfully then an error is raised. Otherwise a new SQL table is successfully created with the fields specified. After the code in *Listing 7.11* is finished executing, the resulting database will contain three different tables. A third table called `Following` was required because SQLite does not support arrays.


The table definitions contain many table constraints, these prevent invalid data being stored in the database. For example, the `FOREIGN KEY` constraints present in the `Following` table ensure that the `followed_user` and `follower` fields contain usernames which are already stored inside the `User` table.


Save the code in *Listing 7.11* in your `createDatabase.nim` file. Then compile and run it by executing `nimble c -r src/createDatabase`. You should see the "Database created successfully!" message and a `tweeter.db` file in Tweeter’s directory.


Your database has been created and you are now ready to start defining procedures for storing and querying data.





7.3.3  Storing and retrieving data
----------------------------------



The `createDatabase.nim` file is now finished, so you can switch back to the `database.nim` file. This section describes how to begin adding data into the database and how to then get the data stored in it back.


Let’s start with storing data into the database. The three actions that will trigger data to be added into the database in Tweeter will be the following:



* Posting a new message.
* Following a user.
* Creating an account.



The `database` module should define procedures for those three actions. The procedures will be defined as follows:




```
proc post(message: Message)
proc follow(follower: User, user: User)
proc create(user: User)
```


Each procedure corresponds to a single action. *Figure 7.10* shows how the `follow` procedure will modify the database.




Figure 7.11. Storing Follower data in the database


![ch07 db store](../Images/ch07_db_store.png)

Each of those procedures simply needs to execute the appropriate SQL statements to store the desired data. In order to do that the procedures will also need to take a `DbConn` object as a paremeter. The `DbConn` object should be saved in a custom `Database` object so that it can be changed if required in the future. *Listing 7.12* shows the definition of the `Database` type.




Listing 7.12. The `Database` type




```
type
  Database* = ref object
    db: DbConn

proc newDatabase*(filename = "tweeter.db"): Database =
  new result
  result.db = open(filename, "", "", "")
```



Add the type definition above and corresponding constructor to the top of your `database.nim` file. Also make sure to add `import db_sqlite` to the top of the file. After you do so you will be ready to implement the `post`, `follow` and `create` procedures. *Listing 7.13* shows how they can be implemented.




Listing 7.13. Implementing the `post`, `follow` and `create` procedures




```
proc post*(database: Database, message: Message) =
  if message.msg.len > 140:   ❶
    raise newException(ValueError, "Message has to be less than 140 characters.")

  database.db.exec(sql"INSERT INTO Message VALUES (?, ?, ?);",         ❷
    message.username, $message.time.toSeconds().int, message.msg)      ❸

proc follow*(database: Database, follower: User, user: User) =
  database.db.exec(sql"INSERT INTO Follower VALUES (?, ?);",           ❷
    follower.username, user.username)

proc create*(database: Database, user: User) =
  database.db.exec(sql"INSERT INTO User VALUES (?);", user.username)   ❷
```




|  |  |
| --- | --- |
| [❶](#CO7-1) | Verify that the message length is not greater than 140 characters. If it is then raise an exception. |
| [❷](#CO7-2) | Insert a row into the specified table. The question marks are replaced with the values passed in after the SQL statement. The `exec` procedure ensures that the values are escaped to prevent SQL injections. |
| [❸](#CO7-3) | The time which has type `Time` is converted into the number of seconds since the Unix Epoch by calling `toSeconds`. The `float` result is then converted into an `int`. |





The code in *Listing 7.13* is fairly straightforward, the annotations highlight and explain the important parts of the code. These procedures should work perfectly well but just to make sure they do you should test them. In order to do so you are going to need a way to query for data, this gives a good excuse to implement the procedures needed to get information from the database.


Just like when implementing the procedures above, let’s think about the actions that will prompt the retrieval of data from the database.


The primary way that the user will interact with Tweeter will be via its front page. Initially the front page will ask the user for their username, Tweeter will need to check whether that username has already been created. A procedure called `findUser` will need to be defined to check whether a username exists in the database. This procedure should return a new `User` object containing both the user’s username and a list of users being followed.


Should the username not exist, an account for it will be created. The user will then be logged in. At that point the user will be shown a list of messages posted by the users that they follow. A procedure called `findMessages` will need to be defined. This procedure will take a list of users and return the messages that those users posted in chronological order.


Each of the messages shown to the user will contain a link to the profile of the user that posted it. Once the user clicks that link they will be shown messages posted only by that user. The `findMessages` procedure is flexible enough to be reused for this purpose.


Let’s define those two procedures. *Listing 7.14* shows their definitions and implementations.




Listing 7.14. Implementing the `findUser` and `findMessages` procedures




```
proc findUser*(database: Database, username: string, user: var User): bool =   ❶
  let row = database.db.getRow(
      sql"SELECT username FROM User WHERE username = ?;", username)            ❷
  if row[0].len == 0: return false   ❸
  else: user.username = row[0]

  let following = database.db.getAllRows(
      sql"SELECT username FROM Following WHERE follower = ?;", username)       ❹
  user.following = @[]
  for row in following:              ❺
    if row[0].len != 0:
      user.following.add(row[0])

  return true

proc findMessages*(database: Database, usernames: seq[string],
    limit = 10): seq[Message] =      ❻
  result = @[]   ❼
  if usernames.len == 0: return
  var whereClause = " WHERE "
  for i in 0 .. <usernames.len:      ❽
    whereClause.add("username = ? ")
    if i != <usernames.len:
      whereClause.add("or ")

  let messages = database.db.getAllRows(
      sql("SELECT username, time, msg FROM Message" &
          whereClause &
          "ORDER BY time LIMIT " & $limit),
      usernames)         ❾
  for row in messages:   ❿
    result.add(Message(username: row[0], time: fromSeconds(row[1].parseInt), msg: row[2]))
```




|  |  |
| --- | --- |
| [❶](#CO8-1) | This procedure returns a Boolean which determines whether the user was found. The `User` object is saved in the `user` parameter. |
| [❷](#CO8-2) | Find a row with the specified username in the database. |
| [❸](#CO8-3) | An empty string is returned when the database doesn’t contain the username specified. |
| [❹](#CO8-4) | Find all the usernames of people that the user with the specified username is following. |
| [❺](#CO8-5) | Iterate through each row that specifies who the user is following, and add that username to the `following` list. |
| [❻](#CO8-6) | This procedure takes an optional `limit` parameter, its default value is `10` and it specifies the amount of messages that this procedure will return. |
| [❼](#CO8-7) | Initialise the `seq[Message]` so that items can be `add`-ed to it. |
| [❽](#CO8-8) | Add `username = ?` to the `whereClause` for each username specified in `usernames`. This ensures that the SQL query returns messages from each of the username’s specified. |
| [❾](#CO8-9) | Ask the database to return a list of all the messages from `usernames` in a chronological order limited to the value of `limit`. |
| [❿](#CO8-10) | Iterate through each of the messages and add them to the resultant sequence. The returned time integer which is represented as the number of seconds since the Unix epoch is converted into a `Time` object using the `fromSeconds` procedure. |





Add these procedures to your `database.nim` file, you will need to import the `strutils` module which define the `parseInt` procedure used in the `findMessages` procedure.


These procedures are significantly more complicated. The `findUser` procedure makes a query to find the specified user, but it then also makes another query to find who the user is following. The `findMessages` procedure requires some string manipulation to build part of the SQL query, this is needed because the number of usernames passed into this procedure can vary. Once the `WHERE` clause of the SQL query is built, the rest is fairly simple. The SQL query also contains two keywords, the `ORDER BY` keyword instructs SQLite to sort the resulting messages based on the time they were posted and the `LIMIT` keyword ensures that only a certain number of messages is returned.





7.3.4  Testing the database
---------------------------



The `database` module is now ready to be tested. Let’s write some simple unit tests to ensure that all the procedures in it are working correctly.


To do this, start by creating a new directory called `tests` in Tweeter’s root directory. Then create a new file called `database_test.nim` in the `tests` directory. Type `import database` into the `database_test.nim` then try to compile it by executing `nimble c tests/database_test.nim`. The compilation will fail with `Error: cannot open 'database'`. This is due to the unfortunate fact that neither Nim nor Nimble have any way of finding the `database` module, this module is hidden away in your `src` directory and so cannot be found.


To get around this create a new file called `database_test.nim.cfg` in the `tests` directory. Inside it write `--path:"./src"`. This will instruct the Nim compiler to look for modules in the `src` directory when compiling the `database_test` module. Verify that the `database_test.nim` file now compiles.


The test will need to create its own database instance. This is so that it does not overwrite Tweeter’s database instance. Unfortunately the code for setting up the database is in the `createDatabase` module. You’re going to have to move the bulk of the code into the `database` module so that `database_test` can use it. The new `createDatabase.nim` will be much smaller after you add the procedure shown in *Listing 7.15*. See *Listing 7.16* for the new `createDatabase.nim` implementation.




Listing 7.15. The `setup` and `close` procedures destined for `database.nim`




```
proc close*(database: Database) =   ❶
 database.db.close()

proc setup*(database: Database) =   ❷
  database.db.exec(sql"""
    CREATE TABLE IF NOT EXISTS User(
      username text PRIMARY KEY
    );
  """)

  database.db.exec(sql"""
    CREATE TABLE IF NOT EXISTS Following(
      follower text,
      followed_user text,
      PRIMARY KEY (follower, followed_user),
      FOREIGN KEY (follower) REFERENCES User(username),
      FOREIGN KEY (followed_user) REFERENCES User(username)
    );
  """)

  database.db.exec(sql"""
    CREATE TABLE IF NOT EXISTS Message(
      username text,
      time integer,
      msg text NOT NULL,
      FOREIGN KEY (username) REFERENCES User(username)
    );
  """)
```




|  |  |
| --- | --- |
| [❶](#CO9-1) | The `close` procedure simply closes the database and returns any allocated resources to the operating system. |
| [❷](#CO9-2) | The `setup` procedure intialises the database with `User`, `Following` and `Message` tables. |







Listing 7.16. The new implementation of `createDatabase.nim`




```
import database

var db = newDatabase()
db.setup()
echo("Database created successfully!")
db.close()
```



Add the code in *Listing 7.15* to `database.nim` and replace the contents of `createDatabase.nim` with the code in *Listing 7.16*.


Now that the small reorganisation of code is complete, you can start writing test code in the `database_test.nim` file. *Listing 7.17* shows a simple test of the `database` module.




Listing 7.17. A test of the database module




```
import database

import os, times

when isMainModule:
  removeFile("tweeter_test.db")             ❶
  var db = newDatabase("tweeter_test.db")   ❷
  db.setup()                                ❸

  db.create(User(username: "d0m96"))        ❹
  db.create(User(username: "nim_lang"))     ❹

  db.post(Message(username: "nim_lang", time: getTime() + 4.seconds,   ❺
      msg: "Hello Nim in Action readers"))
  db.post(Message(username: "nim_lang", time: getTime() + 2.seconds,   ❺
      msg: "99.9% off Nim in Action for everyone, for the next minute only!"))

  var dom: User
  doAssert db.findUser("d0m96", dom)        ❻
  var nim: User
  doAssert db.findUser("nim_lang", nim)     ❻
  db.follow(dom, nim)   ❼

  doAssert db.findUser("d0m96", dom)        ❽

  let messages = db.findMessages(dom.following)   ❾
  echo(messages)
  doAssert(messages[0].msg == "Hello Nim in Action readers")
  doAssert(messages[1].msg == "99.9% off Nim in Action for everyone, for the next minute only!")
  echo("All tests finished successfully!")
```




|  |  |
| --- | --- |
| [❶](#CO10-1) | Remove the old test database. |
| [❷](#CO10-2) | Create a new `tweeter_test.db` database. |
| [❸](#CO10-3) | Create the tables in the SQLite database. |
| [❹](#CO10-4) | Test user creation. |
| [❺](#CO10-6) | Test message posting by posting two messages, one 4 seconds from now and the other 2 seconds from now. |
| [❻](#CO10-8) | Test the `findUser` procedure, it should return `true` in both cases because the `d0m96` and `nim_lang` users have been created. |
| [❼](#CO10-10) | Test the `follow` procedure. |
| [❽](#CO10-11) | Re-read the user information for `d0m96` to ensure that the `following` information is correct. |
| [❾](#CO10-12) | Test the `findMessages` procedure. |





The test is very large. It tests the `database` modules as a whole, this is necessary in order to test it fully. Try to compile it yourself and you should see the two messages displayed on your screen followed by "All tests finished successfully!".


That’s really it for this section. The `database` module is complete, it can store information about users including who they are following and the messages that they post. The module can then also read that data back. All of this is exposed in an API which abstracts the database away and defines only the necessary procedures to build the Tweeter web application.






7.4  Developing the web application’s view
==========================================



Now that the `database` module is complete it is time to start the development of the web component of this application.


The `database` module provides the data needed in the application. It is the equivalent of the model component in the MVC architectural pattern which I explained above. The two components that are left are the view and controller. The controller acts as a link joining the view and model components together, so its best if you begin by implement the view first.


In Tweeter’s case, the view is going to contain multiple modules each defining one or more procedures. These procedures are going to take data as input and return HTML as output. The produced HTML will represent the data in a way that can be rendered by a web browser and be displayed appropriately to the user.


The data will be provided by the `database` module. One of the procedures that are going to be used will be called `renderUser`, as you might imagine this procedure will take a `User` object which it will then use to generate HTML. The HTML will be returned as a `string`. *Figure 7.12* below shows a simplified example of how this procedure, together with the `database` module and the controller, will display the information about a user to the person accessing the web application.




Figure 7.12. The process of displaying information about a user in the web browser


![ch07 render html](../Images/ch07_render_html.png)

There are many ways to implement procedures which convert information into HTML, like the `renderUser` procedure. One way is to use the `%` string formatting operator to build up a string based on the data as shown in the listing below.




```
proc renderUser(user: User): string =
  return "<div><h1>$1</h1><span>Following: $2</span></div>" %
          [user.username, $user.following.len]
```


Unfortunately this is very error prone and it does not make sure that special characters such as ampersands or `<` are escaped. Not escaping such characters can cause invalid HTML to be generated which would lead to invalid data being shown to the user. But more importantly, this can cause a major security risk!


Thankfully Nim supports two methods of generating HTML that are more intuitive. The first is defined in the `htmlgen` module. This module defines a Domain Specific Language for generating HTML. The listing below shows how it can be used.




```
proc renderUser(user: User): string =
  return `div`(          ❶
    h1(user.username),   ❷
    span("Following: ", $user.following.len)   ❸
  )
```




|  |  |
| --- | --- |
| [❶](#CO11-1) | The backticks ``` around the `div` are needed because `div` is a keyword. |
| [❷](#CO11-2) | The username passed to `h1` becomes the `<h1>` tag’s content. |
| [❸](#CO11-3) | Only strings are accepted so the length must be explicitly converted to a string using the `$` operator. |




This method of generating HTML is great when the generated HTML is small. But there is another more powerful method of generating HTML called filters. *Listing 7.18* shows filters in action.




Listing 7.18. Using a Nim filter to generate HTML




```
#? stdtmpl(subsChar = '$', metaChar = '#')   ❶
#import "../database"   ❷
#           ❸
#proc renderUser*(user: User): string =
#  result = ""          ❹
<div id="user">         ❺
  <h1>${user.username}</h1>
  <span>${user.following.len}</span>
</div>
#end proc   ❻
#
#when isMainModule:
#  echo renderUser(User(username: "d0m96", following: @[]))
#end when
```




|  |  |
| --- | --- |
| [❶](#CO12-1) | This line is called the filter definition, it allows you to customize the behaviour of the filter. |
| [❷](#CO12-2) | This file assumes that it is placed in a `views` subdirectory, this is why the `..` is necessary to import `database`. |
| [❸](#CO12-3) | This is an important gotcha to keep in mind. It is explained below. |
| [❹](#CO12-4) | In the filter an ordinary procedure is created, in it you need to initialise the `result` variable. |
| [❺](#CO12-5) | Each line that does not begin with `#` is converted to `result.add` by the compiler. |
| [❻](#CO12-6) | Keywords are used to delimit when the procedure ends as indentation does not work well in templates such as these. |





Filters allow the mixing of Nim code together with any other code. This way HTML can be written verbatim and Nim code can still be used. Create a new folder called `views` in the `src` directory of Tweeter and then save the contents of *Listing 7.18* into `views/user.nim`. Then compile this file. You should see the following output:




```
<div id="user">
  <h1>d0m96</h1>
  <span>0</span>
</div>
```


Filters are very powerful and can be customised to great lengths. Unfortunately they are still rather buggy. But they are still very usable for generating HTML.





|  |  |
| --- | --- |
| [Warning] | One important thing that can catch you out with filters |
| An important gotcha to look out for in filters involves empty lines. Unless you want Nim to generate `result.add("")` you should prefix the empty line with `#`. If you forget to do so you will get errors such as `undeclared identifier: result` in your code. |



*Figure 7.13* shows the resulting view that the `renderUser` procedure is going to create.




Figure 7.13. The view created by *Listing 7.18*


![ch07 renderUser view](../Images/ch07_renderUser_view.png)

The code shown in *Listing 7.18* still suffers from the same problems as the first example in this section: it does not escape special characters. But thanks to the filter’s flexibility this can be easily repaired. The listing below shows how this can be done.




Listing 7.19. `views/user.nim`




```
#? stdtmpl(subsChar = '$', metaChar = '#', toString = "xmltree.escape")   ❶
#import "../database"
#import xmltree   ❷
#
#proc renderUser*(user: User): string =
#  result = ""
<div id="user">
  <h1>${user.username}</h1>
  <span>${$user.following.len}</span>
</div>
#end proc
#
#when isMainModule:
#  echo renderUser(User(username: "d0m96<>", following: @[]))   ❸
#end when
```




|  |  |
| --- | --- |
| [❶](#CO13-1) | Note that the `toString` parameter is being overwritten with a new string `xmltree.escape`. This parameter specifies the operation that is applied to each expression such as `${user.username}`. That way these expressions are escaped. |
| [❷](#CO13-2) | The `xmltree` module which defines `escape` needs to be imported. |
| [❸](#CO13-3) | The username of the user is now `d0m96<>` to test the escape mechanism. |





 





> Tip Filter definitions |
| You can learn more about how to customise filters by taking a look at their documentation, available at the following URL: <http://nim-lang.org/docs/filters.html> |



Save this file in `views/user.nim` and note the new output. Everything should be as before except for the `<h1>` tag which should read `<h1>d0m96&lt;&gt;</h1>`, note how the `<>` is escaped as `&lt;&gt;`.




7.4.1  Developing the user view
-------------------------------



The vast majority of the user view is already implemented in the `view/user.nim` file. The procedures defined in this view will be used whenever a specific user’s page is accessed.


Together with some basic information about the user, the user’s page is going to display all of the user’s messages. Basic information about the user is already presented in the form of HTML using the `renderUser` procedure.


The `renderUser` procedure needs to include a Follow and Unfollow button. Instead of making the `renderUser` procedure more complicated, let’s overload it with a new one. This new `renderUser` procedure will take an additional parameter called `currentUser`. *Listing 7.19* below shows its implementation.




Listing 7.20. The second `renderUser` procedure




```
#proc renderUser*(user: User, currentUser: User): string =   ❶
#  result = ""
<div id="user">
  <h1>${user.username}</h1>
  <span>Following: ${$user.following.len}</span>
  #if user.username notin currentUser.following:   ❷
  <form action="follow" method="post">             ❸
    <input type="hidden" name="follower" value="${currentUser.username}">   ❹
    <input type="hidden" name="target" value="${user.username}">            ❹
    <input type="submit" value="Follow">
  </form>
  #end if
</div>
#
#end proc
```




|  |  |
| --- | --- |
| [❶](#CO14-1) | Note how the procedure definition is almost identical to the previous `renderUser` procedure. The difference is in the parameters, in this case the addition of the `currentUser` parameter. |
| [❷](#CO14-2) | Check to see if the currently logged in user is already following the specified `user`. If not create a "Follow" button. |
| [❸](#CO14-3) | This procedure adds a form which contains a Follow or Unfollow button. The form is submitted to the `/follow` route. |
| [❹](#CO14-4) | Hidden fields are used to pass information to the `/follow` route. |





*Figure 7.14* shows what the follow button will look like once its rendered.




Figure 7.14. The follow button constructed by `renderUser` in *Listing 7.19*


![ch07 renderUser view2](../Images/ch07_renderUser_view2.png)

Now let’s implement a `renderMessages` procedure as well. *Listing 7.20* below shows the full implementation of the `renderMessages` procedure together with the `renderUser` procedures implemented in the previous section.




Listing 7.21. `views/user.nim`




```
#? stdtmpl(subsChar = '$', metaChar = '#', toString = "xmltree.escape")
#import "../database"
#import xmltree
#import times   ❶
#
#proc renderUser*(user: User): string =
#  result = ""
<div id="user">
  <h1>${user.username}</h1>
  <span>Following: ${$user.following.len}</span>
</div>
#end proc
#
#proc renderUser*(user: User, currentUser: User): string =
#  result = ""
<div id="user">
  <h1>${user.username}</h1>
  <span>Following: ${$user.following.len}</span>
  #if user.username notin currentUser.following:
  <form action="follow" method="post">
    <input type="hidden" name="follower" value="${currentUser.username}">
    <input type="hidden" name="target" value="${user.username}">
    <input type="submit" value="Follow">
  </form>
  #end if
</div>
#
#end proc
#
#proc renderMessages*(messages: seq[Message]): string =        ❷
#  result = ""                  ❸
<div id="messages">             ❹
  #for message in messages:     ❺
    <div>
      <a href="/${message.username}">${message.username}</a>   ❻
      <span>${message.time.getGMTime().format("HH:mm MMMM d',' yyyy")}</span>   ❼
      <h3>${message.msg}</h3>   ❽
    </div>
  #end for                      ❾
</div>
#end proc
#
#when isMainModule:
#  echo renderUser(User(username: "d0m96<>", following: @[]))
#  echo renderMessages(@[        ❿
#    Message(username: "d0m96", time: getTime(), msg: "Hello World!"),
#    Message(username: "d0m96", time: getTime(), msg: "Testing")
#  ])
#end when
```




|  |  |
| --- | --- |
| [❶](#CO15-1) | The `times` module is imported so that the time can be formatted. |
| [❷](#CO15-2) | The new `renderMessages` procedure takes a list of messages and returns a single string. |
| [❸](#CO15-3) | As before, `result` is initialised so that text can be appended to it by the filter. |
| [❹](#CO15-4) | The procedure will first emit a new `<div>` tag. |
| [❺](#CO15-5) | Iterating through all messages. All the HTML code underneath will be added verbatim in each iteration. |
| [❻](#CO15-6) | The username is added to the HTML first. |
| [❼](#CO15-7) | The time the message was created is formatted and then added to the HTML. |
| [❽](#CO15-8) | Finally the message text is added last. |
| [❾](#CO15-9) | The for loop is explicitly finished by the `end for` keywords. |
| [❿](#CO15-10) | The `renderMessages` procedure is tested with some messages. |





Replace the contents of your `views/user.nim` file with the contents of *Listing 7.20*. Then compile and run it, you should see something similar to the following:




```
<div id="user">
  <h1>d0m96&lt;&gt;</h1>
  <span>Following: 0</span>
</div>

<div id="messages">
    <div>
      <a href="/d0m96">d0m96</a>
      <span>12:37 March 2, 2016</span>
      <h3>Hello World!</h3>
    </div>
    <div>
      <a href="/d0m96">d0m96</a>
      <span>12:37 March 2, 2016</span>
      <h3>Testing</h3>
    </div>
</div>
```


*Figure 7.15* shows what that may look like.




Figure 7.15. A message produced by `renderMessages`


![ch07 renderMessages view](../Images/ch07_renderMessages_view.png)

That’s all that is needed for the `user` view. All that is left now is building the remaining views.





7.4.2  Developing the general view
----------------------------------



The `user` view will be used for a specific user’s page. All that remains is the front page. The front page will either show a login form or if the user has logged in then they will be shown the messages posted by the people that they follow.


This will all be used in the front page of Tweeter, so for simplicity let’s just implement the procedures in a new file called `general.nim`. Create this file in the `views` directory now.


One important procedure that is still missing is one which will generate the main body of the HTML page. Let’s implement this now as a `renderMain` procedure. *Listing 7.21* shows how to implement this procedure.




Listing 7.22. Implementing the `renderMain` procedure




```
#? stdtmpl(subsChar = '$', metaChar = '#')        ❶
#import xmltree
#
#proc `$!`(text: string): string = escape(text)   ❷
#end proc
#
#proc renderMain*(body: string): string =         ❸
#  result = ""
<!DOCTYPE html>
<html>
  <head>
    <title>Tweeter written in Nim</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>

  <body>
    <div id="main">
      ${body}
    </div>
  </body>

</html>
#end proc
```




|  |  |
| --- | --- |
| [❶](#CO16-1) | Note that the `toString` parameter has been removed from the filter definition. |
| [❷](#CO16-2) | This defines a new operator which can be used to escape text easily. |
| [❸](#CO16-3) | This defines the `renderMain` procedure. The procedure simply generates a new HTML document, and inserts the `body` inside the `<div>` tag. |





The code is fairly straightforward. One important difference is the removal of the `toString` parameter in the filter definition. The `renderMain` procedure takes a parameter called `body`, this parameter contains HTML code which should be inserted in the body of the HTML page. The `toString` parameter was removed to ensure that the `body` is not escaped. Instead a new operator called `$!` was introduced, this operator is simply an alias for the `escape` procedure. This means that you can easily decide which of the strings that you are embedding will be escaped and which will not be.


Now that the `renderMain` procedure is implemented it is time to move onto implementing the remaining two procedures: `renderLogin` and `renderTimeline`. The first procedure is going to show a simple login form and the second is going to show the user their *timeline*. The timeline refers to the messages posted by the people that the user is following.


Let’s start with `renderLogin`, *Listing 7.22* below shows it can be implemented.




Listing 7.23. The implementation of `renderLogin`




```
#proc renderLogin*(): string =
#  result = ""
<div id="login">
  <span>Login</span>
  <span class="small">Please type in your username...</span>
  <form action="login" method="post">
    <input type="text" name="username">
    <input type="submit" value="Login">
  </form>
</div>
#end proc
```



This procedure is very simple as it does not take any arguments. It simply returns a piece of static HTML which represents a login form. *Figure 7.16* shows what this looks like when rendered in a web browser. Add this procedure to the bottom of `general.nim`.




Figure 7.16. The rendered login page


![ch07 renderLogin view](../Images/ch07_renderLogin_view.png)

The next procedure is also fairly straightforward even though it takes two parameters. *Listing 7.23* below shows how it is implemented.




Listing 7.24. The implementation of `renderTimeline`




```
#proc renderTimeline*(username: string, messages: seq[Message]): string =
#  result = ""
<div id="user">
  <h1>Your timeline</h1>
</div>
<div id="newMessage">
  <span>New message</span>
  <form action="createMessage" method="post">
    <input type="text" name="message">
    <input type="hidden" name="username" value="${$!username}">   ❶
    <input type="submit" value="Tweet">
  </form>
</div>
${renderMessages(messages)}   ❷
#end proc
```




|  |  |
| --- | --- |
| [❶](#CO17-1) | The `$!` operator is used here to ensure that `username` is escaped. |
| [❷](#CO17-2) | The `renderMessages` procedure is called and its result is inserted into the generated HTML. |





Add this procedure to the bottom of `general.nim`, and make sure that you also import `"../database"` and `user` at the top of the file. The implementation itself is fairly simple. It first creates a `<div>` tag which holds the title, then a `<div>` tag that allows the user to tweet a new message. Finally the `renderMessages` procedure defined in the `user` module is called.


For completeness, here is the full `general.nim` code.




Listing 7.25. `general.nim`




```
#? stdtmpl(subsChar = '$', metaChar = '#')
#import "../database"
#import user
#import xmltree
#
#proc `$!`(text: string): string = escape(text)
#end proc
#
#proc renderMain*(body: string): string =
#  result = ""
<!DOCTYPE html>
<html>
  <head>
    <title>Tweeter written in Nim</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>

  <body>
    ${body}
  </body>

</html>
#end proc
#
#proc renderLogin*(): string =
#  result = ""
<div id="login">
  <span>Login</span>
  <span class="small">Please type in your username...</span>
  <form action="login" method="post">
    <input type="text" name="username">
    <input type="submit" value="Login">
  </form>
</div>
#end proc
#
#proc renderTimeline*(username: string, messages: seq[Message]): string =
#  result = ""
<div id="user">
  <h1>${$!username}'s timeline</h1>
</div>
<div id="newMessage">
  <span>New message</span>
  <form action="createMessage" method="post">
    <input type="text" name="message">
    <input type="hidden" name="username" value="${$!username}">
    <input type="submit" value="Tweet">
  </form>
</div>
${renderMessages(messages)}
#end proc
```



With that the view components are finished and Tweeter is very close to being finished. All that is left is the component to tie the database and views together.






7.5  The controller
===================



The controller is what will tie the `database` module and the two different views together. Relative to the three modules that you have already implemented with the help of the previous few sections, the controller will be much smaller. The bulk of the work is now essentially behind you.


You have already created a file which implements the controller, it is called `tweeter.nim`. Open this file now so that you can begin editing it.


This file currently only contains one route: the `/` route. You will need to modify this route so that it responds with the HTML for the login page. In order to do so, start by importing the different modules that you have implemented in the previous section. Specifically `database`, `views/user`, and `views/general`. You can use the following code to import these modules:




```
import database, views/user, views/general
```


Now that you’ve done that, you can modify the `/` route so that it sends the login page to the user’s web browser:




```
get "/":
  resp renderMain(renderLogin())
```


Save your newly modified `tweeter.nim` file, then compile and run it. Open a new web browser tab and navigate to <http://localhost:5000>. You should see a login form, albeit a very white one. It might look similar to *Figure 7.17*.




Figure 7.17. The unstyled login form


![ch07 login nocss](../Images/ch07_login_nocss.png)

Let’s add some CSS style to this page. If you are familiar with CSS and are confident in your web design abilities, then I encourage you to write some CSS yourself in order to create a nice design for Tweeter’s login page.





> Note Share your CSS |
| If you do end up designing your own Tweeter, then please share what you come up with on Twitter with the hashtag `#NimInActionTweeter`. I would personally love to see what you come up with, if you don’t have Twitter you can also post it on the Nim forums or the Manning forums available at <http://forum.nim-lang.org> and <https://forums.manning.com/forums/nim-in-action> respectively. |



If you are more like myself and don’t have any web design abilities whatsoever, you can use the CSS available at the following URL: <https://github.com/dom96/nim-in-action-code/blob/master/Chapter7/Tweeter/public/style.css>


The CSS file should be placed in a `public` directory. Create this directory now and save your CSS file as `style.css`. When a page is requested, Jester will check the `public` directory for any files that match the page requested. If the page requested exists in the `public` directory, Jester will send that page to the browser.





> Note Static file directory |
| The `public` directory is known as the static file directory. This directory is set to `public` by default, but can be configured using the `setStaticDir` procedure or in a settings block. [[24]](#ftn.d5e8900) |



Once you’ve placed the CSS file in the `public` directory, refresh the page. You should see that the login page is now styled, it should look similar to the screen in *Figure 7.18*.




Figure 7.18. The login page


![ch07 login page](../Images/ch07_login_page.png)

Now type in a username then click the "Login" button. You will see an error message which reads `404 Not Found`. Take a look at your terminal and see what Jester displayed there, you should see something similar to *Figure 7.19* below.




Figure 7.19. Debug information from Jester


![ch07 jester debug](../Images/ch07_jester_debug.png)

Note the last line which reads:




```
DEBUG post /login
DEBUG   404 Not Found {Content-type: text/html;charset=utf-8, Content-Length: 178}
```


This specifies that an HTTP post request was made to the `/login` page. A route for the `/login` page has not yet been created, so Jester simply responds with a `404 Not Found` error.




7.5.1  Implementing the `/login` route
--------------------------------------



Let’s implement the `/login` route now. Its implementation is short:




```
post "/login":    ❶
  setCookie("username", @"username", getTime().getGMTime() + 30.minutes)   ❷
  redirect("/")   ❸
```




|  |  |
| --- | --- |
| [❶](#CO18-1) | Specifies a new POST route on the path `/login`. Any HTTP POST requests on `/login` will activate this route and the code in its body will be executed. |
| [❷](#CO18-2) | Sets a new cookie with a key of `"username"` and tells it to expire in 30 minutes. The cookie’s value is set to the username that the user typed into the login box on the front page. |
| [❸](#CO18-3) | Asks Jester to redirect the user’s web browser to the front page. |




Add the code in the listing above to `tweeter.nim`, make sure it’s indented just like the other route. You will also need to import the `times` module. The code above may seem a bit magical so let me explain it in more detail.


The code does two simple things: it sets a cookie and then redirects the user to the front page of Tweeter. A cookie is a piece of data stored in a user’s browser, it is composed of a key, a value and an expiration date. The cookie created in this route stores a username, which was typed in by the user just before the "Login" button was clicked. This username was sent together with the HTTP request when the "Login" button was clicked, its referred to by `"username"` because that is the `name` of the `<input>` tag that was created in the `renderLogin` procedure. The value of `"username"` is accessed in Jester using the `@` operator. Finally the expiration date of the cookie is calculated using a special `+` operator which adds a `TimeInterval` to a `TimeInfo` object, in this case it creates a date that is 30 seconds in the future. Finally, the route finishes by redirecting the user to the front page.


Recompile `tweeter.nim`, run it and test it out. You should now be able to type in a new username, click the login button and see that the web browser navigates to the front page automatically. Notice what is happening in your terminal, in particular the following line:




```
DEBUG post /login
DEBUG   303 See Other {Set-Cookie: username=test; Expires=Wed, 02 Mar 2016 21:57:29 UTC, Content-Length: 0, Location: /}
```


The last line is actually the response that Jester sent, together with the HTTP headers which include a `Set-Cookie` header. *Figure 7.20* shows this in action.




Figure 7.20. The current login process


![ch07 post login](../Images/ch07_post_login.png)




7.5.2  Extending the `/` route
------------------------------



After the user is redirected back to the front page the cookie is set. Unfortunately the user is still shown the front page without actually being logged in. Let’s fix that. *Listing 7.26* shows a modified version of the `/` route which fixes this problem.




Listing 7.26. The `/` route




```
let db = newDatabase()    ❶

routes:
  get "/":
    if request.cookies.hasKey("username"):   ❷
      var user: User
      if not db.findUser(request.cookies["username"], user):     ❸
        user = User(username: request.cookies["username"], following: @[])   ❹
        db.create(user)   ❹
      let messages = db.findMessages(user.following)             ❺
      resp renderMain(renderTimeline(user.username, messages))   ❻
    else:
      resp renderMain(renderLogin())         ❼
```




|  |  |
| --- | --- |
| [❶](#CO19-1) | Create a new database instance, this will open the database saved in `tweeter.db`. This is done inside a global variable so that every route can access it. |
| [❷](#CO19-2) | Check if the cookie has been set. |
| [❸](#CO19-3) | Check if the username already exists in the database. |
| [❹](#CO19-4) | If the username does not exist in the database then create it. |
| [❺](#CO19-6) | Retrieve the messages posted by the users that `user` is following. |
| [❻](#CO19-7) | Use the `renderTimeline` procedure to render the user’s timeline, then pass the result to `renderMain` which returns a fully rendered web page. |
| [❼](#CO19-8) | If the cookie is not set simply show the login page. |





Modify `tweeter.nim` by replacing the `/` route with the code in *Listing 7.26* above. Then recompile and run Tweeter again. Navigate to <http://localhost:5000>, type in `test` into the login text box and click the "Login" button. You should now be able to see test’s timeline. It should look similar to the screenshot in *Figure 7.21* below.




Figure 7.21. A simple timeline


![ch07 simple timeline](../Images/ch07_simple_timeline.png)

Congratulations, you have almost created your very own Twitter clone.





7.5.3  Implementing the `/createMessage` route
----------------------------------------------



Let’s keep going. The next step is to implement the tweeting functionality. Clicking the "Tweet" button will take you to the `/createMessage` route resulting in another 404 error. It is now time to implement the `/createMessage` route. *Listing 7.27* below shows how it can be implemented.




Listing 7.27. The `/createMessage` route




```
post "/createMessage":
  let message = Message(
    username: @"username",
    time: getTime(),
    msg: @"message"
  )
  db.post(message)
  redirect("/")
```



This route simply initialises a new `Message` and uses the `post` procedure defined in the `database` module to save the message in the database. It then redirects the browser to the front page.


Add this code to the bottom of your routes. Then recompile, run Tweeter and navigate to <http://localhost:5000>. After logging in you should be able to start Tweeting. Unfortunately you will quickly notice that the tweets you create are not appearing. This is because your username is not passed to the `findMessages` procedure in the `/` route.


To fix this problem change `let messages = db.findMessages(user.following)` to `let messages = db.findMessages(user.following & user.username)`. You should then be able to see the messages you have created after recompiling and running Tweeter. *Figure 7.22* below shows an example of what that will look like.




Figure 7.22. A timeline with messages


![ch07 own timeline](../Images/ch07_own_timeline.png)




7.5.4  Implementing the user route
----------------------------------



The username `test` in the message is clickable. It takes you to the user page for that specific username. Clicking it should take you to <http://localhost:5000/test> which will result in a 404 error. Because a route for `/test` has not yet been created. This route is a bit different, because it should accept any username not just `test`. Jester features patterns in route paths to support such use cases. *Listing 7.28* below shows how a route which shows any user’s timeline can be implemented.




Listing 7.28. The user route




```
get "/@name":   ❶
  var user: User
  if not db.findUser(@"name", user):   ❷
    halt "User not found"   ❸

  let messages = db.findMessages(@[user.username])
  resp renderMain(renderUser(user) & renderMessages(messages))   ❹
```




|  |  |
| --- | --- |
| [❶](#CO20-1) | Anything preceded by the `@` character in a path is a variable. Jester will activate this route when the path is `/test`, or `/foo`, or `/<insert_anything_here>`. |
| [❷](#CO20-2) | Inside the route, the `@` operator is then used to retrieve the value of the "name" variable in the path. The `User` object for that username value is then retrieved. |
| [❸](#CO20-3) | If the user is not found then the route finishes early with the specified message. The `halt` procedure is similar to a `return`. |
| [❹](#CO20-4) | The `renderUser` procedure is used to render the timeline of the specified `user` and the `renderMessages` procedure is then also used to generate the HTML for the user’s messages. |





Add the route in *Listing 7.28* into `tweeter.nim`, then recompile, run and navigate to the front page: <http://localhost:5000/>.


You will note that the page no longer has any style associated with it. So what happened? Unfortunately the route you have just added also matches `/style.css` and because a user with that name does not exist a 404 error is returned.


Thankfully this is easy to fix. Jester provides a procedure called `cond` which takes a boolean parameter and if that parameter is false the route is skipped. Simply add `cond '.' notin @"name"` at the top of the route to skip the route if `.` is inside the value of the "name" variable. This will skip the route when `/style.css` is accessed and fall back to responding with the static file.


Test it by recompiling `tweeter.nim` and running it again. You should see that the stylesheet has been restored when you navigate to <http://localhost:5000/>. Login using the `test` username and click on the username in your message again. You should see something resembling *Figure 7.23*.




Figure 7.23. Another user’s timeline


![ch07 user timeline](../Images/ch07_user_timeline.png)




7.5.5  Adding the Follow button
-------------------------------



There is one important feature missing from the user’s timeline page. That is the follow button, without which users cannot follow each other. Thankfully the `user` view already contains support for it. The route just needs to check the cookies to see if a user is logged in.


This operation is already becoming common, the `/` route also performs it. It would make sense to put this code into a procedure so that it is reusable. Let’s create this procedure now:




```
proc userLogin(db: Database, request: Request, user: var User): bool =
  if request.cookies.hasKey("username"):
    if not db.findUser(request.cookies["username"], user):
      user = User(username: request.cookies["username"], following: @[])
      db.create(user)
    return true
  else:
    return false
```


Add the `userLogin` procedure above your routes and outside the `routes` block. The `userLogin` procedure checks the cookies for a "username" key. If one exists it reads the value, attempts to retrieve the user from the database and if no such user exists then it will be created. The procedure performs the same actions as the `/` route.


The new implementations of the `/` and user routes then are fairly easy. *Listing 7.29* shows the new implementation of the two routes.




Listing 7.29. The new implementation of `/` and user routes




```
  get "/":
    var user: User
    if db.userLogin(request, user):
      let messages = db.findMessages(user.following & user.username)
      resp renderMain(renderTimeline(user.username, messages))
    else:
      resp renderMain(renderLogin())

  get "/@name":
    cond '.' notin @"name"
    var user: User
    if not db.findUser(@"name", user):
      halt "User not found"
    let messages = db.findMessages(@[user.username])

    var currentUser: User
    if db.userLogin(request, currentUser):
      resp renderMain(renderUser(user, currentUser) & renderMessages(messages))
    else:
      resp renderMain(renderUser(user) & renderMessages(messages))
```



Now the "Follow" button should appear when you navigate to a user’s page. But clicking it will again result in a 404 error.





7.5.6  Implementing the `/follow` route
---------------------------------------



Let’s fix that by implementing the `/follow` route. All that this route needs to do is call the `follow` procedure defined in the `database` module. *Listing 7.30* below shows how the `/follow` route can be implemented.




Listing 7.30. The `/follow` route




```
post "/follow":
  var follower: User
  var target: User
  if not db.findUser(@"follower", follower):   ❶
    halt "Follower not found"        ❷
  if not db.findUser(@"target", target):       ❶
    halt "Follow target not found"   ❷
  db.follow(follower, target)        ❸
  redirect(uri("/" & @"target"))     ❹
```




|  |  |
| --- | --- |
| [❶](#CO21-1) | Retrieve the current user and the target user to follow from the database. |
| [❷](#CO21-2) | If either of the usernames is not present in the database respond with an error. |
| [❸](#CO21-5) | Call the `follow` procedure which will store follower information in the database. |
| [❹](#CO21-6) | The `redirect` procedure is used to redirect the user’s browser back to to the user page. |





That’s all there is to it. You can now log into Tweeter, create messages, follow other users using a direct link to their timeline, and then see the messages of other users that you are following as they are created on your own timeline.


Currently Tweeter may not be the most user-friendly or secure. Demonstrating and explaining the implementation of many of the features, which would improve both of those aspects, would unfortunately take far too many pages. Despite the limited functionality you have implemented as part of this chapter, you should now have the knowledge necessary to extend Tweeter with many more features.


As such I would like to challenge you to consider implementing the following features:



* The ability to unfollow users.
* Authentification with passwords.
* Better navigation including a button that takes the user to the front page.





  


[[24]](#d5e8900) Static file config in Jester, <https://github.com/dom96/jester#static-files>







7.6  Deploying the web application
==================================



Now that the web application is mostly complete. You may wish to deploy it to a server.


When you compile and run a Jester web application. Jester starts up a small HTTP server that can be used to test the web application locally. This HTTP server runs on port `5000` by default, but this port can be easily changed. A typical web server’s HTTP server runs on port 80. When you navigate to a website, your web browser defaults to that port.


You could simply run your web application on port 80, but that is not recommended. The reason is that Jester’s HTTP server has not been designed to be directly accessible by users. From a security point of view, it is also not a good idea to directly expose web applications like that.


A more secure way is to run a reliable HTTP server such as nginx, apache or lighttpd and configure it in such a way so that it passes the request onto Jester. Therefore acting as a *reverse proxy*.




7.6.1  Configuring Jester
-------------------------



The default Jester port is fine for most development work. But there undoubtedly comes a time when it needs to be changed. You may also wish to configure other aspects of Jester, for example the static directory.


Jester can be configured easily using a `settings` block. For example to change the port to `80`, simply place the code in *Listing 7.31* above your routes.




Listing 7.31. Configuring Jester




```
settings:
  port = Port(5454)
```



Other parameters which can be customised in Jester can be found in its documentation: <https://github.com/dom96/jester#readme>





7.6.2  Setting up a reverse proxy
---------------------------------



A *reverse proxy* is a piece of software that retrieves resources on behalf of a client from one or more servers. In the case of Jester, a reverse proxy would accept HTTP requests from web browsers ensuring that they are valid and passing them onto a Jester application. A Jester application would then send a response to the reverse proxy, and the reverse proxy would then pass it on to the client web browser as if it generated the response. *Figure 7.24* shows a reverse proxy taking requests from a web browser and forwarding them to a Jester application.




Figure 7.24. Reverse proxy in action


![ch07 reverse proxy](../Images/ch07_reverse_proxy.png)

When configuring such an architecture, you must first decide how you will get a working binary of your web application onto the server itself. Keep in mind that binaries compiled on a specific operating system are not compatible with other operating systems. For example, if you are developing on a MacBook running Mac OS X then you will not be able to upload the binary to a server running Linux. You will either have to cross-compile, which requires setting up a new C compiler, or alternatively you can compile your web application on the server itself.


The latter is much simpler. You just need to install the Nim compiler on your server, upload the source code and compile it.


Once your web application is compiled, you need a way to execute it in the background while retaining its output. An application that runs in the background is referred to as a *daemon*. Thankfully many Linux distributions support the management of daemons out of the box. You will need to find out what init system your Linux distribution comes with, and how it can be used to run custom daemons.


Once your web application is up and running, all that is left is to configure your HTTP server of choice. This should be fairly simple in most HTTP servers. *Listing 7.32* below shows a configuration suitable for Jester web applications that can be used for nginx.




Listing 7.32. Nginx configuration for Jester




```
server {
        server_name tweeter.org;

        location / {
                proxy_pass http://localhost:5000;
                proxy_set_header Host $host;
                proxy_set_header X-Real_IP $remote_addr;
        }
}
```



All you need to do is save that into `/etc/nginx/sites-enabled/tweeter.org`, reload Nginx’s configuration and you should see Tweeter at <http://tweeter.org>. But perhaps more realistically on <http://yourDomainHere.org>.


Other web servers should support similar configurations including Apache and lighttpd. Unfortunately showing how to do this for each web server is outside the scope of this book. But there are many good guides online on how to configure these web servers to act as reverse proxies.






7.7  Summary
============




* The Model-View-Controller is a very popular pattern for developing web applications.
* Some web frameworks have been built with MVC in mind.
* Microframeworks are minimalistic web frameworks, they lack certain features of fully fledged web frameworks but are in return simpler.
* Jester is the Sinatra-inspired Nim web framework.
* In order to ensure that Nimble can build your project, you must make sure that all dependencies are specified in the `.nimble` file.
* Nim’s standard library defines three different database modules: `db_sqlite`, `db_mysql`, `db_postgresql`. These can be freely swapped out without changing much code.
* Nim filters can be used as a powerful templating tool for rendering HTML.
* It is recommended to deploy Jester applications behind a reverse proxy.





