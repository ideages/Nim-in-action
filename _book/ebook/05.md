

5
=


Package management
==================


This chapter covers:



* What is Nimble and how does it help me develop software?
* Using Nimble packages to develop software
* Creating Nimble packages and publishing them



Today package managers have a central role in the development of software. This was not always the case; the Comprehensive Perl Archive Network, or CPAN, was one of the first large software repositories to have existed solely for a specific programming language. It consists of over 150,000 modules of Perl code, making it one of the biggest software module repositories from a single programming language. It’s also one of the earliest examples of such a software repository; its success influenced many others. Today software repositories exist for just about all programming languages.


A package is an abstract term given to a collection of modules; these modules may form a library or an application. A package manager automates the process of downloading, installing, updating and removing packages. Libraries contain implementations of different behaviour which can be invoked using a well-defined interface. These implementations are stored and exposed through one or more modules.


Software repositories distribute a number of different packages, allowing those packages to be freely downloaded. You could download packages manually, but doing so would be tedious. For example, many packages have dependencies: other packages which need to be installed ahead of time in order for a package to work correctly. Package managers ensure that dependencies are correctly installed automatically. *Figure 5.1* below shows how packages, libraries, applications and software repositories relate to each other.




Figure 5.1. Comparison between packages, libraries, applications and software repositories


![ch05 intro](../Images/ch05_intro.png)

Most programming languages have at least 1 package manager, some even have multiple. Nim’s package manager is important because it is a tool which gives you access to the hundreds of open source packages that are contained in Nim’s package repository.




5.1  The Nim package manager
============================



There are many package managers in existence today, but not all of them are designed for the same purpose. Package managers are primarily split into two categories, the system-level package managers and the application-level package managers.


System-level package managers are typically bundled with the operating system. They allow the user to install a popular set of applications and libraries written in many different programming languages. The application-level package managers are more specific, they focus on libraries and applications written in a single programming language.


Imagine that you got a brand new computer and you would like to watch some movies on it. One of the most widely used applications for watching video is VLC, but computers don’t come preinstalled with it. You can instruct a package manager to install VLC, together with any missing libraries which VLC needs to function. A system-level package manager would be perfect for this.


VLC comes with a library called `libvlc`, this library allows any application to play video with the same accuracy as VLC itself. You may wish to make use of this library in your Nim application, in order to do so you would need a Nim package which implements a Nim interface to that library. Such a package would be installed via an application-level package manager.




Figure 5.2. System-level vs. application-level package managers


![ch05 system vs app level](../Images/ch05_system_vs_app_level.png)

Package managers also differ in the way that they distribute packages. Some distribute packages in the form of binaries, whereas others distribute the source code. In the latter case the packages must then be compiled on the user’s computer using a compiler.


Nim’s package manager is called *Nimble*. Nimble is an application-level package manager, and it distributes packages in the form of source code. This is similar to other application-level package managers such as Python’s pip and NodeJS' npm. Nimble is already being used by many Nim programmers, even though it is not yet stable and there are still some features missing from it. This section will show you how the current version of Nimble (0.7.2 as of writing) can be used to manage Nim libraries and applications. Keep in mind that Nimble is evolving every day and that some of the things mentioned in this section may change in the future.






5.2  Installing the Nimble package manager
==========================================



The good news is that you most likely already have Nimble installed. The Nim installation packages have started to include Nimble since around version 0.15.0 so if you have Nim installed you should have Nimble installed too.


You can check whether this is the case easily by running `nimble -v` in the terminal. Keep in mind that in order to install packages Nimble may execute an external application called Git, which you must also have installed and available in your PATH.


For more details about the Nimble installation, refer to this document: <https://github.com/nim-lang/nimble#installation>





5.3  The `nimble` command-line tool
===================================



You should now have Nimble installed on your system. Running `nimble` in a new terminal window should display a list of commands that are supported by Nimble. *Figure 5.4* shows just a few of these commands.




Figure 5.3. Some of the commands that Nimble supports


![ch05 nimble help](../Images/ch05_nimble_help.png)

You can also see the order in which commands should be passed to Nimble in *Figure 5.4*. A single command is written after "nimble", separated by a space. What follows then are the flags and parameters passed to that command, each separated by a space. For example, to search for any packages which relate to Linux you can execute `nimble search linux`. You can also specify a `--ver` flag which will show you the available versions of each package. *Figure 5.5* shows the result of a search for "linux" with the `--ver` flag.




Figure 5.4. Searching for a "linux" package with version information


![ch05 nimble search ver](../Images/ch05_nimble_search_ver.png)

Note the "versions:" followed by a list of 2 different versions in *Figure 5.5*. Those are the versions of the `daemonize` package which can be installed.


Nimble’s command-line interface is the primary way of installing, searching, upgrading and removing packages. Before I show you how to install packages, let’s learn more about what a package actually is.





5.4  What is a Nimble package?
==============================



Software is almost always composed of different types of files including source code, images, sound and more. For example, let’s say you are creating a video game. Video games require a plethora of resources to function, and these need to be bundled together with the game’s executable. A package offers a convenient way to bundle such files together with the software.


In the simplest sense, a minimal *Nimble package* is a directory containing a `.nimble` file and one or more Nim modules.


A `.nimble` file contains metadata about a package. It specifies a package’s name, version, author, dependencies and more. The `.nimble` is just a file extension, the file name of every `.nimble` file is the same as the name of the package. *Listing 5.2* shows a simple example of a `.nimble` file.




Listing 5.1. The `MyPkg.nimble` example `.nimble` file.




```
[Package]
name          = "MyPkg"     ❶
version       = "0.1.0"     ❷
author        = "Dominik Picheta"
description   = "Example .nimble file."
license       = "MIT"

[Deps]
Requires: "nim >= 0.12.0"   ❸
```




|  |  |
| --- | --- |
| [❶](#CO1-1) | The name specified here must be the same as the filename plus the `.nimble` extension, i.e. `MyPkg.nimble`. |
| [❷](#CO1-2) | Versions usually consist of 3 digits separated by periods, and their meaning follows semantic versioning [[18]](#ftn.d5e5758). You can specify as many digits as you want, but other characters are not supported. |
| [❸](#CO1-3) | This specifies that the package requires at least version 0.12.0 of the Nim compiler to be successfully compiled. |





The format of the `.nimble` file is similar to the *ini* configuration file format. Sections are delimited by square brackets, key and value pairs are specified using the `key = "value"` syntax or the `key: "value"` syntax. *Figure 5.6* below shows what the contents of a typical standalone Nimble package look like.




Figure 5.5. A typical Nimble package


![ch05 nimble file](../Images/ch05_nimble_file.png)

The data specified in the `MyPkg.nimble` file in *Listing 5.2* is mandatory, and there are many other options you can specify in a `.nimble` file as well. Far too many exist to list them all here, but you will learn about some of them later in this chapter. For a full list, check out the Nimble documentation on Github: <https://github.com/nim-lang/nimble#readme>




An alternative `.nimble` format



Nimble recently gained support for a brand new Nim-based configuration format. It is called Nimscript and it is a subset of the full Nim language. This syntax makes it very easy to define more complex packages using Nim code.


One important use case that Nimscript allows is specifying dependencies based on the operating system Nimble is running on.


An equivalent to `MyPkg.nimble` using Nimscript would look like the following:




```
# Package information
version       = "0.1.0"
author        = "Dominik Picheta"
description   = "Example .nimble file."
license       = "MIT"


# Dependencies
requires "nim >= 0.12.0"
```


As you can see the syntax is mostly the same. The two big differences are the lack of `name` field, which is redundant anyway, and the slightly different syntax for specifying dependencies. The sections delimited by square brackets are also gone and no longer necessary.


Where Nimscript begins to shine is with the ability to specify custom tasks, for example:




```
task tests, "Run the packages tests!":
  exec "nim c -r tests/mytest.nim"
```


Placing that snippet of code at the bottom of your `.nimble` file will allow you to execute `nimble tests` which will execute the code specified for that task. In this case, the code will compile and run the `mytest.nim` file.



Assuming that you have a Nimble package somewhere on your local file system, you can very easily open a terminal in the directory of that package and execute `nimble install`. When you do this, Nimble will attempt to install the package contained in the current directory. This is useful for local packages which you likely have created yourself. But what about packages which have been created by other developers, do you need to download these manually?


Thankfully, the answer to that question is "No". As part of the `install` command a URL can be specified which points to the package that you want to install. Currently this URL must point to either a Git or Mercurial repository. This brings about the definition of an *external* package, one that can be accessed over the internet. An external Nimble package is either a Git or Mercurial repository containing a `.nimble` file and one or more Nim modules.




What is Git and Mercurial?



Both Git and Mercurial are examples of a Distributed Version Control System (DVCS). A DVCS enables a team of software developers to work together on a software project, it helps to deal with situations where two or more developers end up editing the same files. It does this by keeping track of the history of each of these files instead of simply overwriting the files and storing the newest revision.


A Git (or Mercurial) *repository* is a place where the history of a software project is stored. These repositories can be uploaded to a remote server and then subsequently downloaded using the `git` and `hg` command-line tools, for Git and Mercurial respectively. This allows other developers to work on the project and upload their changes which you can then download.


After a repository is downloaded, the history of the files can be explored. You can for example see what the state of the repository looked like a week ago, all the way to when the repository was first created.



Git and Mercurial repositories may contain additional information, for example they support something called tags. A tag identifies a particular revision in the history of the repository. Repositories containing Nimble packages must contain a tag which identifies each version of that package. *Figure 5.7* below shows how an external Nimble package’s content change between revisions.




Figure 5.6. An external Nimble package’s evolution


![ch05 nimble repo](../Images/ch05_nimble_repo.png)

In the previous section I have shown you how the `search` command works. With the `--ver` flag, the `search` command lists the tags of each of the package repositories. Nimble interprets each tag as a version.


Nimble packages are coupled to repositories because most libraries and applications are already stored in a repository. Turning that repository into a Nimble package is easy, it just needs a `.nimble` file. Other package managers store their packages on a single centralised server, this has its advantages and is something that Nimble will eventually also support.



  


[[18]](#d5e5758) <http://semver.org>







5.5  Installing Nimble packages
===============================



The installation of Nimble packages is likely the most common task that you will use Nimble for. You have already seen an example of the `install` command in the previous section. This command provides the primary means of installing packages.


The install command is powerful, it can:



* Install packages on your local file system.
* Install packages from a specified URL.
* Install a package by name.
* Install a specific version of a package.
* Install multiple packages at once.





5.5.1  Using the `install` command
----------------------------------



The installation of local packages is simple. Just open a new terminal, `cd` into the directory of your local package (by typing `cd /home/user/MyPkg` for example), and execute `nimble install`.


To install a package from a URL: just open a new terminal and execute `nimble install <your_url_here>`, replacing the `<your_url_here>` with the URL to the package that you want to install. Currently the URL must point to a non-empty Git or Mercurial repository.


Nimble saves you the trouble of remembering a bunch of URLs to different packages. A package repository which contains a listing of packages created by the Nim community is available. Nimble downloads this listing, which contains some basic information about each package such as the package’s URL and name. Remember the `search` command? It searches through this listing. Any of the packages listed in your search results can be installed, simply specify their name after the `install` command. For example, to install the `daemonize` package seen in the search results in *Figure 5.5* just execute `nimble install daemonize`.


A specific version of a package can be installed by using the special `@` character after the name of a package. For example, to install version `0.1.0` of the `daemonize` package execute `nimble install daemonize@0.1.0`. Instead of specifying a specific version you can also specify a version range, for example if you want to install the latest version that is greater than version `0.1.0` you can execute `nimble install daemonize@>=0.1.0`. Specifying a repository revision is also supported by using the `#` character after the `@` character, for example `nimble install daemonize@#b4be443`.





|  |  |
| --- | --- |
| [Warning] | Special characters in shells |
| Depending on your shell some of the characters, such as `@`, `>`, or `=` may be treated as part of the shell’s syntax. You may need to escape them or quote the package name and version like so: `nimble install "daemonize@>=0.1.0"`. |



Specifying multiple parameters to the `install` command will cause Nimble to install more than one package. The parameters just need to be separated by a space.





5.5.2  How does the `install` command work?
-------------------------------------------



To learn about what the `install` command does, let’s look at the above example command: `nimble install daemonize`. Try executing it now if you haven’t already. You should see output similar to the one in *Figure 5.8*.




Figure 5.7. The output of `nimble install daemonize`.


![ch05 nimble install](../Images/ch05_nimble_install.png)

Nimble’s output is currently rather verbose, but it tries to give as much information about the installation as possible. The output that you see in *Figure 5.8* may be different in your version of Nimble. But the key information should remain the same. The messages shown in *Figure 5.8* show each of the files from the `daemonize` package being copied into `/Users/dom/.nimble/pkgs/daemonize-0.0.2/`.


Scroll up in your terminal window and you will see what Nimble does first; begins downloading the package. But before I get to that let me mention what it *actually* does first. Before a download is started Nimble needs to know where to download the `daemonize` package from. It does so by consulting the package list. *Figure 5.9* shows the full installation process and its many sub-processes.




Figure 5.8. The Nimble installation process


![ch05 nimble install process](../Images/ch05_nimble_install_process.png)

The package list is currently hosted in a Git repository, the list can be accessed on a website called GitHub at the following URL: <https://github.com/nim-lang/packages>. The package list repository stores a `packages.json` file which contains a list of metadata about different packages. The metadata includes each package’s name, URL, description and more. Nimble can read this list, find the package that you specified on the command line and retrieve that package’s URL. That way Nimble knows the location of that package’s repository and can easily download it. *Figure 5.10* shows how the `daemonize` package is found in the `packages.json` file.




Figure 5.9. Finding information about the `daemonize` package in the `packages.json` file


![ch05 nimble pkg list](../Images/ch05_nimble_pkg_list.png)




|  |  |
| --- | --- |
| [Note] | Package lists |
| The package list stored in <https://github.com/nim-lang/packages> is the official Nimble package list. You can very easily create your own package list with packages which you may wish to keep private. As of version 0.7.0, Nimble supports multiple package lists so you can easily use your own package list in conjunction with the official one. The *Configuring Nimble* section of the Nimble readme explains how this can be done: <https://github.com/nim-lang/nimble#configuration> |



The download is done using either Git or Mercurial. As part of the download process, Nimble checks the tags which have been created on the remote repository. It parses each of the tags and determines which satisfies the version requirements specified by the user. If more than one tag satisfies the version requirements then it picks the highest version. *Figure 5.11* below shows how Nimble decides which commit of a Nimble package to install.




Figure 5.10. How Nimble decides which version of a package to install


![ch05 nimble install tags](../Images/ch05_nimble_install_tags.png)

Once the download is complete the package’s `.nimble` file is read. Nimble verifies the validity of this file. Before installation can commence the following must be checked and verified to be true:



* The `.nimble` file’s name must correspond to the `name` field specified in the `.nimble` file.
* The `version` field specified in the `.nimble` file must correspond to the version that was tagged on the repository.
* The files which will be installed must follow a specific directory layout.
* The correct dependencies specified in the `.nimble` file must be installed.



Those are some of the most common checks that Nimble performs. If the first three fail they will result in an error and the package will not be installed. Missing dependencies will actually be installed automatically by Nimble. You will learn more about these checks in the next section where I will show you how to create your own Nimble package.


Once the package is successfully validated, the installation commences and Nimble copies all of the files in the package to `~/.nimble/pkgs/pkg-ver` where `ver` is the version of the package and `pkg` is the name of the package.


That is just a simple overview of the process involved in the installation of a Nimble package. This process can become more complicated depending on the options specified in the `.nimble` file.






5.6  Creating a Nimble package
==============================



You have likely encountered situations where a set of functionality in your application could be reused in another application. As an example, in *Chapter 3* you have developed a `protocol` module which defines procedures for encoding and decoding chat messages. You may wish for that module to be usable in other applications.


The easiest way to do so is to create a package out of that module. Your applications can then add that package as a dependency and use the same module easily.


Creating a Nimble package out of your Nim library or application has a number of advantages. These include making the installation of dependencies much easier, and allowing others to use your package as a dependency for their own packages.


Creating a Nimble package is also fairly straightforward. All you need to do is create a `.nimble` file and you’re good to go. Nimble includes a command which makes the creation of this file much easier. The `init` command which will ask you some questions about the package and create a `.nimble` file for you based on your responses to those questions. You will likely still need to edit the resulting `.nimble` file manually to customise the options further. But once you understand what those options do that also becomes straightforward.


That is all that is needed to create a local Nimble package, but you might also want to open source your package and publish it in Nimble’s package list. In order to do this you will need to initialise a new Git or Mercurial repository. If you have never used either then I recommend choosing Git as it is more widely supported. Later in this chapter, I will show you how a Nimble package can be published.


In this section I will show you how to create a Nimble package out of a barebones Nim project. But why should you spend time creating Nimble packages?


Imagine that you are writing a brand new library which includes some simple procedures for manipulating numbers. You have two applications, one is a simple calculator application whereas the other is a more specialised application for calculating taxes. You want to use your library in both of those applications, in addition to that you also would like to allow others to use it in their own applications.


You could simply copy and paste your library beside both of your applications. Then distribute it to other developers by compressing it and sending the resulting zip archive via email. There are many problems with this approach, for example:



* Developers rely on you to send them your library, wasting your precious time.
* Developers have no easy way of discovering that your library exists.
* You must manually ensure that your applications have the latest version of your library.



Packaging your library using Nimble solves many of these problems. Developers have an easy way of finding your library, using Nimble’s search functionality. You only need to upload your library once, and after doing so, yourself and others can easily use the latest version of your library.


With all of that in mind, let’s create a simple Nimble package.




5.6.1  Choosing a name
----------------------



A package’s name is very important. It needs to be as short as possible and ideally describe what functionality the package implements.





|  |  |
| --- | --- |
| [Note] | Uniqueness |
| When picking a name it is a good idea to ensure that it is unique, especially if you intend to publish such a package to the Nimble package repository. |



You must pick a name which does not contain any hyphen or at symbols (`-` or `@`). Those characters are treated uniquely by Nimble and are thus disallowed in package names.


The package that you will create as part of this chapter will implement some very simple procedures for manipulating numbers. You may choose whatever package name you wish, but throughout this chapter I will use the name `NimbleExample` and will assume that you have done the same.


Now create a `NimbleExample` directory somewhere on your file system which will contain the Nimble package.





5.6.2  A Nimble package’s directory layout
------------------------------------------



All Nimble packages must adhere to a specific directory layout. This directory layout is more important for libraries than applications, because an application will be compiled and in most cases all that needs to be installed will be the application’s executable.


For libraries, the most important rule is to place all modules in a separate directory named after the package. So create another `NimbleExample` directory inside the `NimbleExample` directory you have already created. Any modules placed inside that directory will be importable with the `NimbleExample/` prefix, for example `import NimbleExample/module`.


One exception to this rule is that you can place a single module containing the primary functionality of your library in the root directory of your package. But it must share the name of your package. In this case the module’s filename would be `NimbleExample.nim`. *Figure 5.12* shows what the final directory structure of `NimbleExample` is going to look like.




Figure 5.11. The `NimbleExample` directory layout


![ch05 nimble dir layout](../Images/ch05_nimble_dir_layout.png)

For the purposes of this example create the following file inside the secondary `NimbleExample` directory.




Listing 5.2. The `math.nim` module.




```
proc add*(a, b: int): int = a + b   ❶
```




|  |  |
| --- | --- |
| [❶](#CO2-1) | Define new `add` procedure taking two integers and returning the sum of those two integers. This procedure is exported using the `*`. |





The code in *Listing 5.3* is pretty straightforward, it defines a new `add` procedure which adds two integers together. Note the `*` used to export the procedure, it ensures that the `add` procedure can be accessed from other modules. Save the code in *Listing 5.3* as `math.nim` in `NimbleExample/NimbleExample`.


There is an additional convention used for modules in a package which are destined to be only used by that package. They should be placed in a `private` module as done with the `utils` module defined in *Listing 5.4* below.




Listing 5.3. The `utils.nim` module.




```
proc mult*(a, b: int): int = a * b   ❶
```




|  |  |
| --- | --- |
| [❶](#CO3-1) | Define a new `mult` procedure taking two integers and returning the result when those numbers are multiplied. This procedure is exported using the `*`. |





Create a new directory named `private` in the `NimbleExample/NimbleExample` directory. Save the code in *Listing 5.4* as `utils.nim` in `NimbleExample/NimbleExample/private`.




Listing 5.4. The `data.nim` module.




```
import NimbleExample/math            ❶
import NimbleExample/private/utils   ❷
let age* = mult(add(15, 5), 2)       ❸
```




|  |  |
| --- | --- |
| [❶](#CO4-1) | Import the `math` module from the `NimbleExample` package. |
| [❷](#CO4-2) | Import the private `utils` module from the `NimbleExample` package. |
| [❸](#CO4-3) | Use the procedures defined in the `utils` and `math` modules to calculate the age. The `age` variable is exported using the `*`. |





The code in *Listing 5.5* is a bit more complicated. It imports two modules defined in the `NimbleExample` package. The first is the `math` module defined in *Listing 5.3* and the other is the `utils` module defined in *Listing 5.4*. Save the code in *Listing 5.5* as `data.nim` in `NimbleExample/NimbleExample`.


*Figure 5.13* shows what the final directory layout should look like, ensure that your local directory layout is the same.




Figure 5.12. The `NimbleExample` directory layout


![ch05 nimble dir layout](../Images/ch05_nimble_dir_layout.png)




5.6.3  Writing the `.nimble` file and sorting out dependencies
--------------------------------------------------------------



Now that the modules have all been placed in the correct directories it’s time to create the `NimbleExample.nimble` file. You can execute `nimble init` which will create a simple one for you. *Figure 5.14* shows an example of what `nimble init` asks as well as the answers needed to generate the `NimbleExample.nimble` file shown in *Listing 5.6*.




Figure 5.13. The `nimble init` command


![ch05 nimble init](../Images/ch05_nimble_init.png)



Listing 5.5. The beginnings of `NimbleExample.nimble`




```
# Package

version       = "0.1.0"
author        = "Your Name"
description   = "Simple package to learn about Nimble"
license       = "MIT"

# Dependencies

requires "nim >= 0.12.0"
```



After you execute `nimble init` or save the contents of *Listing 5.6* as `NimbleExample.nimble`, you should be able to execute `nimble install`. That should successfully install your package!


That is how simple it is to create a Nimble package. But creation of a Nimble package is just a small first step to developing Nimble packages. Packages evolve and with that requirements change, so how can Nimble help us during development?


While developing your package, you may some day realise that you need the functionality of another Nim library. In many cases this library will be a Nimble package. For example, you may want to create a version of `add` for very large integers, ones that are bigger than the biggest integer type in Nim’s standard library can store. The `bigints` package provides this functionality.


Open the `math.nim` file in the `NimbleExample` package and change it so that its contents are the same as those of *Listing 5.7*. Changes are highlighted in bold.




Listing 5.6. Using the `bigints` package in the `math` module




```
**import bigints**   ❶
proc add*(a, b: int): int = a + b
**proc add\*(a, b: BigInt): BigInt = a + b**   ❷
```




|  |  |
| --- | --- |
| [❶](#CO5-1) | Import the `bigints` module from the `bigints` package. No need to explicitly state the package name and module name. |
| [❷](#CO5-2) | Define an `add` procedure for the `BigInt` type defined in the `bigints` module. |





Now try to compile it by executing `nim c NimbleExample/math`. The compiler should output something similar to `math.nim(1, 8) Error: cannot open 'bigints'`. This points to the line of code which imports the `bigints` module. The reason the compilation fails is because the `bigints` package has not been installed. Install it now by executing `nimble install bigints`. Now compile `NimbleExample/math` again. This time the compilation should succeed.


Does this mean that every user of the `NimbleExample` package will need to install the `bigints` package manually? Currently, yes. But this is where the dependency specification in the `NimbleExample.nimble` file comes in.


When compiling any Nim source code using the Nim compiler, every package that you have installed using Nimble will be available to that source code. This is why importing the `bigints` module works as soon as you install the `bigints` package.




Global Nimble packages and the Nim compiler



By default, when installing a package using Nimble, the package is installed into the current user’s Nimble package store which is located in `~/.nimble/`. Every time you compile a Nim module using the Nim compiler, that module can import any of the modules belonging to any of the packages in Nimble’s package store.


But what if there are two versions of the same package installed? In that case Nim will simply use the latest one.



Now try to compile the same file using Nimble. Nimble supports a handy `c` command which does exactly what the Nim compiler does, it compiles the specified file. Now execute `nimble c NimbleExample/math` and note the results. You may be surprised by the failure, but it illustrates the key difference between compiling with the Nim compiler directly and compiling with Nimble. Nimble does not let you import any modules whose packages you have not specified as dependencies in your project’s `.nimble` file.


Let’s change the `NimbleExample.nimble` file so that it includes the `bigints` package as a dependency. *Listing 5.8* shows what the `NimbleExample.nimble` file should now look like, differences are highlighted in bold.




Listing 5.7. Adding a dependency on the `bigints` package




```
# Package

version       = "0.1.0"
author        = "Your Name"
description   = "Simple package to learn about Nimble"
license       = "MIT"

# Dependencies

requires "nim >= 0.12.0, **bigints**"
```



The dependency on `bigints` in *Listing 5.8* specifies no requirements on the version of that package. In such a case Nimble will attempt to install the latest *tagged* version of that library, that is assuming that one is not already installed.





> Tip Cutting edge dependencies |
| You can specify `#head` after the package’s name, for example `bigints#head`. This will get Nimble to always compile your package with the latest revision of that package available. *Figure 5.15* below shows the difference between specifying and not specifying `#head`.


Figure 5.14. Difference between `#head` and no `#head`
ch05 nimble install tags
 |



Once you change your `NimbleExample.nimble` file to match *Listing 5.8* you should be able to successfully compile the `math` module using Nimble. Nimble will even automatically install the `bigints` package for you if it detects that it is not installed! *Figure 5.16* below shows the difference between `nim c` and `nimble c` depending on whether the `bigints` package has been installed.




Figure 5.15. `nim c` vs. `nimble c`


![ch05 nimble c nim](../Images/ch05_nimble_c_nim.png)

You should now have a basic understanding of how Nimble handles dependencies and should have the knowledge necessary to create more Nimble packages. There is one piece of knowledge still missing and that is the process involved in publishing Nimble packages.


Before you move onto the next section which talks about publishing your Nimble package, I would like to give you a quick challenge. Write some simple tests for this Nimble package inside some of this package’s modules, after doing so run those tests by using Nimble’s `c` command. This should get you started: `nimble c -r NimbleExample/math`, specifying the `-r` flag will mean that the the resulting executable is run automatically after compilation. Remember to put your tests under a `when isMainModule:` statement, this statement ensures that any code in its body is only executed when the `math` module is compiled directly. The reason it should be used is so that tests are not executed when the `math` module is imported in an application.






5.7  Publishing Nimble packages
===============================



The process of publishing a Nimble package to the official package list is fairly straightforward. But before your package is published, it must first go through an approval process. Currently the approval process isn’t very strict, as long as your package’s name does not clash with any of the existing package’s already in the list, it will be accepted.


As mentioned previously, before your package can be published you must first upload it to a Git or Mercurial repository hosting service such as Github or BitBucket.


So the first thing that you need to do is initialise a Git or Mercurial repository in your package’s directory. I will show you how to create a Git repository. The choice of repository type does not matter much, it’s mostly a matter of preference. But nowadays Git is more widely adopted so let me show you how to create a repository using it.





|  |  |
| --- | --- |
| [Note] | Version control |
| The details of distributed version control, Git, and Mercurial are outside the scope of this book. I recommend you read up on these technologies further if you are not familiar with them. |



Before we get started, you will need to create an account on <http://github.com> if you do not already have one. Go there now and do so.


After you have an account set up and are logged in, create a new Git repository on GitHub by clicking a button labelled "New Repository". In case you can’t find such a button, you can just navigate to the following URL: <https://github.com/new>. You should see something similar to the screenshot in *Figure 5.17*.




Figure 5.16. Creating a new repository on Github


![ch05 github new repo](../Images/ch05_github_new_repo.png)

Specify "NimbleExample" as the "Repository Name" then click the green "Create Repository" button. You will then be shown another webpage, this webpage will let you know how to create a repository on the command-line. The instructions on the webpage are very generic, *Listing 5.9* shows commands similar to ones seen on the webpage but ones which are tailored to successfully upload the `NimbleExample` package to GitHub. Execute these commands now.




Listing 5.8. Commands to upload the `NimbleExample` package to GitHub.




```
git init
git add NimbleExample.nimble NimbleExample/data.nim NimbleExample/math.nim NimbleExample/private/utils.nim
git commit -m "first commit"
git remote add origin git@github.com:<your-user-name>/NimbleExample.git   ❶
git push -u origin master
```




|  |  |
| --- | --- |
| [❶](#CO6-1) | Remember to change `<your-user-name>` to your Github username! |





Once you successfully execute those commands, navigating to [https://github.com/<your-user-name>/NimbleExample](https://github.com/<your-user-name%3E/NimbleExample) should show you a list of files. These files should include the `NimbleExample.nimble` file, the `NimbleExample` directory and its contents.


There is only one thing left to do. The package is public but Nimble has no way to find it yet because it has not been added to its package list. What this means is that you won’t be able to install it by executing `nimble install NimbleExample`.


Nimble can make use of multiple package lists, but the official package list is the most widely used. The official package list is stored in a GitHub repository located here: <https://github.com/nim-lang/packages>. Something called a pull request is created whenever a user wants to add a package to this package list. After a pull request is created, the Nim community ensures that the package can be added to the package list. Certain aspects of the package are checked, for example the package’s name to ensure it does not clash with the names of any other packages that are already in the list.


Before publishing a package it is always a good idea to ensure that it can be installed successfully. Execute `nimble install` in the package’s directory to verify that it can be installed successfully.


The package is then ready to be published. You can either create a pull request manually or use Nimble’s `publish` command. Execute `nimble publish` now and follow the on-screen prompts.


The process is somewhat complex as it requires you to create a new GitHub access token for Nimble. But once you do so it streamlines the process of publishing Nimble packages significantly.


When your package is accepted and is added to the package list, you will be able to install it by executing `nimble install NimbleExample`.


Remember that publishing a Nimble package is only done once. There is no need to publish the package again when a new version of it is developed, instead the version is tagged as you will find out in the next section.





5.8  Developing a Nimble package
================================



Software projects are typically given versions to determine their state. Software constantly evolves and new developments are marked using increasing version numbers. Nimble packages are no different. The `NimbleExample` package began its life as version `0.1.0`, and if it continues to be developed, it may some day reach version `1.0` or even `10.3`. Versions help the user distinguish and identify different states of your package.


Version information for your package is stored in your package’s `.nimble` file. It is specified using the `version` key. The version must consist of at least one digit, multiple digits must be separated by periods. For example `version = "1.42.5"`.




5.8.1  Giving version numbers meaning
-------------------------------------



The way in which version numbers are assigned and incremented differs. In some cases the version numbers have little meaning other than signifying that version `1.0` is newer than version `0.5`. In others, such as with Semantic Versioning, the version numbers tell you more about the API compatibility of different versions of software.


Semantic Versioning is a convention for specifying a three-part version number: major version, minor version and patch. The patch is incremented for minor bug fixes and changes which do not affect the API of the software. The minor is incremented when backward compatible additions are made to the software. Lastly, the major version is incremented when the API of the software changes into something that is not backward compatible. The full Semantic Versioning specification is available at <http://semver.org>.


You may be tempted to come up with your own rules for package versioning schemes. But I would definitely recommend using Semantic Versioning for your Nimble packages.





5.8.2  Storing different versions of a single package
-----------------------------------------------------



There are some things that you need to keep in mind with versioning and Nimble packages.


A local Nimble package which does not have a Git or Mercurial repository associated with it, has a specific version associated with it. This is the version in the `.nimble` file.


Local Nimble packages which do have a Git or Mercurial repository associated with them are the same. But different versions of those packages can be retrieved because their repository contains a full history of the package. This makes retrieving previous versions of the package easy. This also applies to remote Nimble packages, they are currently all stored in such repositories. This repository can be downloaded giving you a local repository containing each version of the Nimble package.




Figure 5.17. Local Nimble package with no repository vs. one with a Git repository


![ch05 repo versioning](../Images/ch05_repo_versioning.png)

When developing Nimble packages it is important to remember one thing. Nimble uses the tags which are stored in the Nimble package’s repository to identify the point in history where a certain version is stored.


Whenever you want to release a new version of a package you need to follow these steps:



1. Increment the version number in the `.nimble` file.
2. *Commit* these changes into your repository. For example: `git commit -am "Version 0.1.2"`.
3. Tag the commit you just made, use the new version number as the tag name. For example: `git tag v0.1.2`.
4. Upload the changes to the remote repository, make sure to upload the tags as well. For example: `git push origin master --tags`.



Performing step 1 first is very important. If the name of the tag doesn’t match the version specified in the `.nimble` file at the point in history that the tag corresponds to, then there will be an inconsistency and Nimble will refuse to install the package.


The steps needed to tag versions above are specific to Git. You will find that in order to develop Nimble packages you will need at least a very basic knowledge of Git or Mercurial.






5.9  Summary
============



Nimble is not a requirement for developing Nim software, but it is a useful tool that gives you access to hundreds of packages which can make the job of implementing your software easier.


You should now know how to use the Nimble command-line tool, including how to install Nimble packages, how to search for packages, and how to create new packages. You will have successfully created your own Nimble package and should have the ability to share it with the rest of the Nim community.


This chapter covered:



* An overview of what a package manager is and the different package managers available.
* Instructions on how to install Nimble.
* Using the Nimble command-line interface.
* Using the `install` command to install Nimble packages.
* Creating Nimble packages.
* Publishing Nimble packages.



In the next chapter you will find out how concurrency works in Nim. By looking at a number of examples and seeing how they can be made to utilize concurrency you will learn about concurrency features in Nim and in which circumstances those features should be used.




