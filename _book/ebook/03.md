

3
=


Writing a chat application
==========================


This chapter covers:



* Asking the user for input
* Creating a command line interface
* Parsing and generating JSON
* Transferring data over the network
* Using and creating modules



In the previous chapter, you learned how to set up the Nim compiler and its environment, which allowed you to compile your first Nim application. You also learned the basics of the Nim programming language including the syntax, some of the built-in types, information on how to define variables and procedures, control flow statements, exception handling, how to define custom types, and more.


In this chapter you will build upon and solidify that knowledge by developing a fully functioning chat application. You will also learn many new concepts that are essential to the development of certain applications. In particular, you will:



* Build a command-line interface, which will act as a way to ask the user for input.
* Learn how to use sockets to transfer data over networks such as the Internet.
* Use a JSON parser to build a simple chat protocol. This will be used to allow your chat application to exchange messages in a standard and consistent manner.
* Learn how to use modules to separate your code into standalone units, which will make your code more reusable.



With the popularity of the Internet, computer networks have become increasingly important. The most basic feature of the Internet is the transfer of data, a feature that may not be very easy at the programming language level. A chat application is a good way to introduce the basics of transferring data between multiple computers, which is why I will be using it as an example for this chapter.


By the end of this chapter you will have successfully written an application consisting of two different components: a server and client. You will be able to send the client component to your friends and then use it to chat with each other in realtime over the Internet.


Let’s get started. The next section will introduce you to the details of how the application will work.




3.1  The architecture of a chat application
===========================================



The main purpose of the chat application is to allow multiple people to communicate using their personal computers. One way to accomplish this task is by using a network to which these computers are connected, like the Internet, and sending data over it. Unlike applications such as Facebook Messenger, or WhatsApp, which are primarily used for one-on-one communication, the chat application developed in this chapter will primarily support group communication (many-to-many) similar to Internet Relay Chat or Slack. This means that a single message will be sent to multiple users.


**What will the finished application look like?**


Let’s say I just watched the latest Game of Thrones episode and am now excited to speak with my friends about it. I will call them John and Grace, just in case they don’t appreciate me using their real names in this book. The conversation might go something like this (no Game of Thrones spoilers, I promise):




Listing 3.1. Conversation between me, John and Grace about Game of Thrones




```
*Dominik said* What did you guys think about the latest Game of Thrones
episode?
*Grace said* I thought Tyrion was really great in it!
*John said* I agree with Grace. Tyrion deserves an Emmy for his performance.
```



At the end of this chapter you will have built an application which will allow this discussion to take place. Let me show you what the finished application will look like in the context of the conversation outlined in *Listing 3.1*.


After executing the client component of the chat application and allowing it to connect to the server, I will be able to begin sending messages. I will first ask John and Grace what they thought of the latest Game of Thrones episode. I will do this by entering my message into the chat application, and pressing the Enter key to send it.




Figure 3.1. My screen after I send the message


![ch03 Dominik 1](../Images/ch03_Dominik_1.png)

Both John and Grace will receive this message on their computers. The client application will show it to both of them in the same way.




Figure 3.2. John’s and Grace’s screen


![ch03 john grace](../Images/ch03_john_grace.png)

Note that the message is prefixed by "Dominik said", letting John and Grace know who sent the message. Grace can then answer my question by typing in her response and pressing the Enter key to send it. With both John and myself receiving her reply. This way we can have a discussion over the internet relatively easily.


This should give you an idea of what you are aiming to achieve by the end of this chapter. Sure, it might not be as impressive as a full-blown application which includes a graphical user interface but it’s a start. Now let me move onto discussing some of the basic aspects of this application, in particular its network architecture.


**Network architectures and models**


There are two primary network architectures that can be used for this application: peer-to-peer networking and the client-server model. With peer-to-peer networking there is no server; instead, each client is connected to multiple other clients which then exchange information between each other. With the client-server model there is a single server to which all the clients connect. The messages are all sent to the server and the server redistributes them to the correct clients.




Figure 3.3. Client-server vs. Peer-to-peer


![ch03 network models](../Images/ch03_network_models.png)

The client-server model is the simpler of the two. As it also works well for the kind of application that you will be writing, it will be used as the basis for this chat application.


Another thing to consider is the transport protocol, which you will use for the transfer of messages in your application. The two major protocols which are in use today are TCP and UDP. Both of these protocols are used widely for many different types of applications but they differ in two important ways.


The most important feature of the TCP protocol is that it ensures that messages are delivered to their destination. This is achieved by sending extra information along with the messages, in order to verify that the messages have been delivered correctly. The TCP protocol does this at the cost of some performance.


The UDP protocol does not do this. With UDP the data is sent rapidly, the protocol does not check whether the data arrived at its destination. This makes UDP perform better than TCP, but has the effect of making the data transmission less reliable.


Chat applications should be efficient, but the reliable delivery of messages is more important. Based on this aspect alone: TCP wins.





> Note Networking |
| There is a vastly greater amount of information regarding the topic of networking that is outside the scope of this book. I encourage you to research this topic further if it is of interest to you. |



**The client and server components**


Now that you know a bit about the networking side of things, let’s talk about how the software will actually work. The plan is to create two separate applications, the first being a server and the second being a client application. Throughout this chapter I will refer to the client as the *client component* and the server as the *server component*.


When the server first starts, it will begin listening for connections from a client application on a specific port. The port will be hardcoded into the server and chosen ahead of time to not conflict with any other application. I wouldn’t want it to prevent you from enjoying a good game of Call of Duty now would I? Once a connection on that port is detected, the server will accept that connection and wait for messages from it. A newly received message will be sent to any other connection that was previously accepted by the server.


When the client first starts, it will connect to the server address which was specified on the command-line by the user. Once it successfully connects, the user of the client will be able to send messages to the server by inputting them through the command line. The client will also be actively listening for messages from the server and once a message is received it will be displayed to the user.




Figure 3.4. The operation of the chat application


![ch03 chat server](../Images/ch03_chat_server.png)

Those are just some of the details of how the chat application will operate. *Figure 3.8* shows the chat application’s operation in a simple use case involving 3 clients. Dom, John and Grace are all running clients connected to the Server. *Figure 3.8* shows Dom sending a "Hello" message through the client to the server. The server will accept this message and pass it on to other clients currently connected to it.


Our aim - by the end of this chapter - is to have finished an application that will allow us to make scenarios, such as the one described in Figure 3.8, a reality.


You should now have a good idea of how the chat application will work and should be well on your way to being ready to start implementing it. The next section will show you how!






3.2  Starting the project
=========================



By now you should have an idea of what you will be building. The previous section described how the chat application will work in some detail. This section will describe the first steps needed to begin the project. This chapter is very much an exercise and I encourage you to follow along with the development as you read it.


You might find it surprising but getting a project started in Nim is very quick and easy. Simply open your favorite text editor, create a new file and start coding. But before you do that, you should decide on a directory layout for your project. This is entirely optional, the compiler won’t mind if you save all your code in `C:\code`, but doing so is bad practice. You should ideally create a new directory just for this project, for example `C:\code\ChatApp` (or `~/code/ChatApp`). In that directory create a `src` directory to store all your source code. In the future you can, when necessary, create other directories such as `tests`, `images`, `docs` and more in your project. Most other Nim projects are laid out this way too. This project is small so it will only use the `src` directory for now. *Listing 3.2* below shows what a typical Nim project directory layout looks like.




Listing 3.2. Typical directory layout




```
MyAwesomeApp   ❶
├── bin        ❷
│   └── MyAwesomeApp
├── images     ❸
│   └── logo.png
├── src        ❹
│   └── MyAwesomeApp.nim
└── tests      ❺
    └── generictest.nim
```




|  |  |
| --- | --- |
❶](#CO1-1) | The root directory of the `MyAwesomeApp` project. |
❷](#CO1-2) | This directory holds all the executables for this project. |
❸](#CO1-3) | This directory holds all the images that are used by this project. |
❹](#CO1-4) | This directory holds all the Nim source code files relating to this project. |
❺](#CO1-5) | This directory holds all the Nim source code files which contain tests for the files contained in `src`. |





 





> Note Project directory layout |
| A good project directory layout is very beneficial, especially for large applications. It is better to set it up sooner rather than later. Separating your application source code from your tests means that you can easily write test code that does not conflict or otherwise affect your application. In general the separation also makes code navigation easier. |



Now create a `client.nim` file in the `src` directory. This file will compile into a `client` executable and act as the client component of the chat application.


You are now ready to start writing code. As a small test, begin by writing the following into your new `client.nim` file then save it.




```
echo("Chat application started")
```


In order to compile your new `client.nim` file follow these steps.



1. Open a new terminal window.
2. `cd` into your project directory, by executing `cd ~/code/ChatApp` where `~/code/ChatApp` should be replaced by the path to your project directory.
3. Compile the `client.nim` file, by executing `nim c src/client.nim`.






> Tip Aporia |
| If you are using Aporia, you can just press F4 or select Tools > Compile current file in the menu bar to compile the currently selected tab. You can also press F5 to compile and run. |



If you have done everything correctly you should see the following in your terminal window.




Figure 3.5. Successful compilation of `client.nim`.


![ch03 successful compilation](../Images/ch03_successful_compilation.png)




> Tip Output directory |
| By default the Nim compiler will produce the executable in the same directory as the file that was compiled. You can use the `-o` flag to change this. For example `nim c -o:chat src/client.nim` will place a `chat` executable in the current directory. |



Assuming that the compilation was successful, the executable that was created by the compiler can now be started. In order to start its execution, use the following command `./src/client`. This should display "Chat application started" on the screen and then exit.


You now have a good starting point for further development. We started out slowly, and so far your application is not doing much. But it should give you an idea of how all applications in Nim should be started and ensure that the Nim compiler works correctly on your computer.


Now that you have made a start on this project, let’s move on to the first task: the command line interface.





3.3  Retrieving input in the client component
=============================================



Applications typically expect to receive some sort of guidance from the user, this may be the URL of a website to navigate to or the filename of a video to play. Applications need this guidance because they sadly cannot (yet) read our intentions directly from our brains, they need explicit instructions in the form of commands or mouse clicks. The simplest way to guide a piece of software is to give it an explicit command.


In the case of the chat application, and more specifically the client component. One can assume that the pieces of input it will need are going to include, the address of the server to send messages to and one or more messages to send to that server. These are the bare minimum requirements that the chat application will have on the user.


With these things in mind, there needs to be a way to both ask the user for a specific input and a way to then actually get the data that the user enters using their keyboard. Let’s focus on the minimum data requirements that we need from the user. The address of the server that we want to connect to is somewhat critical. The client needs the address before it can do anything, so we should ask the user for that information as soon as the client starts. Until we connect to the server, the user will not be able to send any messages, so asking the user for a message to send will come after.


**Retrieving command-line parameters supplied by the user**


On the command-line, there are two ways you can get data from the user:



* Through command-line parameters, which are passed to your application when it is started.
* Through the standard input stream, which can be read from at any time.



Typically a piece of information such as the server address would be passed to an application through the command-line parameters because the server address needs to be known at the very start of the application.


In Nim, command-line parameters can be accessed via the `paramStr` procedure defined in the `os` module. To use the `paramStr` procedure, you must first import the `os` module. To do this, add `import os` at the top of the `client.nim` file. You can then extend `client.nim` to read the first command-line parameter, in order to do so change your code to the code listed in *Listing 3.3*. The code which was added is shown in bold.




Listing 3.3. Reading command-line parameters




```
**import os**               ❶
echo("Chat application started")
**if paramCount() == 0:**   ❷
  **quit("Please specify the server address, e.g. ./client localhost")**   ❸

**let serverAddr = paramStr(1)**         ❹
**echo("Connecting to ", serverAddr)**   ❺
```




|  |  |
| --- | --- |
❶](#CO2-1) | This is required in order to use the `paramCount` procedure as it is defined in the `os` module. |
❷](#CO2-2) | Ensure that the user has specified a parameter on the command-line. |
❸](#CO2-3) | Stop the application prematurely as it cannot continue without that parameter. |
❹](#CO2-4) | Retrieve the first parameter that the user specified and assign it to new `serverAddr` variable. |
❺](#CO2-5) | Display the message `"Connecting to <serverAddr>"` to the user where `<serverAddr>` is the address the user specified. |





It is always important to check the amount of parameters supplied to your executable. The `paramCount` procedure returns the number of parameters as an integer. The above example checks whether the number of parameters is 0, if so it calls the `quit` procedure with a detailed message of why the application is exiting. The `quit` procedure exits the application, if supplied with a message it first displays that message and quits with an exit code that tells the operating system that the application failed.


When the user does supply the command-line parameter then the `paramStr` procedure is used to retrieve the first parameter supplied. An index of 1 is used because the executable name is stored at an index of 0. The first command-line parameter is then bound to the `serverAddr` variable.





|  |  |
| --- | --- |
Warning] | Executable name |
| Do not retrieve the executable name via `paramStr(0)` as it may give you OS-specific data which is not portable. The `getAppFilename` procedure defined in the `os` module should be used instead. |






|  |  |
| --- | --- |
Caution] | Always use `paramCount` |
| When accessing a parameter through the `paramStr` procedure which does not exist (for example `paramStr(56)` when `paramCount() == 1`), an `IndexError` exception is raised. You should always use the `paramCount` ahead of time, to check the amount of parameters that have been supplied. |



The last line in *Listing 3.3* uses the `echo` procedure to display the string `"Connecting to "` appended to the contents of the `serverAddr` variable on the screen. The `echo` procedure accepts a variable number of arguments, and displays each of them on the same line.





> Tip Parsing command-line parameters |
| Applications typically implement a special syntax for command-line arguments. This syntax includes flags such as `--help` and more. The `parseopt` module included in Nim’s standard library allows these parameters to be parsed. There are also other more intuitive packages created by the Nim community for retrieving and parsing command-line parameters, you will learn about them in the later chapters of this book. |



Recompile your new `client.nim` module by using the command from the previous section and execute it just like you did previously.




Figure 3.6. Starting the client without any parameters


![ch03 exec1](../Images/ch03_exec1.png)

As you can see in *Figure 3.10*, the application will exit immediately with the message *"Please specify the server address, e.g. ./client localhost"*. Now execute it with a single parameter, just as shown in the example: `src/client localhost`.




Figure 3.7. Starting the client with 1 parameter


![ch03 exec2](../Images/ch03_exec2.png)

You will note that the application now displays the message *"Connecting to localhost"*, now try specifying different parameters and see what results you get.


No matter how many parameters you type, as long as there is at least one, the message will always consist of *"Connecting to "* followed by the first parameter that you specified.


*Figure 3.12* shows how the command-line parameters map to different `paramStr` indexes.




Figure 3.8. The supplied command-line parameters and how to access them


![ch03 paramStr](../Images/ch03_paramStr.png)

Now that the client successfully captures the server address it will know which server to connect to. You now need to think about asking the user for a message that they want to send.


**Reading data from the standard input stream**


Unlike the command-line parameters which are passed to the application before it starts, we want to give the user the ability to send messages in realtime, in response to messages that they receive from other users. This means that what we want our application to ideally do is to always be ready to read data from the user.


While an application is running inside of a terminal or command-line, characters can be typed in the terminal window. These characters can be retrieved by the application through the standard input stream. Just like in Python, the standard input stream can be accessed via the `stdin` variable. In Nim, this variable is defined in the implicitly imported `system` module and it is of type `File`. This means that the standard input stream can be read from just like any other `File` object. There are many procedures defined for reading data from a `File` object, typically the most useful is the `readLine` procedure which reads a single line of data from the specified `File`.


Add the following code in *Listing 3.4* to the bottom of `client.nim`, then recompile and run it (you can do so quickly with the following command `nim c -r src/client.nim localhost`).




Listing 3.4. Reading from the standard input stream




```
let message = stdin.readLine()      ❶
echo("Sending \"", message, "\"")   ❷
```




|  |  |
| --- | --- |
❶](#CO3-1) | Read a single line of text from the standard input stream and assign it to the `message` variable. |
❷](#CO3-2) | Display the message *"Sending "<message>""* where `<message>` is the content of the `message` variable which contains the line of text the user typed into their terminal window. |





 





> Note Character escape sequences |
| The last line in *Listing 3.4* uses a character escape sequence in order to show the `"` character. This needs to be escaped because the compiler would otherwise think that the string literal has ended. |



You will see that your application no longer exits immediately, it instead waits for you to type something into the terminal window and press the Enter key. Once you do so, a message is displayed with the text that you have typed into the terminal window.


Reading from the standard input stream will cause your application to stop executing, your application will become *blocked*. The execution will resume once the requested data is fully read. In `stdin.readLine`'s case, the application remains blocked until the user inputs some characters into the terminal and presses the Enter key. When the user performs those actions, they are essentially storing a line of text into `stdin`'s buffer.


Blocking is an unfortunate side-effect of most Input/Output calls, it sadly means that your application will not be able to do any useful work while it’s waiting for the user’s input. This is in fact a problem, because this application will need to actively stay connected to the chat server, something which it will not be able to do if it is waiting for the user to type text into the terminal window. *Figure 3.13* below shows the problem that this causes.




Figure 3.9. Problem caused by the client being blocked indefinitely


![ch03 client blocked](../Images/ch03_client_blocked.png)

Before we move onto solving that problem. There is something missing from *Listing 3.4*, the code only reads the message once but the aim is to allow the user to send multiple messages. Doing so is relatively simple, you just need to introduce an infinite loop using the while statement. Simply wrap the code in *Listing 3.4* in a while statement as shown below.




```
while true:   ❶
  let message = stdin.readLine()   ❷
  echo("Sending \"", message, "\"")
```




|  |  |
| --- | --- |
❶](#CO4-1) | The `while` statement will repeat the statements in its body while its condition is `true`. In this case it will repeat the two statements below it until the application is closed manually by the user. |
❷](#CO4-2) | These two lines will be repeated an infinite number of times because they are indented under the while statement. |




Now compile and run your code again to see for yourself what the result is. You should be able to input as many lines of text as you wish into the terminal window, until of course you terminate your application by pressing the ubiquitous Control and C key combination (Ctrl + C at the same time).


When you terminate your application you should see a traceback similar to the following.




```
Traceback (most recent call last)
client.nim(9)            client
sysio.nim(115)           readLine
sysio.nim(72)            raiseEIO
system.nim(2531)         sysFatal
SIGINT: Interrupted by Ctrl-C.
```


Terminating your application is actually a very good way to determine which line of your code is currently being executed. Above you can see that when the application was terminated, line 9 in client.nim was being executed, this corresponds to `let message = stdin.readLine()` which is the blocking `readLine` call which waits for input from the user.




Figure 3.10. Current execution of `client.nim`


![ch03 input thread](../Images/ch03_input_thread.png)

*Figure 3.14* shows the current flow of execution in `client.nim`. The *main thread* becomes blocked as it waits for input from the user. Because of this the application will sit idle, until the user wakes it up by typing some text into the terminal window and pressing Enter. This is an inherent issue with blocking input/output operations, and we wouldn’t need to worry about it if the client only needed to react to user’s input. Unfortunately, as mentioned above, the client must keep a persistent connection to the server in order to receive messages from other clients.


**Using `spawn` to avoid blocking input/output**


There are a number of ways to ensure that your application does not block when it reads data from the standard input stream. One is *asynchronous input/output* which allows the application to continue execution even if the result is not immediately available. Unfortunately the standard input stream cannot be read asynchronously so asynchronous I/O cannot be used this time but will be used later on when it is time to transfer data over a network. It will be explained in more detail then. The other solution is to create another thread which will read the standard input stream, keeping the main thread unblocked and free to perform other tasks. I will show you how to modify `client.nim` in order to implement this solution now.


The full details of parallelism and how it works in Nim will not be described in this chapter but will be covered later on in this book. In short, every process consists of at least one thread and by default a process starts out with just one thread called the *main thread*. All of the code that is specified in `client.nim` is currently executed in that main thread. This main thread becomes blocked when the call to `readLine` is made. The thread becomes unblocked when the user inputs a single line into the terminal. A separate thread can be created in order to leave the main thread active, ensuring that the created thread is the one that becomes blocked.


A procedure can be executed in a new thread using the `spawn` procedure. The following code shows how this can be done. Replace it with the while statement that you created previously, but don’t compile the code just yet.




```
while true:
  let message = spawn stdin.readLine()   ❶
  echo("Sending \"", ^message, "\"")     ❷
```




|  |  |
| --- | --- |
❶](#CO5-1) | The `spawn` keyword is now used to call the `readLine` procedure, this will spawn a new thread and execute `readLine` there. |
❷](#CO5-2) | The value returned from the thread is not immediately available so reading it must be done explicitly by the `^` operator. |




The `readLine` procedure returns a string value. But when this procedure is executed in another thread, its return value is not immediately available. To deal with this, `spawn` returns a special type called `FlowVar[T]`. This type holds the value that the procedure you spawned returns.


The `^` operator can be used to retrieve the value that a `FlowVar[T]` type holds. But a `FlowVar[T]` object may not always contain a value, it will start out empty, and once the spawned procedure returns a value the `FlowVar[T]` object will then contain it. When the `FlowVar[T]` object is empty, the `^` operator will block the current thread until the `FlowVar[T]` object is no longer empty. If it is not empty in the first place, then the `^` operator will return immediately with the value.


That is why the piece of code above will actually behave in a similar way to that of the previous code. Thankfully, you can also check whether a `FlowVar[T]` type contains a value by using the `isReady` procedure. Using that procedure will allow the application to avoid blocking behaviour.




Generics



Generics are a feature of Nim that you will be introduced to in full detail in *Chapter 9*. For now, all you need to know is that `FlowVar[T]` is a generic type. This allows it to store values of any type, the type of the value stored is specified in the square brackets.


For example, the `spawn stdin.readLine()` expression returns a `FlowVar[string]` type because the return type of `readLine` is a `string`, and because the `FlowVar` wraps the return value of the spawned procedure.


Applying the `spawn` call to any procedure which returns a `string` will result in a `FlowVar[string]` value:




```
import threadpool
proc foo: string = "Dog"
var x: FlowVar[string] = spawn foo()
assert(^x == "Dog")
```



See *Figure 3.15* to see how the two different threads interact with each other. Compare it to *Figure 3.14* to see how the execution of the `client` changed after the introduction of `spawn`.




Figure 3.11. Current execution of `client.nim`


![ch03 input thread 2](../Images/ch03_input_thread_2.png)

There is now a secondary `readLine` thread but the result is the same, both the main thread and the `readLine` thread become blocked yielding the same results.


Let me now show you how to modify `client.nim` in order to use `spawn`. *Listing 3.5* shows the full code with the changed lines in bold. Key point to note is that the `spawn` procedure is defined in the `threadpool` module, so you must remember to import it via `import threadpool`.




Listing 3.5. The code in `client.nim` so far




```
import os, **threadpool**

echo("Chat application started")
if paramCount() == 0:
  quit("Please specify the server address, e.g. ./client localhost")
let serverAddr = paramStr(1)
echo("Connecting to ", serverAddr)
while true:
  let message = **spawn** stdin.readLine()
  echo("Sending \"", **^message**, "\"")
```



Compilation now requires the `--threads:on` flag. To compile and run the `client.nim` file, you should now be executing `nim c -r --threads:on src/client.nim localhost`. The `--threads:on` flag is required to switch on Nim’s threading support, without it `spawn` cannot function.





> Tip Nim config files |
| Flags such as the `--threads:on` flag can accumulate quickly. The Nim compiler supports config files which save you from having to retype all of these flags on the command-line. Simply create a `client.nim.cfg` file (beside the `client.nim` file) and add `--threads:on` there. Each flag needs to be on its own line so you can add extra flags by separating them with newlines. |



The `client` application will still behave the same way as before. But the changes made to the standard input stream reading code will be useful later on in this chapter. In the next section, I will show you how to add asynchronous networking code allowing the client application to connect to the server. The server itself will also use the same asynchronous I/O approach in order to communicate with more than one client at a time.


This section has shown you how to read input from the user in two different ways, as command-line parameters and from the standard input stream during the time your application is running. I have also discussed the problem with standard blocking I/O and showed you one way to solve it. Now let’s move on to writing the protocol for your chat application.





3.4  Implementing the protocol
==============================



Every application that communicates over a network with another application needs to define a protocol to use for that communication. A protocol ensures that the two applications can understand each other. It is similar to a natural language that we humans use, and is also a standard which is mostly consistent and which can be understood by both of the communicating parties. Imagine trying to communicate in English with somebody who can only speak Chinese. You will not understand them, and they will not understand you either. Similarly, the different components in your application must communicate using the same language to understand each other.


![ch03 human protocol](../Images/ch03_human_protocol.png)
It is important to remember that even though protocols are well defined, there is still plenty of room for error. The message may simply have not been transmitted correctly. This is why it is vital that code which parses a given message can handle an incorrectly formatted message, or a message which does not contain the data which is necessary. The code that I will show you in this section will not go to great lengths to verify the validity of the messages that it receives. But I will encourage you later on to spend time adding exception handling code, to verify the validity of the messages and to provide better exception messages to the users of your code.


Code which parses and generates a message is easy to test. Because of this I will also be showing you some basic ways to test your code in this section.


The chat application’s protocol will be a simple one. The information that it will transfer between clients consists of only the message that the user has decided to send to the other clients and the user’s name.


There are many ways that this information could be encoded, but one of the simplest ways is to encode it as a JSON object which is what I will show you how to do.




3.4.1  Modules
--------------



You have already seen many examples of modules. The `client.nim` file that you have written is itself a module, and you have also imported modules from Nim’s standard library into your code using the `import` keyword.


Until now, I have not explained precisely what a module is. Many programming languages today utilize a module system. Nim’s module system is rather simple: every Nim file, that is a file ending with a "nim" extension, is also a module. As long as the compiler can find the file then it can be successfully imported.


The reason I am explaining the module system to you at this point in the book is because the upcoming message parser should ideally be written in a separate module, and I thought that it would be nice to explain it together with a practical example. A module system allows you to separate the functionality of your application into independent modules. One advantage of this in our case is that the module is interchangeable. As long as the interface of the module remains the same the underlying protocol that it implements can be changed. So later on you can easily use something other than JSON to encode the messages.


Now create a module to accommodate your new message parser, simply create a new file named `protocol.nim` in the `src` directory beside the `client.nim` file. After doing so your source directory will contain both the `client` and `protocol` modules.


By default everything you define in a module can only be accessed inside that module, it cannot be accessed outside the module because it is private. This allows you to hide certain implementation details of your module and to decide precisely which ones should be made public to the modules which import it. In some languages the `public` and `private` keywords are used to specify the visibility of a definition, [[12]](#ftn.d5e2808) in Nim each definition is private by default so there is only a need to make it public, this can be done using the `*` operator.


The `*` can be placed at the end of procedure names, variable names, method names, and field names.




Listing 3.6. Message type definition and proc stub




```
type
  Message* = object     ❶
    username*: string   ❷
    message*: string

proc parseMessage*(data: string): Message =   ❸
  discard   ❹
```




|  |  |
| --- | --- |
❶](#CO6-1) | This line defines a new `Message` type. The export marker `*` is placed after the name of the type. |
❷](#CO6-2) | Two field definitions follow the type definition, and they are exported in a similar way. |
❸](#CO6-3) | This line defines a new `parseMessage` procedure. The export marker is also used after the name to export it. |
❹](#CO6-4) | The `discard` is necessary because the body of a procedure cannot be empty. |





*Listing 3.6* shows the definition of the `Message` type which will store the two pieces of information that a message from the server contains, the username of the client and the actual message. Each of these definitions are exported using the `*` marker. At the end the `parseMessage` procedure is defined. It takes in `data` of type string, which is the raw string received from the server by the client, or sent by a client depending on how you look at it. The `parseMessage` procedure then returns a value of type `Message` which is the parsed message. This procedure is also exported, and it forms the public interface of the `protocol` module together with the `Message` type.


You should now add the code in *Listing 3.6* to the `protocol` module you created earlier. Then make sure it compiles with `nim c src/protocol`.


The basics of the module system should be easy to grasp because they are simple. There are some extra things to be aware of but this should be enough to get you started with writing simple modules. Now let’s move onto implementing the `parseMessage` procedure.





3.4.2  Parsing JSON
-------------------



JSON is a very simple data format. It is widely used, and Nim has support for parsing and generating JSON in its standard library. This makes JSON the perfect candidate for storing the two message fields.


A typical piece of JSON consists of an object which contains multiple fields, the field names are simple quoted strings and the values can be any of either an integer, a float, a string, an array or another object.


Let’s look back to the conversation I defined about Game of Thrones at the beginning of this chapter. One of the first messages that I will send will be "What did you guys think about the latest Game of Thrones episode?". This can be represented using JSON like so.




Listing 3.7. A representation of a message in JSON




```
{   ❶
  "username": "Dominik",   ❷
  "message": "What did you guys think about the latest Game of Thrones episode?"   ❸
}
```




|  |  |
| --- | --- |
❶](#CO7-1) | The curly brackets define an object. |
❷](#CO7-2) | The `username` field with the corresponding value. |
❸](#CO7-3) | The `message` field with the corresponding value. |





Parsing JSON is very easy in Nim. First, import the `json` module by adding `import json` to the top of your file. Then replace the `discard` statement in the `parseMessage` proc with `let dataJson = parseJson(data)`. *Listing 3.8* shows the code with the additions in bold.




Listing 3.8. Parsing JSON in `protocol.nim`




```
**import json**
type
  Message* = object
    username*: string
    message*: string

proc parseMessage*(data: string): Message =
  **let dataJson = parseJson(data)**
```



The `parseJson` procedure defined in the `json` module accepts a string and returns a value of the `JsonNode` type.


The `JsonNode` type is a variant type. This means that the fields which can be accessed are determined by the value of one or more other fields that are always defined in that type. In the case of the `JsonNode` it is the `kind` field which determines the kind of JSON node which was parsed.




A little information about variant types



A variant type is an object type whose fields change depending on the value of one or more fields. Let me get straight to an example because it is much easier to explain them this way.





Listing 3.9. Modelling a box using a variant type




```
type
  Box = object           ❶
    case empty: bool     ❷
    of false:            ❸
      contents: string   ❹
    else:
      discard            ❺

var obj = Box(empty: false, contents: "Hello")   ❻
assert obj.contents == "Hello"                   ❼

var obj2 = Box(empty: true)
echo(obj2.contents)      ❽
```




|  |  |
| --- | --- |
❶](#CO8-1) | A variant type is defined in a similar way to an ordinary object type. |
❷](#CO8-2) | The difference is the case statement under the definition of the object. This actually defines an `empty` field in this type. |
❸](#CO8-3) | If the `empty` field is `false` then the fields defined under this branch will be accessible. |
❹](#CO8-4) | The `contents` field will be accessible if `empty == false`. |
❺](#CO8-5) | No additional fields are defined if `empty == true`. |
❻](#CO8-6) | When the `empty` field is set to `false` in the constructor the `contents` field can also be specified. |
❼](#CO8-7) | Because `obj.empty` is `false` the `contents` field can be accessed. |
❽](#CO8-8) | This will result in an error because the `contents` field cannot be accessed. It cannot be accessed because `empty` is `true`. |






*Listing 3.9* shows how an ordinary box which may be empty can be modelled. At the end of *Listing 3.9* I show an erronous case where the contents of an empty box are accessed. It should be no surprise that compiling and running the above code will result in an error.




```
Traceback (most recent call last)
variant.nim(13)          variant
system.nim(2533)         sysFatal
Error: unhandled exception: contents is not accessible [FieldError]
```


That’s just a very simple variant type with only two states. You can also use enum types in the case statement of a variant type. This is very common and is used in the `JsonNode` type.



There are 7 different `JsonNodeKind`’s. The `JsonNodeKind` type is an enum with a value for each kind of JSON value. *Listing 3.10* provides a list of all 7 together with the `JsonNodeKind` that they map to.




Listing 3.10. The mapping between JSON values and the `JsonNodeKind` type




```
assert parseJson("null").kind == JNull
assert parseJson("true").kind == JBool
assert parseJson("42").kind == JInt
assert parseJson("3.14").kind == JFloat
assert parseJson("\"Hi\"").kind == JString
assert parseJson("""{ "key": "value" }""").kind == JObject
assert parseJson("[1, 2, 3, 4]").kind == JArray
```



When parsing arbitrary JSON data, a variant type is required because the compiler has no way of knowing at compile-time what the resulting JSON type should be. This is only known at runtime. This is why the `parseJson` procedure returns a `JsonNode` type whose contents differ depending on the kind of JSON value that was passed into the `parseJson` procedure.


The last two JSON values shown in *Listing 3.10* are collections. The `JObject` kind represents a mapping between a `string` and a `JsonNode`. The `JArray` kind stores a list of `JsonNode`’s.


You can access the fields of a `JObject` by using the `[]` operator. It is similar to the array and sequence `[]` operator but takes a `string` as its argument. The string determines the field that you want to retrieve the value of from the `JObject`. One important thing to remember is that the `[]` operator returns a `JsonNode` value.




```
import json
let data = """
  {"username": "Dominik"}
"""

let obj = parseJson(data)    ❶
assert obj.kind == JObject   ❷
assert obj["username"].kind == JString    ❸
assert obj["username"].str == "Dominik"   ❹
```




|  |  |
| --- | --- |
❶](#CO9-1) | Simply parses the `data` string and returns a `JsonNode` type which is then assigned to the `obj` variable. |
❷](#CO9-2) | The returned `JsonNode` has a `JObject` kind because that is the kind of the JSON contained in `data`. |
❸](#CO9-3) | Fields are accessed using the `[]` operator. It returns another `JsonNode`, in this case its `kind` is a `JString`. |
❹](#CO9-4) | Because the `[]` operator returns a `JsonNode`, the value that it contains must be accessed explicitly via the field which contains it. In `JString`’s case this is `str`. Generally you’re better off using the `getStr` proc though. |




 





|  |  |
| --- | --- |
Caution] | The `kind` matters |
| Calling the `[]` operator with a string on a `JsonNode` who’s `kind` field is not `JObject` will result in an exception being raised. |



So how can you retrieve the `username` field from the parsed `JsonNode`? Using `dataJson["username"]` will return another `JsonNode`. Unless the `username` field does not exist in the parsed `JObject`, in which case a `KeyError` exception will be raised. In the listing above, the `JsonNode` kind that `dataJson["username"]` will return will be `JString` because that field holds a `string` value. You can retrieve the `string` value using the `getStr` procedure. There is a "get" procedure for each of the `JsonNode` kinds, each "get" procedure will return a default value if the type of the value it is meant to be returning does not match the `JsonNode` kind.





> Tip The "get" default value |
| The default value returned by the "get" procedures can be overridden. To override pass the value you want to be returned by default as the second argument to the procedure, for example `node.getStr("Bad kind")`. |



Now you just need to assign this username to a new instance of the `Message` type. See code *Listing 3.11* which shows the full `protocol` module, the new assignments which have been added are in bold.




Listing 3.11. Assigning parsed data to the result variable




```
import json
type
  Message* = object
    username*: string
    message*: string

proc parseMessage*(data: string): Message =
  let dataJson = parseJson(data)
  **result.username = dataJson["username"].getStr()**   ❶
  **result.message = dataJson["message"].getStr()**     ❷
```




|  |  |
| --- | --- |
❶](#CO10-1) | Get the value under the `"username"` key and assign its string value to the `username` field of the resulting `Message`. |
❷](#CO10-2) | Do the same here, but instead get the value under the `"message"` key. |





Just a simple addition of two lines of code and you’re done.




The magical `result` variable



You may be wondering where the `result` variable comes from in *Listing 3.11*. The answer is that Nim implicitly defines it for you. This `result` variable is defined in all procedures that are defined with a return type.




```
proc count10(): int =
  for i in 0 .. 10:
    result.inc
assert count10() == 10
```


This means that you do not need to repeatedly define a `result` variable nor do you need to return it. The `result` variable is automatically returned for you. Take a look back at the *Procedure definitions* section in Chapter 2 for more info.



You should test your code as quickly and as often as you can. You could do so now by starting to integrate your new module with the client module, but it is much better to test code as separate units. The protocol module is a good unit of code to test in isolation. When testing a module, it is always a good idea to test each of the exported procedures to ensure that they work as expected. The protocol module currently exports only one procedure - the `parseMessage` procedure - so you only need to write tests for it.


There are multiple ways to test code in Nim, the simplest is by using the `doAssert` procedure. The `doAssert` procedure is defined in the `system` module. It is similar to the `assert` procedure, it takes one argument of type `boolean` and raises an `AssertionFailed` exception if the value of that `boolean` is `false`. It differs from `assert` in one simple way, `assert` statements are optimized out when you compile your application in release mode (via the `-d:release` flag) whereas `doAssert` statements are not.





> Note Release mode |
| By default the Nim compiler compiles your application in debug mode. In debug mode your application runs a bit slower but performs certain checks which give you more information about certain bugs that you may have accidentally introduced into your program. When deploying your application, for optimal performance you should compile it with the `-d:release` flag which puts it in release mode. |



Let’s define an input and then use `doAssert` to test `parseMessage`’s output.




Listing 3.12. Testing your new functionality




```
when isMainModule:   ❶
  block:             ❷
    let data = """{"username": "John", "message": "Hi!"}"""   ❸
    let parsed = parseMessage(data)      ❹
    doAssert parsed.username == "John"   ❺
    doAssert parsed.message == "Hi!"     ❻
```




|  |  |
| --- | --- |
❶](#CO11-1) | The `when` statement is a compile-time `if` which only includes the code under it if its condition is `true`. The `isMainModule` constant is `true` when the current module has not been imported. This means that the test code is hidden if this module is imported. |
❷](#CO11-2) | Begins a new scope, useful for isolating your tests. |
❸](#CO11-3) | Here I use the triple quoted string literal syntax to define the data to be parsed, the triple quoted string literal mean that the single quote in the JSON does not need to be escaped. |
❹](#CO11-4) | Call the `parseMessage` procedure on the data defined above. |
❺](#CO11-5) | Check that the username that `parseMessage` parsed is correct. |
❻](#CO11-6) | Check that the message that `parseMessage` parsed is correct. |





Add the code in *Listing 3.12* to the bottom of your file, then compile and run your code. Your program should execute successfully with no output. While this is all well and good, it would be nice to at least get some sort of message letting you know that the tests succeeded, so just add `echo("All tests passed!")` to the bottom of your file. Your program should now output that as long as all the tests pass.


Try changing one of the asserts to check for a different output and observe what happens. For example removing the exclamation mark from the `doAssert parsed.message == "Hi!"` statement will result in the following error.




```
Traceback (most recent call last)
protocol.nim(17) protocol
system.nim(3335) raiseAssert
system.nim(2531) sysFatal
Error: unhandled exception: parsed.message == "Hi"  [AssertionError]
```


If you modify the protocol module and break your test, you may find that suddenly you will get such an error.


You now have a test for the correct input, what about incorrect input? Create another test to see what happens when the input is incorrect.




```
block:
  let data = """foobar"""
  let parsed = parseMessage(data)
```


Now compile and run `protocol.nim`, you should get the following output.




```
Traceback (most recent call last)
protocol.nim(21) protocol_progress
protocol.nim(8)  parseMessage
json.nim(1086)   parseJson
json.nim(1082)   parseJson
json.nim(1072)   parseJson
json.nim(561)    raiseParseErr
Error: unhandled exception: input(1, 5) Error: { expected [JsonParsingError]
```


An exception is raised by `parseJson` because the specified data is not valid JSON. But it is what should happen, so define that in the test by catching the exception and making sure that an exception has been raised.




```
block:
  let data = """foobar"""
  try:
    let parsed = parseMessage(data)
    doAssert false   ❶
  except JsonParsingError:   ❷
    doAssert true
  except:
    doAssert false
```




|  |  |
| --- | --- |
❶](#CO12-1) | This line should never be executed because `parseMessage` will raise an exception. |
❷](#CO12-2) | Make sure that the exception which is thrown is the expected one. |




An ideal way for the `parseMessage` proc to report errors would be by raising a custom exception. But this is beyond the scope of this chapter. I would encourage you to come back and implement it once you learn how to do so. For now let’s move onto generating JSON.





3.4.3  Generating JSON
----------------------



You were able to successfully parse JSON so let’s move onto generating JSON now. The protocol module needs to be capable of both parsing and generating messages. Thankfully generating JSON is even simpler than parsing it.


In Nim, JSON can be generated in multiple ways. One way is to simply create a string containing the correct JSON concatenated with the values, as was done in your first test. This will work but is error prone as it is easy to miss certain syntactical elements of JSON. Another way is to construct a new `JsonNode` and convert it to a string using the `$` operator. Let’s do that now. Start by defining a new `createMessage` procedure, then use the `%` operator to create a new `JsonNode` object. *Listing 3.13* shows how the `createMessage` procedure can be defined.




Listing 3.13. Creating a new message




```
proc createMessage*(username, message: string): string =
  result = $(%{   ❶
    "username": %username,   ❷
    "message": %message
  }) & "\c\l"   ❸
```




|  |  |
| --- | --- |
❶](#CO13-1) | The `$` converts the `JsonNode` returned by the `%` operator into a string. |
❷](#CO13-2) | The `%` converts strings, integers, floats, and more into the appropriate `JsonNode`’s. |
❸](#CO13-3) | A carriage return and the line feed characters are added to the end of the message. They act as the separators for the messages. |





 





> Note Table constructor syntax |
| The `{:}` syntax you see used in the code listing above is called a *table constructor*. It is simply syntax sugar for an array constructor, i.e. `{"key1": "value1", "key2": "value2"}` is the same as `[("key1", "value1"), ("key2, "value2")]`. |



The `%` operator is very powerful because it can convert a variety of different types of values into appropriate `JsonNode` types. This allows for the creation of JSON using a very intuitive syntax.


The `$` is, by convention, the operator used to convert any type to a `string` value. In the case of a `JsonNode`, the `$` operator defined for it will produce a valid JSON string literal representation of the `JsonNode` object that was built.


The addition of the carriage return and line feed - which some operating systems use to signify newlines - will be useful later on when the client and server components need to receive messages. They will need a way to determine when a new message stops and another begins, in essence these characters will be the message separators. In practice any separator could be used, but the `\c\l` sequence is commonly used in many other protocols already and is supported by Nim’s networking modules.


Just like with the `parseMessage` procedure you should also add tests for the `createMessage` procedure. Simply use `doAssert` again, to ensure that the output is as expected. Remember to include the `\c\l` in your expected output. The following code listing shows one test that could be performed, add it to the bottom of `protocol.nim`.




```
block:
  let expected = """{"username":"dom","message":"hello"}""" & "\c\l"   ❶
  doAssert createMessage("dom", "hello") == expected
```




|  |  |
| --- | --- |
❶](#CO14-1) | One interesting thing to note here is that the triple quoted string literals do not support any character escape sequences at all. As a workaround I simply concatenate them. |




Recompile your module and run it to ensure that the tests pass. Optionally you can extend the tests further, by checking different inputs such as ones which contain characters which have a special meaning in JSON like the `"` character.


Assuming that all the tests pass then you have successfully completed the `protocol` module and are now ready to move onto the final stage of the development of this application!




  


[[12]](#d5e2808) In particular C++ and Java use the `public` and `private` keywords to denote visibility of identifiers.







3.5  Transferring data using sockets
====================================



At this point in time you are well on your way to completing this chat application. The `protocol` module is complete and the `client` module has mostly been completed. Before you finish the `client` module let’s look at the so far completely neglected `server` module.


The `server` module is arguably one of the most important, it will be compiled separately in order to produce a `server` binary. As mentioned previously, the `server` will act as a central hub to which all the clients will connect to. The `server` will need to perform two primary tasks:



* Listening for new connections from potential clients; and
* Listening to new messages from each of the clients that have already connected to the server



Any messages that the `server` receives will need to be sent to every other `client` that is currently connected to it.




Figure 3.12. The operation of the chat application


![ch03 chat server](../Images/ch03_chat_server.png)

*Figure 3.16* which you have seen in the first section shows the operation of the server and the clients. It is a simplified diagram, without any protocol details included. Now that you are familiar with the protocol that the chat application will be using, I can show you the exact messages that will be sent in *Figure 3.16*. First assume that the server has successfully accepted connections from Dom, John and Grace. The following events occur in the order that they are presented.




Listing 3.14. First the Client Dom sends a message to the Server




```
{"username": "Dom", "message": "Hello"}   ❶
```




|  |  |
| --- | --- |
❶](#CO15-1) | Remember that this message is followed by a `\c\l`. |







Listing 3.15. Then the Server sends the same message to Clients John and Grace




```
{"username": "Dom", "message": "Hello"}   ❶
```




|  |  |
| --- | --- |
❶](#CO16-1) | This message is also followed by a `\c\l`. |





You can see that the server simply passes any messages that it receives onto other clients. For simplicity the server doesn’t check the identity of any of the clients, so it is possible for them to impersonate another user. At the end of this chapter there will be plenty of room for improving this application, and security will be one aspect that you will be encouraged to reinforce.


Not worrying about security for now, let’s march on to create the server module. Let’s begin by defining the types which will be used by it. Firstly, create a new `server.nim` file in the `src` directory. Then create the types shown in *Listing 3.16*.




Listing 3.16. Standard library imports and type definitions




```
import asyncdispatch, asyncnet   ❶

type   ❷
  Client = ref object      ❸
    socket: AsyncSocket    ❹
    netAddr: string        ❺
    id: int                ❻
    connected: bool        ❼

  Server = ref object      ❽
    socket: AsyncSocket    ❾
    clients: seq[Client]   ❿
```




|  |  |
| --- | --- |
❶](#CO17-1) | Import the `asyncdispatch` and `asyncnet` modules which contain the procedures and types needed to use asynchronous sockets. |
❷](#CO17-2) | Start a new type section. |
❸](#CO17-3) | Define the `Client` type as a reference type. |
❹](#CO17-4) | The socket belonging to the client, the `AsyncSocket` type is an asynchronous socket. |
❺](#CO17-5) | The field which stores the address from which this client has connected. |
❻](#CO17-6) | The identification number of this client. |
❼](#CO17-7) | Flag which determines whether this client is still connected. |
❽](#CO17-8) | Define the `Server` type as a reference type. |
❾](#CO17-9) | The server socket for accepting new client connections. |
❿](#CO17-10) | A list of `Client` objects which have connected. |





The `Server` and `Client` types are both defined as reference types, you might recall these from Chapter 2, they are defined this way because it allows procedures which take these types as arguments to modify them. This is going to be essential, as an example, new elements will need to be added to the `clients` field when new clients connect.


The `Server` type holds information related directly to the server, such as the server socket and the clients which have connected to it. Similarly, the `Client` type represents a single client that connected to the server, and it includes fields which provide useful pieces of information about each client. For example, the `netAddr` field which will contain the IP address of the client, and the `id` field which will hold a generated identity for each client allowing you to distinguish between them. The `connected` flag is an important one, because it tracks whether the client is still connected. The server needs to know this as it shouldn’t attempt to send messages to a disconnected client.


All that is left now is to create a constructor for the newly defined `Server` type.




Constructors in Nim



Constructors in Nim are simply procedures with a specific naming convention. Nim does not include any special syntax for defining such constructors, but it does include some simple syntax for constructing your custom types, which you may recall from *Chapter 2*. Examples follow.


Tuples can be constructed by simply placing values in parenthesis:




```
type
  Point = tuple[x, y: int]

var point = (5, 10)
var point2 = (x: 5, y: 10)
```


Objects, including `ref` objects, can be constructed by calling the type - as if it was a procedure - then specifying each field name and value separated by a colon:




```
type
  Human = object
    name: string
    age: int

var jeff = Human(name: "Jeff", age: 23)
var amy = Human(name: "Amy", age: 20)
```


There is no way to override these, so if you need more complex constructors you will need to define a procedure. There is a convention in Nim on how to name these constructor procedures, the table below shows these conventions and how they apply to different type definitions.









| Type Definition | Name |
| `MyType = object` | `initMyType` |
| `MyTypeRef = ref object` | `newMyTypeRef` |
| `MyTuple = tuple[x, y: int]` | `initMyTuple` |



For a ref type, such as the `Server` type, the procedure should be named `newServer`:




```
proc newServer(): Server = Server(socket: newAsyncSocket(), clients: @[])
```


This will create a new instance of the `Server` type and initialize its socket and `clients` sequence. Now call this procedure and assign it to a new `server` variable.




```
var server = newServer()
```


Add the two pieces of code defined above below the types created in *Listing 3.16*. The resulting code gives you a good base to begin adding the networking code. But before getting into that, let me explain more about how networking and in particular how asynchronous networking works in Nim. I will begin by looking at the basic tool used to transfer data over a network, this tool is called a *socket*.




3.5.1  What is a socket?
------------------------



In almost every programming language, transferring data over a network is done using network sockets. A network socket in Nim is represented using the `Socket` type. This type is defined in the `net` module, and a new instance of it can be created using the `newSocket` procedure.


Sockets share some similarities with file descriptors, in that they support operations such as `write`, `read`, `open` and `close`. But in practice, sockets differ enough to expose a different interface. *Table 3.1* below shows some of the common procedures that are defined for sockets and their file descriptor equivalents.




Table 3.1. Common socket procedures









| Procedure | File equivalent | Description |
| `recv` | `read` | Allows incoming data to be read from the remote side. For TCP sockets `recv` is used, and for UDP sockets `recvFrom` is used. |
| `send` | `write` | Sends data to a socket, allowing data to be sent to the remote side. For TCP sockets `send` is used, and for UDP sockets `sendTo` is used. |
| `connect` | `open` | Connects a socket to a remote server. This is typically only used for TCP sockets. |
| `bindAddr` | None | Binds a socket to the specified address and port. When called, the socket becomes a server socket and other sockets can connect to it. This is typically only used for TCP sockets. |




Sockets can be customised a great deal by specifying different options in the `newSocket` constructor. By default, the `newSocket` constructor will create a TCP socket. This is handy, because as it happens TCP is the protocol which the chat application is going to use.


The TCP protocol is a connection protocol, which allows the socket to be used as a server or as a client. A newly created TCP socket is neither, until the `bindAddr` or `connect` procedure is called. The former of which transforms it into a server socket, and the latter a client socket. Let’s create a server socket first, as that is what is needed for the `server` component of this application.


A server socket’s main purpose is to listen for new connections, and accept them with as little delay as possible. But before this can be done, the socket must first be bound to an address and port. *Figure 3.17* shows the procedures which need to be called to successfully create and bind a server socket.




Figure 3.13. The steps needed to start accepting new connections on a server socket


![ch03 server socket](../Images/ch03_server_socket.png)

Firstly, every server socket needs to be explicitly bound to a specific port and address. This can be done using the `bindAddr` procedure which takes a port as the first argument and the address as the second. By default the address is simply "localhost", but the port must always be specified. You can specify the port as anything you want, but be aware that there are standard ports which are often used by other applications. One example of this is port 80 which is used by HTTP servers. Another point to be aware of is that binding to a port which is 1024 or less requires administrator privileges.


Secondly, before the socket can start accepting connections you must call the `listen` procedure on it. The `listen` procedure tells the socket to start listening for incoming connections.


New connections can then be accepted by using the `accept` procedure. This procedure returns a new client socket, which corresponds to the socket which has just connected to the address and port specified in the call to `bindAddr`.





> Tip Details about sockets |
| Don’t worry about remembering all of the details written in this section, use it as a reference together with the next sections which will show you how to put this knowledge into practice. |



Similar to reading data from the standard input, the `accept` procedure blocks your application until a new connection is made. This is a problem, but one which is easy to solve thanks to Nim’s support for asynchronous sockets. Asynchronous sockets don’t block and can be used instead of the synchronous blocking sockets without much trouble. The asynchronous sockets are defined in the `asyncnet` module and I will explain how they work in the next section.





3.5.2  Asynchronous input/output
--------------------------------



Nim supports many abstractions which make working with asynchronous I/O simple, this is achieved in part by making asynchronous I/O very similar to synchronous I/O, so you do not need to make your code logic any more complex than it needs to be.


Let’s first look at the `accept` procedure in more detail. The `accept` procedure takes one parameter: a server socket. This procedure is used to retrieve new clients which have connected to the specified server socket.


The most fundamental difference between the synchronous and asynchronous versions of the `accept` procedure is the following:



* The synchronous `accept` procedure blocks the thread it is called in until a new socket has connected to the server socket; whereas
* The asynchronous `accept` procedure returns immediately after it is called.



But what does the asynchronous version return? It certainly cannot return the accepted socket immediately, because a new client may not have connected yet so there is nothing to accept.


Instead, the asynchronous `accept` returns a `Future[AsyncSocket]` object. Fundamental to your understanding of asynchronous I/O is knowing what a *future* is, so let’s look at it in more detail.


**The Future type**


The `Future` is a special type, one which goes by many names including *promise*, *delay* and *deferred* in other languages. This type acts as a proxy for a result that is initially unknown, usually because the computation of its value is not yet complete.


You can think of a future as a container, initially it is empty and while it remains empty you cannot retrieve its value. At some unknown point in time, something is placed in the container and so it is no longer empty. That is where the name *future* comes from.


Every asynchronous operation in Nim returns a `Future[T]` object, where the `T` corresponds to the type of value which that `Future` promises to store at some point in the future.


The `Future[T]` type is defined in the `asyncdispatch` module, and you can easily experiment with it, without dealing with any asynchronous I/O operations. *Listing 3.17* below shows the behaviour of a simple `Future[int]` object.




Listing 3.17. Simple `Future[int]` example




```
import asyncdispatch   ❶

var answer = newFuture[int]()    ❷
doAssert(not answer.finished)    ❸

answer.callback =      ❹
  proc (future: Future[int]) =   ❺
    echo("Future is no longer empty, ", future.read)   ❻

answer.complete(42)    ❼
```




|  |  |
| --- | --- |
❶](#CO18-1) | The `asyncdispatch` module needs to be imported as it defines the `Future[T]` type. |
❷](#CO18-2) | A new future can be initialised using the `newFuture` constructor. |
❸](#CO18-3) | A future starts out empty, when a future is not empty the `finished` procedure will return true. |
❹](#CO18-4) | A callback can be set which will be called when the future’s value is set. |
❺](#CO18-5) | The callback is given the future whose value was set as a parameter. |
❻](#CO18-6) | The `read` procedure is used to retrieve the value of the future. |
❼](#CO18-7) | A future’s value can be set by calling the `complete` procedure. |





Futures can also store an exception in case the computation of the value fails. Calling `read` on a `Future` which contains an exception will result in an error.


To demonstrate the effects of this, modify the last line of *Listing 3.17* above to `answer.fail(newException(ValueError, "The future failed"))`. Then compile and run it.


The application should crash with the following output:




```
Traceback (most recent call last)
system.nim(2510)         ch3_futures
asyncdispatch.nim(242)   fail
asyncdispatch.nim(267)   :anonymous
ch3_futures.nim(8)       :anonymous
asyncdispatch.nim(289)   read
Error: unhandled exception: The future failed
  unspecified's lead up to read of failed Future:   ❶
    Traceback (most recent call last)
    system.nim(2510)         ch3_futures
    asyncdispatch.nim(240)   fail [Exception]
```




|  |  |
| --- | --- |
❶](#CO19-1) | `unspecified` is the name of the Future, it’s called `unspecified` because the future is created with no name. You can name futures for better debugging information by specifying a string in the `newFuture` constructor. |




As you can see, the error message attempts to pack as much information into itself as possible. It does create some confusion and is missing some important information. The error messages produced by futures are still being worked on and should improve with time. For now it is a good idea to get to know what they look like currently, as you will no doubt see them when writing asynchronous applications in Nim.


The exception above is caused by calling `read` on a future which had an exception stored inside it. To prevent that from occuring, you can check whether the future completed with an exception using the `failed` procedure. This procedure returns a boolean which determines whether the future completed with an exception.


One important thing to keep in mind when working with futures, is that unless they are explicitly read, any exceptions that they store may silently disappear when the future is deallocated. As such, it is important not to `discard` futures but to instead use the `asyncCheck` procedure to ensure that any exceptions are re-raised in your program.


**The difference between synchronous and asynchronous execution**


Hopefully by now you understand how futures work and are ready to go back to learning a little bit more about asynchronous execution in the context of the `accept` procedure. *Figure 3.18* below shows the difference between calling the synchronous version of `accept` versus calling the asynchronous version of it.




Figure 3.14. The difference between synchronous and asynchronous `accept`.


![ch03 server socket async](../Images/ch03_server_socket_async.png)

As mentioned earlier, the asynchronous `accept` returns a `Future` object immediately. Whereas the synchronous `accept` blocks the current thread. While the thread is blocked, it is idle and performs no useful computational work. The asynchronous version on the other hand has the ability to perform computational work, as long as this work does not require the client socket. It may involve client sockets which have connected previously, or it may just involve calculating the 1025th decimal digit of π. In *Figure 3.18*, this work is masked beneath a `doWork` procedure, which could be doing any of the tasks mentioned above behind the scenes.


The asynchronous version performs many more calls to `doWork` than the synchronous version. It also retains the call to `doWork(socket)` leading to the same code logic but very different performance characteristics.


But it is important to note that the asynchronous execution described in *Figure 3.18* has a problem. It demonstrates what is known as *busy waiting*, that is, repeatedly checking whether the Future is empty or not. This technique is very inefficient because CPU time is wasted on a useless activity. As you saw in the previous section, the `Future` supports a callback which can be overriden with a custom procedure. The callback is then called whenever the `Future` is completed with a value, causing that value to be stored in that future, or alternatively completed with an exception. Using a callback in that instance would prevent the *busy waiting*.


**Example of asynchronous I/O using callbacks**


In some of you, the term *callback* may incite a feeling of horror. But not to worry, you will in no way be forced to use callbacks in Nim. While the most basic notification mechanism that `Future`'s expose is a callback, Nim provides what is known as *async await* which hides these callbacks from you. You will learn more about async await later.


While I did say that you are not forced to use callbacks in Nim, I will first explain asynchronous I/O by showing you how it works with callbacks. The reason for this is that I believe there is a higher chance that you are familiar with callbacks than async await. I will start by making a comparison between Node.js and Nim, this comparison does not involve sockets but instead something much simpler: the reading of a file asynchronously.




Listing 3.18. Reading files asynchronously in Node




```
var fs = require('fs');
fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});
```



The code in *Listing 3.18* is taken straight from Node’s documentation,[[13]](#ftn.d5e3595) it simply reads the contents of the `"/etc/passwd"` file asynchronously. What happens when this script is executed is that the `readFile` function tells the Node runtime to read the file specified by the path in the first argument, and once it is done doing so to call the function specified in the second argument. The `readFile` function itself returns immediately and control is given back implicitly to the Node runtime. Now compare it to the Nim version.




Listing 3.19. Reading files asynchronously in Nim




```
import asyncdispatch, asyncfile

var file = openAsync("/etc/passwd")   ❶
let dataFut = file.readAll() ❷
dataFut.callback =           ❸
  proc (future: Future[string]) =
    echo(future.read())      ❹

asyncdispatch.runForever()   ❺
```




|  |  |
| --- | --- |
❶](#CO20-1) | Open the `"/etc/passwd"` file asynchronously and bind it to the `file` variable. |
❷](#CO20-2) | Ask for all of the contents of `file` to be read, and assign the resulting `Future[string]` type to the `dataFut` variable. |
❸](#CO20-3) | Assign a new callback to be called when the future completes. |
❹](#CO20-4) | Inside the callback, read the contents of the future which should now be present. |
❺](#CO20-5) | Run the event loop defined in the `asyncdispatch` module explicitly. |





The Nim version may seem more complex at first, but this is because Nim’s standard library does not define a single `readFile` procedure unlike Node’s standard library. Instead you must first open the file using the `openAsync` procedure to get a `AsyncFile` object, and you can then read data from that object. [[14]](#ftn.d5e3630)


Other than that difference in standard library APIs, the Nim version also differs in one more important way: the `readAll` procedure does not accept a callback, instead it returns a new instance of the `Future` type. The callback is then instead stored in the `Future`, and called once the future completes.


**The event loop**


In a Node application, the runtime is a form of event loop, it uses native operating system APIs in order to check for various events. One of these might be a file being successfully read or a socket receiving data from the server that it is connected to. The runtime dispatches these events to the appropriate callbacks. Nim’s event loop is defined in the `asyncdispatch` module, it is similar to Node’s runtime in many ways except that it needs to be explicitly executed. One way to do this is to call the `runForever` procedure. *Figure 3.19* below shows the behaviour of the `runForever` procedure.




Figure 3.15. Nim’s `asyncdispatch` event loop


![ch03 event loop](../Images/ch03_event_loop.png)

The Nim event loop puts you in control. The `runForever` procedure is simply a wrapper around the `poll` procedure, which the `runForever` procedure calls in an infinite loop. You can call the `poll` procedure yourself which will give you greater control over the event loop. The `poll` procedure waits for events for a specified number of milliseconds (by default 500ms), it doesn’t always take 500ms to finish as events can occur much earlier than that. Once an event is created the `poll` procedure processes it. The `poll` procedure then checks each of the currently pending `Future` objects to see if the `Future` is waiting on that event. If it is, then the `Future`’s callback is called and any appropriate values that are stored inside the future are populated.


In contrast to synchronous I/O which can block for an unlimited number of time, the `poll` procedure also blocks but only for a finite number of time which can be freely specified. This allows you to commit a certain amount of time to I/O processing and the rest to other tasks such as drawing a GUI or performing a CPU intensive calculation. I will show you how to utilize this procedure later on in the `client` module, in order to mix async sockets with the `readLine` procedure which reads the standard input stream in another thread.


**Async await**


There is a big problem with using callbacks for asynchronous I/O. The problem is that for complex application logic they are not flexible, leading to - what is aptly named - *callback hell*. Let me illustrate this problem with an example use case. Assume that you want to read another file after the first one has been read. To do so, you’re forced to nest callbacks and end up with code which becomes ugly and unmaintainable.


Nim has a solution to this problem and it is the `await` keyword. The `await` keyword can only be used inside of procedures marked with the `{.async.}` pragma. It eliminates callback hell completely and makes asynchronous code almost identical to synchronous code. *Listing 3.20* below shows how to read and write files using an `async` procedure.




Listing 3.20. Reading files and writing to them in sequence using await




```
import asyncdispatch, asyncfile

proc readFiles() {.async.} =        ❶
  var file = openAsync("~/test.txt", fmReadWrite)   ❷
  let data = await file.readAll()   ❸
  echo(data)          ❹
  await file.write("Hello!\n")      ❺

waitFor readFiles()   ❻
```




|  |  |
| --- | --- |
❶](#CO21-1) | The `{.async.}` pragma is used to specify that the `readFile` procedure is asynchronous. |
❷](#CO21-2) | Opens the `"~/test.txt"` file asynchronously in `fmReadWrite` mode, so that the file can be read and written to. |
❸](#CO21-3) | The file is fully read, the `await` keyword used here signifies that `readFiles` should be paused until the file is fully read. |
❹](#CO21-4) | Display the contents of the file. |
❺](#CO21-5) | Write some data to the file too. The procedure is paused until the data is successfully written to the file. |
❻](#CO21-6) | Run the event loop until `readFile` finishes. |





*Listing 3.20* performs the same actions and more than the code in *Listing 3.19*. At every point that the `await` keyword is used, the execution of the `readFiles` procedure is paused until the `Future` which is awaited is completed. At which point the procedure resumes its execution and the value of the future is read automatically. While the procedure is paused, the application continues running so the thread is never blocked. This is all done in a single thread, at any point multiple async procedures can be paused waiting for an event to resume them, and in the background callbacks are used to resume these procedures.


Every procedure marked with the `{.async.}` pragma must return a `Future[T]` object. In *Listing 3.20* the procedure might seem like it returns nothing, but actually it returns a `Future[void]`, this is done implicitly to avoid the pain of writing `Future[void]` all the time. Any procedure that returns a `Future[T]` can be awaited.


*Figure 3.20* below shows what the execution of *Listing 3.20* looks like.




Figure 3.16. The execution of *Listing 3.20*


![ch03 async await execution](../Images/ch03_async_await_execution.png)

The `waitFor` procedure used instead of `runForever` runs the event loop until the `readFiles` procedure finishes its execution. *Table 3.2* below shows a comparison between all the different async keywords you have seen up until now.




Table 3.2. Comparison between common async keywords










| Procedure | Controls event loop directly | Use case | Description |
| `runForever` | Yes | Usually used for server applications that need to stay alive indefinitely. | Runs the event loop forever. |
| `waitFor` | Yes | Usually used for applications which need to quit after a specific asynchronous procedure finishes its execution | Runs the event loop until the specified future completes. |
| `poll` | Yes | For applications which need precise control of the event loop. The `runForever` and `waitFor` procedures call this. | Listens for events for the specified amount of time. |
| `asyncCheck` | No | Discarding Futures safely. Typically to execute an async proc without caring for its result. | Sets the specified future’s callback property to a procedure which will handle exceptions appropriately. |
| `await` | No | Used to execute another async proc whose result is needed in the line of code after the `await`. | Pauses the execution of an async proc, until the specified future completes. |




 





|  |  |
| --- | --- |
Warning] | The procedures which control the event loop |
| Typically `runForever`, `waitFor`, and `poll` should not be used within async procedures, because they control the event loop directly. |



Now let me show you how to make use of `await` and asynchronous sockets in order to finish the implementation of the server.





3.5.3  Transferring data asynchronously
---------------------------------------



You have already initialized an asynchronous socket and stored it in the `server` variable. The next steps are as follows:



* Bind the socket to a port such as `7687`. [[15]](#ftn.d5e3818)
* Call `listen` on the socket to begin listening for new connections.
* Start accepting connections via the `accept` procedure.



You will need to use `await` and so will need to introduce a new async procedure. The code listing below shows a `loop` procedure which performs these steps.




```
proc loop(server: Server, port = 7687) {.async.} =
  server.socket.bindAddr(port.Port)   ❶
  server.socket.listen()

  while true:
    let clientSocket = await server.socket.accept()   ❷
    echo("Accepted connection!")

waitFor loop(server)   ❸
```




|  |  |
| --- | --- |
❶](#CO22-1) | Set up the server socket by binding it to a port and calling `listen`. The integer `port` param needs to be cast to a `Port` type which the `bindAddr` procedure expects. |
❷](#CO22-2) | Call `accept` on the server socket in order to accept a new client. The `await` keyword ensures that the procedure is paused until a new client has connected. |
❸](#CO22-3) | Executes the `loop` procedure, then runs the event loop until the `loop` procedure returns. |




The `loop` procedure will continuously wait for new client connections to be made. Currently nothing is done with those connections but let’s test that this works. Add the above code to the bottom of `server.nim`. Then compile and run the server by running `nim c -r src/server`.


**Testing a server without a client**


Testing this is a bit tricky since your client has not yet been completed. But it is fairly easy to use a command-line application called `telnet` to connect to your new server.


On Windows you may need to enable it in the Windows Features menu, more information available at this link: <http://windows.microsoft.com/en-gb/windows/telnet-faq>. After installation you should be able to open a new command window, type `telnet` into the prompt, then connect to your server by executing the `open localhost 7687` command. The server should then output "Accepted connection!".


On Unix-like operating systems such as Linux and Mac OS X, the `telnet` application should be available by default. You can simply open a new terminal window and execute `telnet localhost 7687`, the server should then output "Accepted connection!".


**Creating a new `Client` instance to hold data about the client**


Now let’s extend the `loop` procedure to create a new `Client` instance and add it to the `clients` field. Replace the while loop with the following.




```
while true:
  let (netAddr, clientSocket) = await server.socket.acceptAddr()   ❶
  echo("Accepted connection from ", netAddr)   ❷
  let client = Client(   ❸
    socket: clientSocket,
    netAddr: netAddr,
    id: server.clients.len,
    connected: true
  )
  server.clients.add(client)   ❹
```




|  |  |
| --- | --- |
❶](#CO23-1) | `acceptAddr` returns a `tuple[string, AsyncSocket]` type, the tuple is unpacked into two variables. |
❷](#CO23-2) | A message is displayed that a client has connected, together with its network address. |
❸](#CO23-3) | Initialize a new instance of the `Client` object and set its fields correspondingly. |
❹](#CO23-4) | Finally add the new instance of the client to the `clients` sequence. |




The variant of the `accept` procedure has been changed to one which also returns the IP address of the client which has connected. The `acceptAddr` procedure returns a tuple, the first value of which is the IP address of the client, and the second value is the client socket. The listing above uses *tuple unpacking*, which allows for these two values to be assigned immediately to two different variables.


When a client successfully connects, the next line writes a message to the terminal which includes the IP address of the client that just connected. After doing so, a new instance of the `Client` object is created, with each field assigned a new value one by one using a constructor. Finally, the new instance is added to the server’s `clients` sequence.


Recompiling this code and repeating the steps above should yield a result which displays "Accepted connection from 127.0.0.1". But sending messages won’t yet work of course.


**Processing the client’s messages**


After a connection is made using telnet, any messages typed into the prompt will not be received by the server. This is because the messages are still not being read from the clients that have connected. Let’s implement the code to do that in the server now.




```
proc processMessages(server: Server, client: Client) {.async.} =
  while true:
    let line = await client.socket.recvLine()   ❶
    if line.len == 0:         ❷
      echo(client, " disconnected!")
      client.connected = false
      client.socket.close()   ❸
      return   ❹

    echo(client, " sent: ", line)
```




|  |  |
| --- | --- |
❶](#CO24-1) | Wait for a single line to be read from the client. |
❷](#CO24-2) | Most procedures which read data from a socket may return an empty string, this signifies that the socket has disconnected from the server. |
❸](#CO24-3) | Close the client’s socket since it has disconnected. |
❹](#CO24-4) | Stop any further processing of messages. |




Make sure to place the `processMessage` procedure above the `loop` procedure. Later on you will need to call this procedure in the `loop` procedure, and in order for that to work this procedure must be above the call site.


You may find it strange to see another infinite loop denoted by the `while true` statement at the top of the procedure body. Surely as soon as this procedure is called, its execution will never stop. There is a truth to that, but note that this is an *async* procedure, and because of that it can be paused. This procedure will never *stop* executing, but it will *pause* its execution when `await client.socket.recvLine()` is called.


This means that other pieces of code will be executing while this procedure waits for the result of `client.socket.recvLine()`. The result will contain a single message sent by the client. A single message is guaranteed because the message protocol created in the previous section uses newline characters as delimiters.


There is one case which will prevent a full message being received: the client disconnecting from the server. In that case, `recvLine` returns an empty string which is why the next line checks the length of the resulting string. If the string is empty, then a message is displayed on the terminal which states that the client disconnected. The client’s `connected` flag is set to false, and the `close` procedure is called on the socket to free its resources.


Finally, assuming that the client has not disconnected, the message which the client sent is displayed in the terminal.


Try to recompile the code again. You will find that it does not compile, the error will be similar to the following.




```
server.nim(16, 54) template/generic instantiation from here
server.nim(20, 12) Error: type mismatch: got (Client)
but expected one of:
system.$(x: int)
system.$(x: seq[T])
system.$(x: cstring)
system.$(x: bool)
...
```


This is because of the `echo(client, " disconnected!")` line which attempts to display the `Client` type in the terminal. The problem is that the `echo` procedure attempts to use the `$` operator in order to display all of its arguments. If a `$` operator is not defined for the type that you pass to `echo`, then you will get an error message similar to the one above. The fix is to simply define it.


The full code listing for `server.nim` should now look something like this.




```
import asyncdispatch, asyncnet

type
  Client = ref object
    socket: AsyncSocket
    netAddr: string
    id: int
    connected: bool

  Server = ref object
    socket: AsyncSocket
    clients: seq[Client]

proc newServer(): Server = Server(socket: newAsyncSocket(), clients: @[])

**proc `$`(client: Client): string =**
  **$client.id & "(" & client.netAddr & ")"**

proc processMessages(server: Server, client: Client) {.async.} =
  while true:
    let line = await client.socket.recvLine()
    if line.len == 0:
      echo(client, " disconnected!")
      client.connected = false
      client.socket.close()
      return

    echo(client, " sent: ", line)

proc loop(server: Server, port = 7687) {.async.} =
  server.socket.bindAddr(port.Port)
  server.socket.listen()

  while true:
    let (netAddr, clientSocket) = await server.socket.acceptAddr()
    echo("Accepted connection from ", netAddr)
    let client = Client(
      socket: clientSocket,
      netAddr: netAddr,
      id: server.clients.len,
      connected: true
    )
    server.clients.add(client)
    **asyncCheck processMessages(server, client)**

var server = newServer()
waitFor loop(server)
```


The code now includes the definition of `$` for the `Client` type, as well as an `asyncCheck` command which runs the `processMessages` procedure in the background. These are both in bold. The `asyncCheck` command can be used to run asynchronous procedures without waiting on their result. This code will call the `processMessages` procedure for each client which connects to the server, which is precisely what needs to be done. Each client needs to be continuously read from to ensure that any messages that it sends are processed. Because of the nature of *async* procedures, all of this will be done in the background, with the execution of `loop` continuing and thus being ready to accept more connections.


Recompile the server module again, then run it and connect to it using `telnet` again. Now type some text into the telnet window and press Enter; you should see messages output by your server that show the text that you have entered.


**Sending the messages onto other clients**


Lastly, you need to send the messages received from a client to all the other clients that are currently connected to the server. Add the following to the bottom of the `processMessages` procedure; make sure you indent this code so it’s within the while loop.




```
for c in server.clients:   ❶
  if c.id != client.id and c.connected:   ❷
    await c.socket.send(line & "\c\l")    ❸
```




|  |  |
| --- | --- |
❶](#CO25-1) | Loop through each of the clients in the `clients` sequence. |
❷](#CO25-2) | Check that the client is not the client that sent this message and that the client is still connected. |
❸](#CO25-3) | Send the message to the client followed by the message separator `\c\l`. |




For completeness, the following code listing shows what your `processMessages` procedure should now look like. The addition is shown in bold.




```
proc processMessages(server: Server, client: Client) {.async.} =
  while true:
    let line = await client.socket.recvLine()
    if line.len == 0:
      echo(client, " disconnected!")
      client.connected = false
      client.socket.close()
      return

    echo(client, " sent: ", line)
    **for c in server.clients:**
      **if c.id != client.id and c.connected:**
        **await c.socket.send(line & "\c\l")**
```


That’s all there is to the server! It can now receive messages and send them on to other clients. The problem now is that the client still has no code to connect to the server or to send messages to it. Let’s fix that.


**Adding network functionality to the client**


The first thing that should be implemented in the client is the ability for it to connect to the server. Before implementing a procedure to do that, you must import the `asyncdispatch` and `asyncnet` modules. In addition to that you will need to also import the `protocol` module you have created earlier. You can then create a new async procedure called `connect` as shown below.




```
proc connect(socket: AsyncSocket, serverAddr: string) {.async.} =
  echo("Connecting to ", serverAddr)
  await socket.connect(serverAddr, 7687.Port)         ❶
  echo("Connected!")

  while true:
    let line = await socket.recvLine()   ❷
    let parsed = parseMessage(line)      ❸
    echo(parsed.username, " said ", parsed.message)   ❹
```




|  |  |
| --- | --- |
❶](#CO26-1) | Connect to the server address supplied, on the default `7687` port. |
❷](#CO26-2) | Continuously attempt to read message from the server. |
❸](#CO26-3) | Use the `parseMessage` procedure defined in the `protocol` module to parse the received message. |
❹](#CO26-4) | Display the message together with the username of the message sender. |




You should place this procedure just below the import statement at the top of the file. It is fairly simple, it connects to the server and starts waiting for messages from it. The `recvLine` procedure is used to read a single line at a time. This line is then passed to the `parseMessage` procedure, which parses it and returns an object that allows for specific parts of the message to be accessed. The message is then displayed together with the username of the messenger.


Before the `connect` procedure can be called, you must first define a new `socket` variable. This variable should be initialised using the `newAsyncSocket` procedure. Define it after the `serverAddr` command line argument is read, so after the `let serverAddr = paramStr(1)` line. The following code should do the trick `var socket = newAsyncSocket()`.


You can then replace the `echo("Connecting to ", serverAddr)` with a call to `connect`, use the `asyncCheck` procedure to run it in the background: `asyncCheck connect(socket, serverAddr)`.


It’s now time to finalise the changes needed to make standard input reading in `client.nim` non-blocking. Currently the while loop which reads the standard input still blocks. But in order for the `connect` async procedure to work, the async event loop needs to be executed. This will not happen if the thread is blocked. So the while loop needs to be modified to integrate the standard input reading with the event loop. The following code listing shows how this can be done, you should replace the while loop in `client.nim` with it.




```
var messageFlowVar = spawn stdin.readLine()   ❶
while true:
  if messageFlowVar.isReady():        ❷
    let message = createMessage("Anonymous", ^messageFlowVar)   ❸
    asyncCheck socket.send(message)   ❹
    messageFlowVar = spawn stdin.readLine()   ❺

  asyncdispatch.poll()   ❻
```




|  |  |
| --- | --- |
❶](#CO27-1) | The initial `readLine` call has been moved out of the while loop. |
❷](#CO27-2) | The `isReady` procedure determines whether reading the value from the `messageFlowVar` will block. |
❸](#CO27-3) | Use the `createMessage` procedure defined in the `protocol` module to create a new message. Getting the user’s name is left as an exercise for the reader. |
❹](#CO27-4) | Send the message to the server, in this case `createMessage` adds the separator for you. |
❺](#CO27-5) | Spawn `readLine` in another thread again as the last one has returned with data. |
❻](#CO27-6) | Call the event loop manually using the `poll` procedure. |




The `readLine` spawn call has been modified in order to prevent the `readLine` procedure from being executed multiple times in hundreds of threads. This would happen if the spawn call was placed inside the while statement because the `messageFlowVar` would no longer be read synchronously. Instead of doing so there is only ever one `readLine` running in a separate thread at one time. The while loop uses the `isReady` procedure to check whether the `readLine` procedure returned a newly read value from the standard input stream. If so then the message is sent to the server, and the `readLine` procedure is spawned again. See *Figure 3.22* which shows the execution of both the main thread and the `readLine` thread. Compare it to *Figure 3.21* which you have seen previously.




Figure 3.17. The execution of `client.nim` before the introduction of `isReady`


![ch03 input thread 2](../Images/ch03_input_thread_2.png)



Figure 3.18. The current execution of `client.nim`


![ch03 input thread 3](../Images/ch03_input_thread_3.png)

Waiting on the standard input no longer blocks the main thread and allows the event loop time to check for events by calling the `poll` procedure.


For completeness, here is the full code listing for `client.nim`. The changes made in this section are shown in bold.




```
import os, threadpool, **asyncdispatch, asyncnet**
**import protocol**

**proc connect(socket: AsyncSocket, serverAddr: string) {.async.} =**
  **echo("Connecting to ", serverAddr)**
  **await socket.connect(serverAddr, 7687.Port)**
  **echo("Connected!")**

  **while true:**
    **let line = await socket.recvLine()**
    **let parsed = parseMessage(line)**
    **echo(parsed.username, " said ", parsed.message)**

echo("Chat application started")
if paramCount() == 0:
  quit("Please specify the server address, e.g. ./client localhost")
let serverAddr = paramStr(1)
**var socket = newAsyncSocket()**
**asyncCheck connect(socket, serverAddr)**
**var messageFlowVar = spawn stdin.readLine()**
**while true:**
  **if messageFlowVar.isReady():**
    **let message = createMessage("Anonymous", ^messageFlowVar)**
    **asyncCheck socket.send(message)**
    **messageFlowVar = spawn stdin.readLine()**

  **asyncdispatch.poll()**
```


**The final results**


That’s all there is to it! You can now compile both the server and the client, then run the server and multiple clients. Sending a message from one client should display it in the server window but also in the other clients that are connected to the server!


Let’s look back at my original use case, asking John and Grace about Game of Thrones. The discussion looks like this.




Listing 3.21. Conversation between me, John and Grace about Game of Thrones




```
*Dominik said* What did you guys think about the latest Game of Thrones
episode?
*Grace said* I thought Tyrion was really great in it!
*John said* I agree with Grace. Tyrion deserves an Emmy for his performance.
```



After this discussion takes place, each persons screen will show the same messages. Except for the fact that their own messages will not be prefixed by `<name> said` where `<name>` is their name.


In order to truly see it in action you need to try this out for yourself.


The server should display the following information after this exchange.




Figure 3.19. The server’s output


![ch03 final 4](../Images/ch03_final_4.png)

That should be the final result. If you got lost somewhere along the way, or just couldn’t get the code to compile for some reason, or the code doesn’t work as it should then you can download all the book’s code examples from <https://github.com/dom96/nim-in-action-code>.


You can now even send the client binary to one of your friends and have them chat with you. You may need to do it over your LAN or forward ports on your router for it to work though.


There is also a lot of room for improvement. I have set the username of each client to "Anonymous" on purpose, to hopefully encourage you to make that configurable for each client similar to the way the server address can be changed. This functionality is present in the screenshots shown throughout this chapter. Other improvements are more involved, like making sure that the clients are still connected by sending special "PING" messages or adding the ability to kick users from the server. I’m sure there are things which you, the creative reader, will come up with too.




  


[[13]](#d5e3595) Node fs.readFile documentation, <https://nodejs.org/api/fs.html#fs_fs_readfile_filename_options_callback>




[[14]](#d5e3630) Creating a single `readFile` procedure would be a fairly trivial undertaking, I leave the challenge of creating such a procedure to you.




[[15]](#d5e3818) Most of the easy to remember ports are used by other applications, <https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>







3.6  Summary
============




* The architecture of a chat application, including comparisons between the client-server and peer-to-peer models and the common Internet protocols such as TCP and UDP.
* Setting up your first Nim project and compiling it, including additional flags to customize the compilation process and the Nim config files which can be used to house these flags.
* Retrieving command-line arguments using the `paramStr` procedure.
* Reading lines from the standard input stream using `readLine`.
* Solving the blocking problem with synchronous I/O by using `spawn` to read data from the standard input stream in another thread.
* Parsing and generating JSON using the `json` module.
* Writing simple unit tests using `doAssert`.
* Transferring data over the network using the `asyncnet` module and sockets.
* Nim’s module system.





